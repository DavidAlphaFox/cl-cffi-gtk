@c -----------------------------------------------------------------------------
@c File     : gtk-getting-started.texi
@c License  : GNU General Public License (GPL)
@c Author   : Dieter Kaiser
@c Date     : 26.12.2011
@c Revision : 17.04.2012
@c 
@c Copyright (C) 2011 - 2012 by Dieter Kaiser
@c -----------------------------------------------------------------------------

@menu
* Installation::
* A Simple Window::
* More about the Lisp binding to GTK+::
* Hello World in GTK+::
* Introduction to Signals and Callbacks::
* An Upgraded Hello World::
@end menu

@c -----------------------------------------------------------------------------
@node Installation, A Simple Window, Top, Top
@section Installation

The first thing to do is to download the @code{cl-cffi-gtk} source and to
install it.  The latest version is available from the repository at
@url{github.com/crategus/cl-cffi-gtk}.  The @code{cl-cffi-gtk} library can be
loaded with the command @code{(asdf:operate 'asdf:load-op :cl-cffi-gtk)}
from the Lisp prompt.  The library is developed with the Lisp SBCL 1.0.56 on a
Linux system and GTK+ 3.2.

At this time (April 2012) there is no GTK+ 3 library for Windows available at
@url{www.gtk.org}.  The current maintained version is GTK+ 2.24.  The
repository at @url{github.com/crategus/cl-cffi-gtk} has a branch @code{gtk-2-24}
which is tested with SBCL 1.0.54 and GTK+ 2.24 on Windows.

With SBCL an alternative command to load the @code{cl-cffi-gtk} library is
@code{(asdf:load-system 'cl-cffi-gtk)}.  The libraries GLib, GObject, GDK,
Pango, and Cairo are part of GTK+ and loaded in addition with the above command.
These libraries can be loaded individually with the commands:
@verbatim
   (asdf:load-system 'cl-cffi-gtk-glib)
   (asdf:load-system 'cl-cffi-gtk-gobject)
   (asdf:load-system 'cl-cffi-gtk-gdk)
   (asdf:load-system 'cl-cffi-gtk-pango)
   (asdf:load-system 'cl-cffi-gtk-cairo)
@end verbatim

It is assumed, that the corresponding system definition files
@code{cl-cffi-gtk.asd} for GTK+, @code{cl-cffi-gtk-glib.asd} for GLib,
@code{cl-cffi-gtk-gobject.asd} for GObject, @code{cl-cffi-gtk-gdk.asd} for GDK,
@code{cl-cffi-gtk-pango.asd}, for Pango and @code{cl-cffi-gtk-cairo.asd} for
Cairo are correctly registered to @code{asdf:*central-registry*} or the
corresponding symlinks are created.

For example for SBCL on a Linux system the symlinks are added to the directory
@code{~/.sbcl/systems} with the commands:

@verbatim
   cd ~/.sbcl/systems
   ln -s /path-to-cl-cffi-gtk/gtk/cl-cffi-gtk.asd
   ln -s /path-to-cl-cffi-gtk/gdk/cl-cffi-gtk-gdk.asd
   ln -s /path-to-cl-cffi-gtk/gobject/cl-cffi-gtk-gobject.asd
   ln -s /path-to-cl-cffi-gtk/glib/cl-cffi-gtk-glib.asd
   ln -s /path-to-cl-cffi-gtk/pango/cl-cffi-gtk-pango.asd
   ln -s /path-to-cl-cffi-gtk/cairo/cl-cffi-gtk-cairo.asd
@end verbatim

The @code{cl-cffi-gtk} library depends further on the following libraries,
which must be installed:
@table @emph
@item CFFI
      the Common Foreign Function Interface, purports to be a portable
      foreign function interface for Common Lisp.
      See @url{http://common-lisp.net/project/cffi/}.
   
@item Trivial-Garbage
      provides a portable API to finalizers, weak hash-tables
      and weak pointers on all major CL implementations.
      @url{See http://www.cliki.net/trivial-garbage}.
   
@item Iterate
      is a lispy and extensible replacement for the LOOP macro.
      See @url{http://common-lisp.net/project/iterate/}.
   
@item Bordeaux-Threads
      lets you write multi-threaded applications in a portable way.
      See @url{http://common-lisp.net/project/bordeaux-threads/}.
   
@item Closer-MOP
      Closer to MOP is a compatibility layer that rectifies many of the absent
      or incorrect MOP features as detected by MOP Feature Tests.
      See @url{http://common-lisp.net/project/closer/closer-mop.html}.
@end table

@findex cl-cffi-gtk-build-info

Information about the installation can be obtained with the function
@code{cl-cffi-gtk-build-info}.  This is an example for the output, when calling
the function from the Lisp prompt after loading the library:

@example
* (cl-cffi-gtk-build-info)

cl-cffi-gtk version: 0.0.0
cl-cffi-gtk build date: 21:48 4/16/2012
GTK+ version: 3.2.0
GLIB version: 2.30.0
Pango version: 1.29.3
Cairo version: 1.10.2
Machine type: X86
Machine version: Intel(R) Pentium(R) M processor 1.73GHz
Software type: Linux
Software version: 3.0.0-19-generic
Lisp implementation type: SBCL
Lisp implementation version: 1.0.56
@end example

@c -----------------------------------------------------------------------------
@node A Simple Window, More about the Lisp binding to GTK+, Installation, Top
@section A Simple Window

The @code{cl-cffi-gtk} source distribution contains the complete source to all
of the examples used in this tutorial.  To begin the introduction to GTK+, the
output of the simplest program possible is shown in @ref{figure-simple-window}
and the Lisp code in @ref{example-simple-window}.

@ifnotinfo
@float Figure, figure-simple-window
@caption{A Simple Window}
@center @image{figures/simple-window206x226, 137pt}
@end float
@end ifnotinfo

The program creates a 200 x 200 pixel window.  In this case the window has the
default title "sbcl".  The window can be sized and moved.  Because no special
action is implemented to close the window, depending on the operating system
the program might hang.  First in @ref{example-simple-window-C} the C program
of the GTK+ 2.0 Tutorial is presented to show the close connection between the
C library and the implementation of the Lisp binding.  The code of the Lisp
program is shown in @ref{example-simple-window}.

@float Example, example-simple-window-C
@caption{A simple window in the programing language C}
@end float
@verbatim
#include <gtk/gtk.h>

int main( int   argc,
          char *argv[] )
{
    GtkWidget *window;
    
    gtk_init (&argc, &argv);
    
    window = gtk_window_new (GTK_WINDOW_TOPLEVEL);
    gtk_widget_show  (window);
    
    gtk_main ();

    return 0;
}
@end verbatim

@findex within-main-loop

@findex gtk-window-new
@findex gtk-widget-show
@findex gtk-widget-show-all
@findex gtk-init
@findex gtk-main

@findex window-new, gtk-window-new
@findex widget-show, gtk-widget-show
@findex widget-show-all, gtk-widget-show-all
@findex init, gtk-init
@findex main, gtk-main

@float Example, example-simple-window
@caption{A Simple Window in the programing language Lisp}
@end float
@verbatim
(asdf:operate 'asdf:load-op :cl-cffi-gtk)

(defpackage :gtk-tutorial
  (:use :gtk :gdk :gobject :glib :pango :cairo :common-lisp))

(in-package :gtk-tutorial)

(defun example-simple-window ()
  (within-main-loop
    (let (;; Create a toplevel window.
          (window (gtk-window-new :toplevel)))
      ;; Show the window.
      (gtk-widget-show-all window))))
@end verbatim

The first four lines of code load the @code{cl-cffi-gtk} library and define an
own package @code{:gtk-tutorial} for the example program. The package
@code{:gtk-tutorial} includes the symbols from the packages @code{:gtk} for GTK,
@code{:gdk} for GDK, @code{:glib} for GLib, @code{:pango} for Pango, and
@code{:cairo} for Cairo.  In further examples of this tutorial these first lines
of code are omitted.

The macro @code{within-main-loop} is a wrapper about a GTK+ program.  The
functionality of the macro corresponds to the C functions @code{gtk_init()}
and @code{gtk_main()} which initialize and start a GTK+ program.  Both functions
have corresponding Lisp functions with the names @code{gtk-init} and
@code{gtk-main}, but these functions are not used in this tutorial.
@code{gtk-init} is automatically called when loading the Lisp library
@code{cl-cffi-gtk} and the function @code{gtk-main} is called from the macro
@code{within-main-loop}.

Only two further functions are needed in this simple example.  The window is
created with the function @code{gtk-window-new}.  The keyword @code{:toplevel}
tells GTK+ to create a toplevel window.  The second call
@code{gtk-widget-show-all} displays the new window.

In addition to the function @code{gtk-widget-show-all} the function
@code{gtk-widget-show} is available.  The function @code{gtk-widget-show} only
displays the widget, which is the argument to the function.  The function
@code{gtk-widget-show-all} displays the window and all including child widgets.
For the first simple window this makes no difference, because the window has
not child widgets.

@c -----------------------------------------------------------------------------
@node More about the Lisp binding to GTK+, Hello World in GTK+, A Simple Window, Top
@section More about the Lisp binding to GTK+

@findex GtkWindow
@findex gtk-window
@findex window, gtk-window
@findex make-instance

@ref{figure-getting-started} and @ref{example-getting-started} show a second
implementation of the simple program discussed in @ref{A Simple Window}.
The second implementation uses the fact, that all GTK+ widgets are internally
represented in the Lisp binding through a Lisp class.  The Lisp class
@code{gtk-window} represents the required window, which corresponds to the C
class @code{GtkWindow}.  An instance of the Lisp class @code{gtk-window} can be
created with the function @code{make-instance}.  Furthermore, the slots of the
window class can be given new values to overwrite the default values.  These
slots represent the properties of the C classes.  @ref{GtkWindow} shows a
list of properties, which are available for an instance of the class
@code{GtkWindow}.  In addition an instance has all properties of the inherited
classes.  The object hierarchy shows, that the class @code{GtkWindow} inherits
all properties of the classes @code{GtkWidget}, @code{GtkContainer}, and
@code{GtkBin}.

@ifnotinfo
@float Figure, figure-getting-started
@caption{Getting started}
@center @image{figures/getting-started256x226, 171pt}
@end float
@end ifnotinfo

@findex type
@findex title
@findex default-width

In @ref{example-getting-started} the property @code{type} with the keyword
@code{:toplevel} creates again a toplevel window.  In addition a title is set
assigning the string @code{"Getting started"} to the property @code{title} and
the width of the window is a little enlarged assigning the value @code{250} to
the property @code{default-width}.  @code{title}, @code{type}, and
@code{default-width} are properties of the class @code{GtkWindow} as shown in
@ref{GtkWindow}.  The result of the example program is shown in
@ref{figure-getting-started}.

@findex GtkWindowType
@findex gtk-window-type
@findex GTK_WINDOW_TOPLEVEL
@findex GTK_WINDOW_POPUP

@findex window-type, gtk-window-type
@findex :toplevel
@findex :popup

The keyword @code{:toplevel} is one of the values of the enumeration type
@code{GtkWindowType} in C.  In the Lisp binding this enumeration is implemented
as @code{gtk-window-type} with the two possible keywords @code{:toplevel}
for @code{GTK_WINDOW_TOPLEVEL} and @code{:popup} for @code{GTK_WINDOW_POPUP}.
Most windows are of the type @code{:toplevel}.  Windows with this type are
managed by the window manager and have a frame by default.  Windows with type
@code{:popup} are ignored by the window manager and are used to implement
widgets such as menus or tooltips.

@float Example, example-getting-started
@caption{Getting Started}
@end float
@verbatim
(defun example-simple-window-2 ()
  (within-main-loop
    (let (;; Create a toplevel window with a title and a default width.
          (window (make-instance 'gtk-window
                                 :type :toplevel
                                 :title "Getting started"
                                 :default-width 250)))
      ;; Show the window.
      (gtk-widget-show-all window))))
@end verbatim

The @ref{example-getting-started} shows, that the Lisp function
@code{gtk-window-new} is not really needed.  The function @code{gtk-window-new}
is internally implemented in the Lisp binding simply as

@example
(defun gtk-window-new (type)
  (make-instance 'gtk-window :type type))
@end example

@findex gtk-window-set-title
@findex gtk-window-set-default-size

@findex window-set-title, gtk-window-set-title
@findex window-set-default-size, gkt-window-set-default-size

To set the title of the window or to change the default width of a window the
C library knows accessor functions to set the corresponding values.  In C the
title of the window is set with the function @code{gtk_window_set_title()}.
The corresponding Lisp function is @code{gtk-window-set-title}.  Accordingly,
the default width of the window can be set in C with the function
@code{gtk_window_set_default_size()}, which sets both the default width and the
default height.  In Lisp this function is named
@code{gtk-window-set-default-size}.  As we have seen, these Lisp accessor
functions are not really needed when creating a window, but the functions are
provided to allow the user to translate a C program more easy to Lisp.

@findex default-width
@findex default-height

@findex gtk-window-default-width
@findex gtk-window-default-height
@findex gtk-window-set-default-size
@findex gtk-window-get-default-size

@findex window-default-width, gtk-window-default-width
@findex window-default-height, gtk-window-default-height
@findex window-set-default-size, gtk-window-set-default-size
@findex window-get-default-size, gtk-window-get-default-size

At last, in Lisp it is possible to use the accessors of the slots to get or
set the value of a widget property.  The properties @code{default-width} and
@code{default-height} of the Lisp class @code{gtk-window} have the Lisp
accessor functions @code{gtk-window-default-width} and
@code{gtk-window-default-height}.  With these accessor functions the C function
@code{gtk_window_set_default_size()} is implemented the following way in the
Lisp library

@example
(defun gtk-window-set-default-size (window width height)
  (setf (gtk-window-default-width window) width
        (gtk-window-default-height window) height))
@end example

As a second example the Lisp implementation of the C function
@code{gtk_window_get_default_size()} is shown

@example
(defun gtk-window-get-default-size (window)
  (values (gtk-window-default-width window)
          (gtk-window-default-height window)))
@end example

In distinction to the C function @code{gtk_window_get_default_size()}, which is
implemented as

@example
void gtk_window_get_default_size (GtkWindow *window,
                                  gint *width, gint *height)
@end example

the Lisp implementation does not modify the arguments @code{width} and
@code{height}, but returns the values.

@c -----------------------------------------------------------------------------
@node Hello World in GTK+, Introduction to Signals and Callbacks, More about the Lisp binding to GTK+, Top
@section Hello World in GTK+

Now a program with a button is presented.  The output is shown in
@ref{figure-hello-world}.  Again the C program from the GTK+ 2.0 Tutorial is
shown first in @ref{example-hello-world-C} to learn more about the differences
between a C and a Lisp implementation.

@ifnotinfo
@float Figure, figure-hello-world
@caption{Hello World}
@center @image{figures/hello-world256x79, 171pt}
@end float
@end ifnotinfo

@float Example, example-hello-world-C
@caption{Hello World in the programing language C}
@end float
@verbatim
#include <gtk/gtk.h>

/* This is a callback function. The data arguments are ignored
 * in this example. More on callbacks below. */
static void hello( GtkWidget *widget,
                   gpointer   data )
{
    g_print ("Hello World\n");
}

static gboolean delete_event( GtkWidget *widget,
                              GdkEvent  *event,
                              gpointer   data )
{
    /* If you return FALSE in the "delete-event" signal handler,
     * GTK will emit the "destroy" signal. Returning TRUE means
     * you don't want the window to be destroyed.
     * This is useful for popping up 'are you sure you want to quit?'
     * type dialogs. */

    g_print ("delete event occurred\n");

    /* Change TRUE to FALSE and the main window will be destroyed with
     * a "delete-event". */

    return TRUE;
}

/* Another callback */
static void destroy( GtkWidget *widget,
                     gpointer   data )
{
    gtk_main_quit ();
}

int main( int   argc,
          char *argv[] )
{
    /* GtkWidget is the storage type for widgets */
    GtkWidget *window;
    GtkWidget *button;
    
    /* This is called in all GTK applications. Arguments are parsed
     * from the command line and are returned to the application. */
    gtk_init (&argc, &argv);
    
    /* create a new window */
    window = gtk_window_new (GTK_WINDOW_TOPLEVEL);
    
    /* When the window is given the "delete-event" signal (this is given
     * by the window manager, usually by the "close" option, or on the
     * titlebar), we ask it to call the delete_event () function
     * as defined above. The data passed to the callback
     * function is NULL and is ignored in the callback function. */
    g_signal_connect (window, "delete-event",
		      G_CALLBACK (delete_event), NULL);
    
    /* Here we connect the "destroy" event to a signal handler.  
     * This event occurs when we call gtk_widget_destroy() on the window,
     * or if we return FALSE in the "delete-event" callback. */
    g_signal_connect (window, "destroy",
		      G_CALLBACK (destroy), NULL);
    
    /* Sets the border width of the window. */
    gtk_container_set_border_width (GTK_CONTAINER (window), 10);
    
    /* Creates a new button with the label "Hello World". */
    button = gtk_button_new_with_label ("Hello World");
    
    /* When the button receives the "clicked" signal, it will call the
     * function hello() passing it NULL as its argument.  The hello()
     * function is defined above. */
    g_signal_connect (button, "clicked",
		      G_CALLBACK (hello), NULL);
    
    /* This will cause the window to be destroyed by calling
     * gtk_widget_destroy(window) when "clicked".  Again, the destroy
     * signal could come from here, or the window manager. */
    g_signal_connect_swapped (button, "clicked",
			      G_CALLBACK (gtk_widget_destroy),
                              window);
    
    /* This packs the button into the window (a gtk container). */
    gtk_container_add (GTK_CONTAINER (window), button);
    
    /* The final step is to display this newly created widget. */
    gtk_widget_show (button);
    
    /* and the window */
    gtk_widget_show (window);
    
    /* All GTK applications must have a gtk_main(). Control ends here
     * and waits for an event to occur (like a key press or
     * mouse event). */
    gtk_main ();
    
    return 0;
}
@end verbatim

Now, the Lisp implementation is presented in @ref{example-hello-world}.  One
difference is, that the function @code{make-instance} is used to create the
window and the button.  Another point is, that the definition of separate
callback functions is avoided.  The callback functions are short, implemented
through Lisp @code{lambda} functions and are passed as the third argument to
the function @code{g-signal-connect}.  More about signals and callback
functions follows in @ref{Introduction to Signals and Callbacks}.

@findex GtkContainer

@findex gtk-container
@findex gtk-container-border-width
@findex gtk-container-set-border-width

@findex border-width
@findex container, gtk-container
@findex container-border-width, gtk-container-border-width
@findex container-set-border-width, gtk-container-set-border-width

In @ref{example-hello-world} a border with a width of @code{12} is added to
the window setting the property @code{border-width} when creating the window
with the function @code{make-instance}.  The C implementation uses the function
@code{gtk_container_set_border_width()} which is available in Lisp as
@code{gtk-container-set-border-width}.  The property @code{border-width} is
inherited from the C class @code{GtkContainer}, which in the Lisp library is
represented through the Lisp class @code{gtk-container}.  Therefore, the
accessor function has the prefix @code{gtk_container} in C and
@code{gtk-container} in Lisp.  In addition Lisp knows the accessor function
@code{gtk-container-border-width} to set or to get the property
@code{border-width}.  A full list of properties of @code{GtkContainer} is
available in @ref{GtkContainer}.

@float Example, example-hello-world
@caption{Hello World in the programing language Lisp}
@end float
@verbatim
(defun example-hello-world ()
  (within-main-loop
    (let (;; Create a toplevel window, set a border width.
          (window (make-instance 'gtk-window
                                 :type :toplevel
                                 :title "Hello World"
                                 :default-width 250
                                 :border-width 12))
          ;; Create a button with a label.
          (button (make-instance 'gtk-button :label "Hello World")))
      ;; Signal handler for the button to handle the signal "clicked".
      (g-signal-connect button "clicked"
                        (lambda (widget)
                          (declare (ignore widget))
                          (format t "Hello world.~%")
                          (gtk-widget-destroy window)))
      ;; Signal handler for the window to handle the signal "destroy".
      (g-signal-connect window "destroy"
                        (lambda (widget)
                          (declare (ignore widget))
                          (gtk-main-quit)))
      ;; Signal handler for the window to handle the signal "delete-event".
      (g-signal-connect window "delete-event"
                        (lambda (widget event)
                          (declare (ignore widget event))
                          (format t "Delete Event Occured.~%")
                          t))
      ;; Put the button into the window.
      (gtk-container-add window button)
      ;; Show the window and the button.
      (gtk-widget-show-all window))))
@end verbatim

@findex gtk-widget-show
@findex widget-show, gtk-widget-show

An attentive reader notes that in distinction to the C implementation the
function @code{gtk-widget-show} is not called for every single widget, which are
in @ref{example-hello-world} the window and the button.  Instead the function
@code{gtk-widget-show-all} is used to display the window with all including
widgets.

@findex gtk-widget-destroy
@findex gtk-main-quit
@findex gtk-container-add

@findex widget-destroy, gtk-widget-destroy
@findex main-quit, gtk-main-quit
@findex container-add, gtk-container-add

Three more functions are used in @ref{example-hello-world}.  The function
@code{gtk-widget-destroy} takes as an argument any widget and destroys it.  In
the above example this function is called by the signal handler of the button.
When the button is clicked by the user, the signal "clicked" is catched by the
signal handler, which causes a call of the function @code{gtk-widget-destroy}
for the toplevel window.  Now the toplevel window receives the signal "destroy",
which is handled by a signal handler of the toplevel window.  This signal
handler calls the function @code{gtk-main-quit}, which stops the event loop and
finishes the application.

A second signal handler is connected to the toplevel window to catch the
signal "delete-event".  The signal "delete-event" occurs, when the user or the
window manager tries to close the window.  In this case, the signal handler
prints a message on the console.   Because the value @code{T} is returned from
the signal handler the window is not closed, but the execution of the
application is continued.  To close the window, the user has to press the button
in this example.

At last, the function @code{gtk-container-add} is used to put the button into
the toplevel window.  @ref{Packing Widgets} shows how it is possible to put more
than one widget into a window.

@c -----------------------------------------------------------------------------
@node Introduction to Signals and Callbacks, An Upgraded Hello World, Hello World in GTK+, Top
@section Introduction to Signals and Callbacks

GTK+ is an event driven toolkit, which means GTK+ will sleep until an event
occurs and control is passed to the appropriate function.  This passing of
control is done using the idea of "signals".  (Note that these signals are not
the same as the Unix system signals, and are not implemented using them,
although the terminology is almost identical.)  When an event occurs, such as
the press of a mouse button, the appropriate signal will be "emitted" by the
widget that was pressed.  This is how GTK+ does most of its useful work.  There
are signals that all widgets inherit, such as "destroy", and there are signals
that are widget specific, such as "toggled" on a toggle button.

To make a button perform an action, a signal handler is set up to catch these
signals and call the appropriate function.  This is done in the C GTK+ library
by using a function such as

@example
gulong g_signal_connect( gpointer      *object,
                         const gchar   *name,
                         GCallback     func,
                         gpointer      func_data );
@end example

where the first argument is the widget which will be emitting the signal, and
the second the name of the signal to catch.  The third is the function
to be called when the signal is caught, and the fourth, the data to have passed
to this function.

The function specified in the third argument is called a "callback function",
and is for a C program of the form

@example
void callback_func( GtkWidget *widget,
                    ... /* other signal arguments */
                    gpointer   callback_data );
@end example

where the first argument will be a pointer to the widget that emitted the
signal, and the last a pointer to the data given as the last argument to the C
function @code{g_signal_connect()} as shown above.  Note that the above form for
a signal callback function declaration is only a general guide, as some widget
specific signals generate different calling parameters.

@findex g-signal-connect
@findex signal-connect, g-signal-connect

This mechanism is realized in Lisp with a similar function
@code{g-signal-connect} which has the arguments @code{widget}, @code{name},
and @code{func}.  In distinction from C the Lisp function
@code{g-signal-connect} has not the argument @code{func_data}.  The
functionality of passing data to a callback function can be realized with the
help of a @code{lambda} function in Lisp.

As an example the following code shows a typical C implementation which is used
in the Hello World program.

@example
g_signal_connect (window, "destroy", G_CALLBACK (destroy), NULL);
@end example

This is the corresponding callback function which is called when the event
"destroy" occurs.

@example
static void destroy (GtkWidget *widget, gpointer data)
@{
    gtk_main_quit ();
@}
@end example

In the corresponding Lisp implementation we simply declare a @code{lambda}
function as a callback function which is passed as the third argument.

@example
(g-signal-connect window "destroy"
                  (lambda (widget)
                    (declare (ignore widget))
                    (gtk-main-quit)))
@end example

If it is necessary to have a separate function which needs user data, the
following implementation is possible

@example
(defun separate-event-handler (widget arg1 arg2 arg3)
  [ here is the code of the event handler ] )
@end example

@example
(g-signal-connect window "destroy"
                  (lambda (widget)
                    (separate-event-handler widget arg1 arg2 arg3)))
@end example

If no extra data is needed, but the callback function should be separated out
than it is also possible to implement something like

@example
(g-signal-connect window "destroy" #'separate-event-handler)
@end example

Furthermore, the C function 

@example
gulong g_signal_connect_swapped (gpointer    *object,
                                 const gchar *name,
                                 GCallback   func,
                                 gpointer    *callback_data);
@end example

is not implemented in Lisp.  Again this functionality is already present with
the help of @code{lambda} functions in Lisp.

@c -----------------------------------------------------------------------------
@node An Upgraded Hello World, , Introduction to Signals and Callbacks, Top
@section An Upgraded Hello World

@ref{figure-upgraded-hello-world} and @ref{example-upgraded-hello-world} show
a slightly improved Hello World with better examples of callbacks.  This will
also introduce the next topic, packing widgets.  First, the C program is shown
in @ref{example-upgraded-hello-world-C}.

@ifnotinfo
@float Figure, figure-upgraded-hello-world
@caption{Upgraded Hello World}
@center @image{figures/upgraded-hello-world256x101, 171pt}
@end float
@end ifnotinfo

@float Example, example-upgraded-hello-world-C
@caption{An upgraded Hello World in the programing language C}
@end float
@verbatim
#include <gtk/gtk.h>

/* Our new improved callback.  The data passed to this function
 * is printed to stdout. */
static void callback( GtkWidget *widget,
                      gpointer   data )
{
    g_print ("Hello again - %s was pressed\n", (gchar *) data);
}

/* another callback */
static gboolean delete_event( GtkWidget *widget,
                              GdkEvent  *event,
                              gpointer   data )
{
    gtk_main_quit ();
    return FALSE;
}

int main( int   argc,
          char *argv[] )
{
    /* GtkWidget is the storage type for widgets */
    GtkWidget *window;
    GtkWidget *button;
    GtkWidget *box1;

    /* This is called in all GTK applications. Arguments are parsed
     * from the command line and are returned to the application. */
    gtk_init (&argc, &argv);

    /* Create a new window */
    window = gtk_window_new (GTK_WINDOW_TOPLEVEL);

    /* This is a new call, which just sets the title of our
     * new window to "Hello Buttons!" */
    gtk_window_set_title (GTK_WINDOW (window), "Hello Buttons!");

    /* Here we just set a handler for delete_event that immediately
     * exits GTK. */
    g_signal_connect (window, "delete-event",
		      G_CALLBACK (delete_event), NULL);

    /* Sets the border width of the window. */
    gtk_container_set_border_width (GTK_CONTAINER (window), 10);

    /* We create a box to pack widgets into.  This is described in detail
     * in the "packing" section. The box is not really visible, it
     * is just used as a tool to arrange widgets. */
    box1 = gtk_hbox_new (FALSE, 0);

    /* Put the box into the main window. */
    gtk_container_add (GTK_CONTAINER (window), box1);

    /* Creates a new button with the label "Button 1". */
    button = gtk_button_new_with_label ("Button 1");
    
    /* Now when the button is clicked, we call the "callback" function
     * with a pointer to "button 1" as its argument */
    g_signal_connect (button, "clicked",
		      G_CALLBACK (callback), (gpointer) "button 1");

    /* Instead of gtk_container_add, we pack this button into the invisible
     * box, which has been packed into the window. */
    gtk_box_pack_start (GTK_BOX(box1), button, TRUE, TRUE, 0);

    /* Always remember this step, this tells GTK that our preparation for
     * this button is complete, and it can now be displayed. */
    gtk_widget_show (button);

    /* Do these same steps again to create a second button */
    button = gtk_button_new_with_label ("Button 2");

    /* Call the same callback function with a different argument,
     * passing a pointer to "button 2" instead. */
    g_signal_connect (button, "clicked",
		      G_CALLBACK (callback), (gpointer) "button 2");

    gtk_box_pack_start(GTK_BOX (box1), button, TRUE, TRUE, 0);

    /* The order in which we show the buttons is not really important, but I
     * recommend showing the window last, so it all pops up at once. */
    gtk_widget_show (button);

    gtk_widget_show (box1);

    gtk_widget_show (window);
    
    /* Rest in gtk_main and wait for the fun to begin! */
    gtk_main ();

    return 0;
}
@end verbatim

@findex gtk-box-new
@findex box-new, gtk-box-new
@findex :horizontal

The Lisp implementation in @ref{example-upgraded-hello-world} tries to be close
to the C program.  Therefore, the window and the box are created with the
functions @code{gtk-window-new} and @code{gtk-box-new}.  Various properties
like the title of the window, the default size or the border width are set with
the functions @code{gtk-window-set-title}, @code{gtk-window-set-default-size}
and @code{gtk-container-set-border-width}.  As described for
@ref{example-hello-world} the function @code{gtk-widget-show-all} is used to
display the window including all child widgets.

One main difference of the Lisp implementation is the use of the function
@code{gtk-box-new} with an argument @code{:horizontal} to create a horizontal
box.  The @code{GtkHBox} widget which is used in the GTK+ 2.0 Tutorial is
deprecated and is replaced by @code{GtkBox} with the property
@code{orientation}.  More about boxes and their usages follows in
@ref{Packing Widgets}.

@float Example, example-upgraded-hello-world
@caption{Upgraded Hello world}
@end float
@verbatim
(defun example-upgraded-hello-world ()
  (within-main-loop
    (let ((window (gtk-window-new :toplevel))
          (box (gtk-box-new :horizontal 6))
          (button  nil))
      (g-signal-connect window "destroy"
                        (lambda (widget)
                          (declare (ignore widget))
                          (gtk-main-quit)))
      (gtk-window-set-title window "Hello Buttons")
      (gtk-window-set-default-size window 250 75)
      (gtk-container-set-border-width window 12)
      (setq button (gtk-button-new-with-label "Button 1"))
      (g-signal-connect button "clicked"
                        (lambda (widget)
                          (declare (ignore widget))
                          (format t "Button 1 was pressed.~%")))
      (gtk-box-pack-start box button :expand t :fill t :padding 0)
      (setq button (gtk-button-new-with-label "Button 2"))
      (g-signal-connect button "clicked"
                        (lambda (widget)
                          (declare (ignore widget))
                          (format t "Button 2 was pressed.~%")))
      (gtk-box-pack-start box button :expand t :fill t :padding 0)
      (gtk-container-add window box)
      (gtk-widget-show-all window))))
@end verbatim

The second implementation in @ref{example-upgraded-hello-world-2} makes
more use of a Lisp style.  The window is created with the Lisp function
@code{make-instance}.  All desired properties of the window are initialized by
assigning values to the slots of the classes @code{gtk-window} and
@code{gtk-box}.  The Lisp implementation uses a lot keywords arguments with
default values for long lists of arguments.  In
@ref{example-upgraded-hello-world-2} the keyword arguments @code{expand},
@code{fill}, and @code{padding} of the function @code{gtk-box-pack-start} take
their default values.  In future examples of this tutorial the style shown in
@ref{example-upgraded-hello-world-2} is preferred.  Furthermore, the C code is
no longer presented for comparison.

@float Example, example-upgraded-hello-world-2
@caption{Second implementation of an Upgraded Hello World}
@end float
@verbatim
(defun example-upgraded-hello-world-2 ()
  (within-main-loop
    (let ((window (make-instance 'gtk-window 
                                 :type :toplevel
                                 :title "Hello Buttons"
                                 :default-width 250
                                 :default-height 75
                                 :border-width 12))
          (box (make-instance 'gtk-box
                              :orientation :horizontal
                              :spacing 6)))
      (g-signal-connect window "destroy"
                        (lambda (widget)
                          (declare (ignore widget))
                          (gtk-main-quit)))
      (let ((button (gtk-button-new-with-label "Button 1")))
        (g-signal-connect button "clicked"
                          (lambda (widget)
                            (declare (ignore widget))
                            (format t "Button 1 was pressed.~%")))
        (gtk-box-pack-start box button))
      (let ((button (gtk-button-new-with-label "Button 2")))
        (g-signal-connect button "clicked"
                          (lambda (widget)
                            (declare (ignore widget))
                            (format t "Button 2 was pressed.~%")))
        (gtk-box-pack-start box button))
      (gtk-container-add window box)
      (gtk-widget-show-all window))))
@end verbatim

