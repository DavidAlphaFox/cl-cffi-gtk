<!DOCTYPE book [

<!ENTITY % tutorial-entities SYSTEM "tutorial-entities.xml">
%tutorial-entities;

]>

<book xmlns="http://docbook.org/ns/docbook" version ="5.0"
      xmlns:xi="http://docbook.sourceforge.net/release/xsl/current/xhtml5/docbook.xsl">

 <title>GTK 3 Tutorial for Lisp</title>
 <subtitle>
   Using the <ulink url="http://crategus.com/books/cl-cffi-gtk">
   cl-cffi-gtk</ulink> library for writing Lisp programs
 </subtitle>

 <bookinfo>
  <legalnotice>
    <para>Copyright (C) 2012 - 2021 Dieter Kaiser</para>
  </legalnotice>
  <author>
   <personname>
    <firstname>Dieter</firstname><surname>Kaiser</surname>
   </personname>
  </author>
 </bookinfo>

 <preface revision="2021-5-12"> 
  <title>Introduction</title>
  <para>
   The <code>cl-cffi-gtk</code> library is a Lisp binding to GTK (GIMP Toolkit) which is a library for
   creating graphical user interfaces. GTK is licensed using the LGPL which has been adopted for the
   <code>cl-cffi-gtk</code> library with a preamble that clarifies the terms for use with Lisp programs and
   is referred as the LLGPL.
  </para>
  <para>
   This work is based on the <code>cl-gtk2</code> library which has been developed by Kalyanov Dmitry and
   already is a fairly complete Lisp binding to GTK. The focus of the <code>cl-cffi-gtk</code> library is
   to document the Lisp library much more complete and to do the implementation as consistent as possible.
   Most information about GTK can be gained by reading the C documentation. Therefore, the C documentation
   from <ulink url="https://developer.gnome.org/gtk3/stable/">GTK 3 Reference Manual</ulink> is included
   into the Lisp files as an API documentation to document the Lisp binding to the GTK library. This way the
   calling conventions are easier to determine and missing functionality is easier to detect. The Lisp API
   documentation is available online at <ulink url="http://crategus.com/books/cl-cffi-gtk">
   cl-cffi-gtk API documentation</ulink>.
  </para>
  <para>
   The GTK library is called the GIMP toolkit because GTK was originally written for developing the GNU
   Image Manipulation Program (GIMP), but GTK has now been used in a large number of software projects,
   including the GNU Network Object Model Environment (GNOME) project. GTK is built on top of GDK (GIMP
   Drawing Kit) which is basically a wrapper around the low-level functions for accessing the underlying
   windowing functions (Xlib in the case of the X windows system), and GdkPixbuf, a library for client-side
   image manipulation.
  </para>
  <para>
   GTK is essentially an object oriented application programmers interface (API). Although written
   completely in C, GTK is implemented using the idea of classes and callback functions (pointers to
   functions).
  </para>
  <para>
   A third component is called GLib which contains replacements for standard calls, as well as additional
   functions for handling linked lists, etc. The replacement functions are used to increase the portability
   of GTK, as some of the functions implemented here are not available or are non standard on other Unixes
   such as <code>g_strerror()</code>. Some also contain enhancements to the libc versions, such as
   <code>g_malloc()</code> that has enhanced debugging utilities.
  </para>
  <para>
   In version 2.0, GLib has picked up the type system which forms the foundation for the class hierarchy of
   GTK, the signal system which is used throughout GTK, a thread API which abstracts the different native
   thread APIs of the various platforms and a facility for loading modules.
  </para>
  <para>
   As the last components, GTK uses the Pango library for internationalized text output, the Cario library,
   which is a 2D graphics library with support for multiple output devices, and the GIO library, which is a
   modern easy-to-use VFS API including abstractions for files, drives, volumes, stream IO, as well as
   network programming and DBus communication.
  </para>
  <para>
   This tutorial describes the Lisp interface to GTK. It includes a lot of material and code from different
   sources. See <link linkend="Licenses">Licences</link> for more information.
  </para>
 </preface>

 <chapter id="Getting_started" revision="2021-5-12">
  <title>Getting started</title>
  <section id="Installation" revision="2021⁻5-12">
   <title>Installation</title>
   <para>
    The first thing to do is to download the <code>cl-cffi-gtk</code> source and to install it. The latest
    version is available from the repository at <ulink url="http://github.com/crategus/cl-cffi-gtk">
    github.com/crategus/cl-cffi-gtk</ulink>. The <code>cl-cffi-gtk</code> library is ASDF installable and can
    be loaded with the command <code>(asdf:load-system :cl-cffi-gtk)</code> from the Lisp prompt. The library
    is developed with the Lisp SBCL 2.0 on a Linux system and GTK 3.24. Furthermore, the library runs
    successfully with Clozure Common Lisp and CLISP on Linux. The library compiles and the demos run with
    Windows 10.
   </para>
   <para>
    The minimum version requirements are GTK 3.16 and GLIB 2.48.
   </para>
   <para>
    GTK depends on the libraries GLib, GObject, GDK, GDK-Pixbuf, GIO, Pango, and Cairo. These libraries
    can be loaded separately with the following commands:
   </para>
   <programlisting>
(asdf:load-system 'cl-cffi-gtk-glib)
(asdf:load-system 'cl-cffi-gtk-gobject)
(asdf:load-system 'cl-cffi-gtk-gdk)
(asdf:load-system 'cl-cffi-gtk-gdk-pixbuf)
(asdf:load-system 'cl-cffi-gtk-gio)
(asdf:load-system 'cl-cffi-gtk-pango)
(asdf:load-system 'cl-cffi-gtk-cairo)
   </programlisting>
   <para>
    Please consult the ASDF documentation which is available at
    <ulink url="http://common-lisp.net/project/asdf/">common-lisp.net/project/asdf/</ulink>
    for configuring ASDF to find your systems.
   </para>
   <para>
    The <code>cl-cffi-gtk</code> library depends further on the following libraries:
   </para>
   <variablelist>
    <varlistentry>
     <term>CFFI</term>
     <listitem>
      <para>
       the Common Foreign Function Interface, purports to be a portable foreign function interface for
       Common Lisp.
       See <ulink url="http://common-lisp.net/project/cffi/">common-lisp.net/project/cffi/</ulink>.
      </para>
      <para>
       <emphasis>Warning:</emphasis> Yout must use the version 0.11.2 or newer of the CFFI library.
       Older versions of CFFI are no longer compatible with the implementation of <code>cl-cffi-gtk</code>.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>Trivial-Garbage</term>
     <listitem>
      <para>
       provides a portable API to finalizers, weak hash-tables and weak pointers on all major CL
       implementations. See <ulink url="http://common-lisp.net/project/trivial-garbage/">
       common-lisp.net/project/trivial-garbage</ulink>.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>Iterate</term>
     <listitem>
      <para>
       is a lispy and extensible replacement for the LOOP macro.
       See <ulink url="http://common-lisp.net/project/iterate/">common-lisp.net/project/iterate/</ulink>.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>Bordeaux-Threads</term>
     <listitem>
      <para>
       lets you write multi-threaded applications in a portable way.
       See <ulink url="http://common-lisp.net/project/bordeaux-threads/">
       common-lisp.net/project/bordeaux-threads/</ulink>.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>Closer-MOP</term>
     <listitem>
      <para>
       Closer to MOP is a compatibility layer that rectifies many of the absent or incorrect MOP features as
       detected by MOP Feature Tests. See
       <ulink url="http://common-lisp.net/project/closer/closer-mop.html">
       common-lisp.net/project/closer/closer-mop.html</ulink>.
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
   <para>
    Information about the installation can be obtained with the function &cl-cffi-gtk-build-info;. This is an
    example for the output, when calling the function from the Lisp prompt after loading the library:
   </para>
   <programlisting>
* (cl-cffi-gtk-build-info)

cl-cffi-gtk version: 1.0.0
cl-cffi-gtk build date: 21:37 5/12/2021
GTK version: 3.24.23
GLIB version: 2.66.1
GDK-Pixbuf version: 2.40.0
Pango version: 1.46.2
Cairo version: 1.16.0
Machine type: X86-64
Machine version: Intel(R) Core(TM) i5-4210U CPU @ 1.70GHz
Software type: Linux
Software version: 5.8.0-50-generic
Lisp implementation type: SBCL
Lisp implementation version: 2.0.6.debian
   </programlisting>
  </section>

  <section id="Simple_Window" revision="2021-5-12">
   <title>Simple Window</title>
   <para>
    The <code>cl-cffi-gtk</code> source distribution contains the complete source to all of the examples used
    in this tutorial. To begin the introduction to GTK, the output of the simplest program possible is shown
    in <xref linkend="figure-window-simple"/>.
   </para>

   <figure id="figure-window-simple">
    <title>Simple Window</title>
    <mediaobject>
     <imageobject>
      <imagedata fileref="figures/window-simple.png" format="png"></imagedata>
     </imageobject>
    </mediaobject>
   </figure>

   <para>
    The program creates a 200 x 200 pixel window. In this case the window has the default title "sbcl". The
    window can be sized and moved. First in <xref linkend="example-window-simple-c"/> the C program of the
    <ulink url="http://developer.gnome.org/gtk3/3.14/gtk-getting-started.html#id-1.2.3.3"> GTK 3 Reference
    Manual (Version 3.14)</ulink> is presented to show the close connection between the C library and the
    implementation of the Lisp binding. The code of the Lisp program is shown in
    <xref linkend="example-window-simple"/>.
   </para>

   <example id="example-window-simple-c">
    <title>Simple window in C</title>
    <programlisting>
#include &lt;gtk/gtk.h>

int main (int argc, char *argv[])
{
  GtkWidget *window;

  gtk_init (&amp;argc, &amp;argv);

  window = gtk_window_new (GTK_WINDOW_TOPLEVEL);

  g_signal_connect (window, "destroy", G_CALLBACK (gtk_main_quit), NULL);

  gtk_widget_show (window);

  gtk_main ();

  return 0;
}
    </programlisting>
   </example>
   <example id="example-window-simple">
    <title>Simple Window in Lisp</title>
    <programlisting xmlns:xi="http://www.w3.org/2001/XInclude">
<xi:include href="../demo/gtk-example/window-simple.lisp" parse="text"/>
    </programlisting>
   </example>

   <para>
    The examples of this tutorial are defined in the package <code>:gtk-example</code>. The package
    <code>:gtk-example</code> includes the symbols from the packages <code>:gtk</code> for GTK,
    <code>:gdk</code> for GDK, <code>:gdk-pixbuf</code> for GDK-Pixbuf, <code>:gobject</code> for GObject,
    <code>:glib</code> for GLib, <code>:gio</code> for GIO, <code>:pango</code> for Pango, and
    <code>:cairo</code> for Cairo. Most of the symbols of the included packages are not needed for the first
    simple examples, but we include all packages so later no symbol is missing.
   </para>
   <para>
    You can load this package on the Lisp prompt and execute the examples of this tutorial. You can start the
    first example the following way:
   </para>
   <programlisting>
* (asdf:load-system :gtk-example)
T
* (gtk-example:example-window-simple)
#&lt;SB-THREAD:THREAD "cl-cffi-gtk main thread" RUNNING {10040EEB83}&gt;
1
*
   </programlisting>
   <para>
    The macro &within-main-loop; is a wrapper around a GTK program. The functionality of the macro corresponds
    to the C functions <code>gtk_init()</code> and <code>gtk_main()</code> which initialize and start a GTK
    program. Both functions have corresponding Lisp functions. The function <code>gtk_main()</code> is
    exported as the Lisp function &gtk-main;. The corresponding Lisp function to <code>gtk_init()</code> is
    called internally when loading the library, but is not exported.
   </para>
   <para>
    Already in this simple example, a signal is connected to the created window. More about signals and
    callback functions follows in <xref linkend="Introduction_to_Signals_and_Callbacks"/>. The  "destroy"
    signal is emitted when the user quits the window. The function &g-signal-connect; connects a Lisp
    lambda function to this signal, which calls the function &leave-gtk-main; to destroy the GTK main loop.
    Like the macro &within-main-loop; the function &leave-gtk-main; is special for the Lisp binding. It calls
    internally the C function <code>gtk_main_quit()</code>, but does some extra work to finish the Lisp
    program.
   </para>
   <para>
    Only two further functions are needed in this simple example. The window is created with the function
    &gtk-window-new;. The keyword <code>:toplevel</code> tells GTK to create a toplevel window. The second
    function &gtk-widget-show-all; displays the new window.
   </para>
   <para>
    In addition to the function &gtk-widget-show-all; the function &gtk-widget-show; is available. It only
    displays the widget, which is the argument to the function. The function &gtk-widget-show-all; displays
    the window and all the child widgets it contains. For the first simple window, this makes no difference,
    because the window has no child widgets.
   </para>
  </section>

  <section id="More_about_the_Lisp_binding_to_GTK" revision="2021-5-13">
   <title>More about the Lisp binding to GTK</title>
   <para>
    <xref linkend="figure-getting-started"/> and <xref linkend="example-getting-started"/> show a second
    implementation of the simple program discussed in section <xref linkend="Simple_Window"/>. The second
    implementation uses the fact, that all GTK widgets are internally represented in the Lisp binding through
    a Lisp class. The Lisp class &gtk-window; represents the required window, which corresponds to the C
    class <code>GtkWindow</code>. An instance of the Lisp class &gtk-window; can be created with the function
    <code>make-instance</code>. Furthermore, the slots of the window class can be given new values to
    overwrite the default values. These slots represent the properties of the C classes. In addition an
    instance has all properties of the inherited classes. The object hierarchy in the
    <ulink url="http://crategus.com/books/cl-cffi-gtk">cl-cffi-gtk API documentation</ulink> shows, that the
    &gtk-window; class inherits all properties of the &gtk-widget;, &gtk-container;, and &gtk-bin; classes.
   </para>

   <figure id="figure-getting-started">
    <title>Getting started</title>
    <mediaobject>
     <imageobject>
      <imagedata fileref="figures/getting-started.png" format="png"></imagedata>
     </imageobject>
    </mediaobject>
   </figure>

   <para>
    In <xref linkend="example-getting-started"/> the &gtk_window_type; property with the keyword
    <code>:toplevel</code> creates again a toplevel window. In addition a title is set assigning the string
    "Getting started" to the &gtk_window_title; property and the width of the window is a little enlarged
    assigning the value 250 to the &gtk_window_default-width; property. The result of the example program is
    shown in figure <xref linkend="figure-getting-started"/>.
   </para>
   <para>
    The keyword <code>:toplevel</code> is one of the values of the <code>GtkWindowType</code> enumeration in
    C. In the Lisp binding this enumeration is implemented as the &gtk-window-type; enumeration with the two
    possible keywords <code>:toplevel</code> for <code>GTK_WINDOW_TOPLEVEL</code> and <code>:popup</code> for
    <code>GTK_WINDOW_POPUP</code>. Most windows are of the type <code>:toplevel</code>. Windows with this
    type are managed by the window manager and have a frame by default. Windows with type <code>:popup</code>
    are ignored by the window manager and are used to implement widgets such as menus or tooltips.
   </para>

   <example id="example-getting-started">
    <title>Getting started</title>
    <programlisting xmlns:xi="http://www.w3.org/2001/XInclude">
<xi:include href="../demo/gtk-example/getting-started.lisp" parse="text"/>
    </programlisting>
   </example>

   <para>
    <xref linkend="example-getting-started"/> shows, that the Lisp function &gtk-window-new; is not needed.
    The function &gtk-window-new; is internally implemented in the Lisp binding simply as:
   </para>
   <programlisting>
(defun gtk-window-new (type)
  (make-instance 'gtk-window :type type))
   </programlisting>
   <para>
    To set the title of the window or to change the default width of a window the C library knows accessor
    functions to set the corresponding values. In C the title of the window is set with the function
    <code>gtk_window_set_title()</code>. The corresponding Lisp function is &gtk-window-title;. Accordingly,
    the default width of the window can be set in C with the function
    <code>gtk_window_set_default_size()</code>, which sets both the default width and the default height. In
    Lisp this function is implemented as &gtk-window-default-size;.
   </para>
   <para>
    At last, in Lisp it is possible to use the accessors of the slots to get or set the value of a widget
    property. The &gtk_window_default-width; and &gtk_window_default-height; properties of the Lisp
    &gtk-window; class have the Lisp slot access functions &gtk-window-default-width; and
    &gtk-window-default-height;. With these slot access functions the C function
    <code>gtk_window_set_default_size()</code> is implemented the following way in the Lisp library as the
    function <code>(setf gtk-window-default-size)</code>:
   </para>
   <programlisting>
(defun (setf gtk-window-default-size) (size window)
  (destructuring-bind (width height) size
     (values (setf (gtk-window-default-width window) width)
             (setf (gtk-window-default-height window) height))))
   </programlisting>
   <para>
    As a second example the Lisp implementation of the C function <code>gtk_window_get_default_size()</code>
    is shown:
   </para>
   <programlisting>
(defun gtk-window-default-size (window)
  (values (gtk-window-default-width window)
          (gtk-window-default-height window)))
   </programlisting>
   <para>
    In distinction to the C function <code>gtk_window_get_default_size()</code>, which is implemented as
   </para>
   <programlisting>
void gtk_window_get_default_size (GtkWindow *window,
                                  gint      *width,
                                  gint      *height)
   </programlisting>
   <para>
    the Lisp implementation does not modify the arguments <code>width</code> and <code>height</code>, but
    returns the values.
   </para>
   <para>
    Note the naming conventions for the translation of C accessor functions to Lisp slot access functions.
    C reader functions with the name <code>gtk_&#x3c;class>_get_&#x3c;property></code> get the Lisp name
    <code>gtk-&#x3c;class>-&#x3c;property></code> and the C writer functions
    <code>gtk_&#x3c;class>_set_&#x3c;property></code> are replaced by the corresponding
    <code>(setf gtk-&#x3c;class>-&#x3c;property>)</code> functions. That is, for example, to get the
    &gtk_window_title; property of a &gtk-window; class use the slot access function &gtk-window-title; and
    to set the title use the slot access function <code>(setf gtk-window-title)</code>.
   </para>
  </section>

  <section id="Hello_World_in_GTK" revision="2021-5-13">
   <title>Hello World in GTK</title>
   <para>
    Now a program with a button is presented. The output is shown in <xref linkend="figure-hello-world"/>.
    Again the C program from the <ulink url="http://developer.gnome.org/gtk3/3.14/gtk-getting-started.html">
    GTK 3 Reference Manual</ulink> is shown first in <xref linkend="example-hello-world-c"/> to illustrate
    the differences between a C and a Lisp implementation.
   </para>

   <example id="example-hello-world-c">
    <title>Hello World in C</title>
    <programlisting>
#include &#x3c;gtk/gtk.h>

/* This is a callback function. The data arguments are ignored
 * in this example. More on callbacks below. */
static void hello( GtkWidget *widget, gpointer data )
{
    g_print ("Hello World\n");
}

static gboolean delete_event( GtkWidget *widget,
                              GdkEvent  *event,
                              gpointer   data )
{
    /* If you return FALSE in the "delete-event" signal handler,
     * GTK will emit the "destroy" signal. Returning TRUE means
     * you don't want the window to be destroyed.
     * This is useful for popping up 'are you sure you want to quit?'
     * type dialogs. */

    g_print ("delete event occurred\n");

    /* Change TRUE to FALSE and the main window will be destroyed with
     * a "delete-event". */

    return TRUE;
}

/* Another callback */
static void destroy( GtkWidget *widget, gpointer data )
{
    gtk_main_quit ();
}

int main( int argc, char *argv[] )
{
    /* GtkWidget is the storage type for widgets */
    GtkWidget *window;
    GtkWidget *button;

    /* This is called in all GTK applications. Arguments are parsed
     * from the command line and are returned to the application. */
    gtk_init (&#x26;argc, &#x26;argv);

    /* create a new window */
    window = gtk_window_new (GTK_WINDOW_TOPLEVEL);

    /* When the window is given the "delete-event" signal (this is given
     * by the window manager, usually by the "close" option, or on the
     * titlebar), we ask it to call the delete_event () function
     * as defined above. The data passed to the callback
     * function is NULL and is ignored in the callback function. */
    g_signal_connect (window, "delete-event",
		      G_CALLBACK (delete_event), NULL);

    /* Here we connect the "destroy" event to a signal handler.
     * This event occurs when we call gtk_widget_destroy() on the window,
     * or if we return FALSE in the "delete-event" callback. */
    g_signal_connect (window, "destroy",
		      G_CALLBACK (destroy), NULL);

    /* Sets the border width of the window. */
    gtk_container_set_border_width (GTK_CONTAINER (window), 10);

    /* Creates a new button with the label "Hello World". */
    button = gtk_button_new_with_label ("Hello World");

    /* When the button receives the "clicked" signal, it will call the
     * function hello() passing it NULL as its argument.  The hello()
     * function is defined above. */
    g_signal_connect (button, "clicked",
		      G_CALLBACK (hello), NULL);

    /* This will cause the window to be destroyed by calling
     * gtk_widget_destroy(window) when "clicked".  Again, the destroy
     * signal could come from here, or the window manager. */
    g_signal_connect_swapped (button, "clicked",
			      G_CALLBACK (gtk_widget_destroy),
                              window);

    /* This packs the button into the window (a gtk container). */
    gtk_container_add (GTK_CONTAINER (window), button);

    /* The final step is to display this newly created widget. */
    gtk_widget_show (button);

    /* and the window */
    gtk_widget_show (window);

    /* All GTK applications must have a gtk_main(). Control ends here
     * and waits for an event to occur (like a key press or
     * mouse event). */
    gtk_main ();

    return 0;
}
    </programlisting>
   </example>

   <para>
    Now, the Lisp implementation is presented in <xref linkend="example-hello-world"/>. One difference is,
    that the function <code>make-instance</code> is used to create the window and the button. Another point
    is, that the definition of separate callback functions is avoided. The callback functions are short,
    implemented through Lisp <code>lambda</code> functions and are passed as the third argument to the
    function &g-signal-connect;. More about signals and callback functions follows in
    <xref linkend="Introduction_to_Signals_and_Callbacks"/>.
   </para>

   <figure id="figure-hello-world">
    <title>Hello World</title>
    <mediaobject>
     <imageobject>
      <imagedata fileref="figures/hello-world.png" format="png"></imagedata>
     </imageobject>
    </mediaobject>
   </figure>

   <para>
    In <xref linkend="example-hello-world"/> a border with a width of 12 is added to the window setting the
    &gtk_container_border-width; property when creating the window with the function
    <code>make-instance</code>. The C implementation uses the function
    <code>gtk_container_set_border_width()</code> which is available in Lisp as the slot access function
    &gtk-container-border-width;. The &gtk_container_border-width; property is inherited from the C class
    <code>GtkContainer</code>, which in the Lisp library is represented through the Lisp class
    &gtk-container;. Therefore, the slot access function has the prefix <code>gtk_container</code> in C and
    <code>gtk-container</code> in Lisp. A full list of properties of <code>GtkContainer</code> is available
    in the &gtk-container; documentation.
   </para>

   <example id="example-hello-world">
    <title>Hello World in Lisp</title>
    <programlisting xmlns:xi="http://www.w3.org/2001/XInclude">
<xi:include href="../demo/gtk-example/hello-world.lisp" parse="text"/>
    </programlisting>
   </example>

   <para>
    An attentive reader notes that in distinction to the C implementation the function &gtk-widget-show; is
    not called for every single widget, which are in <xref linkend="example-hello-world"/> the window and the
    button. Instead the function &gtk-widget-show-all; is used to display the window with all including
    widgets.
   </para>
   <para>
    The function &gtk-widget-destroy; takes as an argument any widget and destroys it. In the above example
    this function is called by the signal handler for the button. When the button is clicked by the user, the
    "clicked" signal is catched by the signal handler, which causes a call of the function
    &gtk-widget-destroy; for the toplevel window. Now the toplevel window receives the "destroy" signal,
    which is handled by a signal handler of the toplevel window. This signal handler calls the function
    &leave-gtk-main;, which stops the event loop and finishes the application.
   </para>
   <para>
    A second signal handler is connected to the toplevel window to catch the "delete-event" signal. The
    "delete-event" signal occurs, when the user or the window manager tries to close the window. In this
    case, the signal handler prints a message on the console. Because the value of the constant
    &gdk-event-stop; is <emphasis>true</emphasis> the signal handler stops the handling of the signal and the
    window is not closed, but the execution of the application is continued. To close the window, the user
    has to press the button in this example. There is a second constant &gdk-event-propagate; which is used
    to make sure that the propagation of the event is continued. At last, the function &gtk-container-add; is
    used to put the button into the toplevel window. <xref linkend="Packing_Widgets"/> shows how it is
    possible to put more than one widget into a window.
   </para>
  </section>

  <section id="Introduction_to_Signals_and_Callbacks" revision="2021-5-13"> 
   <title>Introduction to Signals and Callbacks</title>
   <para>
    GTK is an event driven toolkit, which means GTK will sleep until an event occurs and control is passed to
    the appropriate function. This passing of control is done using the idea of "signals". Note that these
    signals are not the same as the Unix system signals, and are not implemented using them, although the
    terminology is almost identical. When an event occurs, such as the press of a mouse button, the
    appropriate signal will be "emitted" by the widget that was pressed. This is how GTK does most of its
    useful work. There are signals that all widgets inherit, such as the "destroy" signal, and there are
    signals that are widget specific, such as the "toggled" signal on a toggle button.
   </para>
   <para>
    To make a button perform an action, a signal handler is set up to catch these signals and to call the
    appropriate function. This is done in the C GTK library by using a function such as
   </para>
   <programlisting>
gulong g_signal_connect( gpointer      *object,
                         const gchar   *name,
                         GCallback     func,
                         gpointer      func_data );
   </programlisting>
   <para>
    where the first argument is the widget which will be emitting the signal, and the second the name of the
    signal to catch. The third is the function to be called when the signal is caught, and the fourth, the
    data to have passed to this function.
   </para>
   <para>
    The function specified in the third argument is called a "callback function", and is for a C program of
    the form
   </para>
   <programlisting>
void callback_func( GtkWidget *widget,
                    ... /* other signal arguments */
                    gpointer   callback_data );
   </programlisting>
   <para>
    where the first argument will be a pointer to the widget that emitted the signal, and the last a pointer
    to the data given as the last argument to the C function <code>g_signal_connect()</code> as shown above.
    Note that the above form for a signal callback function declaration is only a general guide, as some
    widget specific signals generate different calling parameters.
   </para>
   <para>
    This mechanism is realized in Lisp with a similar function &g-signal-connect; which has the arguments
    <code>widget</code>, <code>name</code>, and <code>func</code>. In distinction from C the Lisp function
    &g-signal-connect; has not the argument <code>func_data</code>. The functionality of passing data to a
    callback function can be realized with the help of a <code>lambda</code> function in Lisp.
   </para>
   <para>
    As an example the following code shows a typical C implementation which is used in the Hello World
    program.
   </para>
   <programlisting>
g_signal_connect (window, "destroy", G_CALLBACK (destroy), NULL);
   </programlisting>
   <para>
    This is the corresponding callback function which is called when the "destroy" event occurs.
   </para>
   <programlisting>
static void destroy (GtkWidget *widget, gpointer data)
{
    gtk_main_quit ();
}
   </programlisting>
   <para>
    In the corresponding Lisp implementation we simply declare a <code>lambda</code> function as a callback
    function which is passed as the third argument.
   </para>
   <programlisting>
(g-signal-connect window "destroy"
                  (lambda (widget)
                    (declare (ignore widget))
                    (leave-gtk-main)))
   </programlisting>
   <para>
    If it is necessary to have a separate function which needs user data, the following implementation is
    possible
   </para>
   <programlisting>
(defun separate-event-handler (widget arg1 arg2 arg3)
  [ here is the code of the event handler ] )

(g-signal-connect window "destroy"
                  (lambda (widget)
                    (separate-event-handler widget arg1 arg2 arg3)))
   </programlisting>
   <para>
    If no extra data is needed, but the callback function should be separated out than it is also possible
    to implement something like
   </para>
   <programlisting>
(g-signal-connect window "destroy" #'separate-event-handler)
   </programlisting>
  </section>

  <section id="Upgraded_Hello_World" revision="2021-5-13">
   <title>Upgraded Hello World</title>
   <para>
    <xref linkend="figure-upgraded-hello-world"/> and <xref linkend="example-upgraded-hello-world"/> show a
    slightly improved Hello World with better examples of callbacks. This will also introduce the next topic,
    packing widgets. First, the C program is shown in <xref linkend="example-upgraded-hello-world-c"/>.
   </para>

   <figure id="figure-upgraded-hello-world">
    <title>Upgraded Hello World</title>
    <mediaobject>
     <imageobject>
      <imagedata fileref="figures/hello-world-upgraded.png" format="png"></imagedata>
     </imageobject>
    </mediaobject>
   </figure>

   <example id="example-upgraded-hello-world-c">
    <title>An upgraded Hello World in C</title>
    <programlisting>
#include &#x3c;gtk/gtk.h>

/* Our new improved callback.  The data passed to this function
 * is printed to stdout. */
static void callback( GtkWidget *widget, gpointer data )
{
    g_print ("Hello again - %s was pressed\n", (gchar *) data);
}

/* another callback */
static gboolean delete_event( GtkWidget *widget,
                              GdkEvent  *event,
                              gpointer   data )
{
    gtk_main_quit ();
    return FALSE;
}

int main( int argc, char *argv[] )
{
    /* GtkWidget is the storage type for widgets */
    GtkWidget *window;
    GtkWidget *button;
    GtkWidget *box1;

    /* This is called in all GTK applications. Arguments are parsed
     * from the command line and are returned to the application. */
    gtk_init (&#x26;argc, &#x26;argv);

    /* Create a new window */
    window = gtk_window_new (GTK_WINDOW_TOPLEVEL);

    /* This is a new call, which just sets the title of our
     * new window to "Hello Buttons!" */
    gtk_window_set_title (GTK_WINDOW (window), "Hello Buttons!");

    /* Here we just set a handler for delete_event that immediately
     * exits GTK. */
    g_signal_connect (window, "delete-event",
		      G_CALLBACK (delete_event), NULL);

    /* Sets the border width of the window. */
    gtk_container_set_border_width (GTK_CONTAINER (window), 10);

    /* We create a box to pack widgets into.  This is described in detail
     * in the "packing" section. The box is not really visible, it
     * is just used as a tool to arrange widgets. */
    box1 = gtk_hbox_new (FALSE, 0);

    /* Put the box into the main window. */
    gtk_container_add (GTK_CONTAINER (window), box1);

    /* Creates a new button with the label "Button 1". */
    button = gtk_button_new_with_label ("Button 1");

    /* Now when the button is clicked, we call the "callback" function
     * with a pointer to "button 1" as its argument */
    g_signal_connect (button, "clicked",
		      G_CALLBACK (callback), (gpointer) "button 1");

    /* Instead of gtk_container_add, we pack this button into the invisible
     * box, which has been packed into the window. */
    gtk_box_pack_start (GTK_BOX(box1), button, TRUE, TRUE, 0);

    /* Always remember this step, this tells GTK that our preparation for
     * this button is complete, and it can now be displayed. */
    gtk_widget_show (button);

    /* Do these same steps again to create a second button */
    button = gtk_button_new_with_label ("Button 2");

    /* Call the same callback function with a different argument,
     * passing a pointer to "button 2" instead. */
    g_signal_connect (button, "clicked",
		      G_CALLBACK (callback), (gpointer) "button 2");

    gtk_box_pack_start(GTK_BOX (box1), button, TRUE, TRUE, 0);

    /* The order in which we show the buttons is not really important, but I
     * recommend showing the window last, so it all pops up at once. */
    gtk_widget_show (button);

    gtk_widget_show (box1);

    gtk_widget_show (window);

    /* Rest in gtk_main and wait for the fun to begin! */
    gtk_main ();

    return 0;
}
    </programlisting>
   </example>

   <para>
    The Lisp implementation in <xref linkend="example-upgraded-hello-world"/> tries to be close to the C
    program. Therefore, the window and the box are created with the functions &gtk-window-new; and
    &gtk-box-new;. Various properties like the title of the window, the default size or the border width are
    set with the functions &gtk-window-title;, &gtk-window-default-size; and &gtk-container-border-width;. As
    described for <xref linkend="example-hello-world"/> the function &gtk-widget-show-all; is used to display
    the window including all child widgets.
   </para>
   <para>
    One main difference of the Lisp implementation is the use of the function &gtk-box-new; with an argument
    <code>:horizontal</code> to create a horizontal box. The <code>GtkHBox</code> widget which is used in the
    C implementation is deprecated and is replaced by the <code>GtkBox</code> widget with the
    &gtk_orientable_orientation; property. The argument <code>:horizontal</code> is one of the values of
    the &gtk-orientation; enumeration. More about boxes and their usages follows in
    <xref linkend="Packing_Widgets"/>.
   </para>

   <example id="example-upgraded-hello-world">
    <title>Upgraded Hello World in Lisp</title>
    <programlisting xmlns:xi="http://www.w3.org/2001/XInclude">
<xi:include href="../demo/gtk-example/hello-world-upgraded.lisp" parse="text"/>
    </programlisting>
   </example>

   <para>
    The second implementation in <xref linkend="example-upgraded-hello-world-2"/> makes more use of a Lisp
    style. The window is created with the Lisp function <code>make-instance</code>. All desired properties of
    the window are initialized by assigning values to the slots of the &gtk-window; and &gtk-box; classes.
    The Lisp implementation uses a lot keywords arguments with default values for long lists of arguments. In
    this example the keyword arguments <code>expand</code>, <code>fill</code>, and <code>padding</code> of
    the function "&gtk-box-pack-start; take default values. In future examples of this tutorial the style
    shown in this example is preferred. Furthermore, the C code is no longer presented for comparison.
   </para>

   <example id="example-upgraded-hello-world-2">
    <title>Second Upgraded Hello World</title>
    <programlisting xmlns:xi="http://www.w3.org/2001/XInclude">
<xi:include href="../demo/gtk-example/hello-world-upgraded-2.lisp" parse="text"/>
    </programlisting>
   </example>
  </section>

  <section id="Drawing_in_response_to_input" revision="2021-5-13">
   <title>Drawing in response to input</title>
   <para>
    Many widgets, like buttons, do all their drawing themselves. You just tell them the label you want to
    see, and they figure out what font to use, draw the button outline and focus rectangle, etc. Sometimes,
    it is necessary to do some custom drawing. In that case, a &gtk-drawing-area; widget might be the right
    widget to use. It offers a canvas on which you can draw by connecting to the "draw" signal.
   </para>

   <figure id="figure-drawing">
    <title>Drawing in response to input</title>
    <mediaobject>
     <imageobject>
      <imagedata fileref="figures/drawing-area-input.png" format="png"></imagedata>
     </imageobject>
    </mediaobject>
   </figure>

   <para>
    The contents of a widget often need to be partially or fully redrawn, e.g. when another window is moved
    and uncovers part of the widget, or when the window containing it is resized. It is also possible to
    explicitly cause part or all of the widget to be redrawn, by calling the function &gtk-widget-queue-draw;
    or its variants. GTK takes care of most of the details by providing a ready-to-use Cairo context to the
    "draw" signal handler.
   </para>
   <para>
    The following example shows a "draw" signal handler. It is a more complicated than the previous examples,
    since it also demonstrates input event handling by means of "button-press" and "motion-notify" handlers.
   </para>

   <example id="example-drawing">
    <title>Drawing in response to input</title>
    <programlisting xmlns:xi="http://www.w3.org/2001/XInclude">
<xi:include href="../demo/gtk-example/drawing-area-input.lisp" parse="text"/>
    </programlisting>
   </example>
  </section>
 </chapter>

 <chapter id="Packing_Widgets" revision="2021-5-14">
  <title>Packing Widgets</title>
  <section id="Packing_Boxes" revision="2021-5-15">
   <title>Packing Boxes</title>
   <para>
    When creating an application, it is necessary to put more than one widget inside a window. The first
    example in <xref linkend="figure-hello-world"/> only used one button so it could simply use the function
    &gtk-container-add; to "pack" the button into the window. But when more than one widget must be put into
    a window packing comes in.
   </para>
   <para>
    Packing is done by creating boxes or grids. Grids are more general and powerful than boxes. Grids are
    explained later in this tutorial. Boxes are invisible widget containers that can pack widgets into,
    which come in two forms, a horizontal box, and a vertical box. When packing widgets into a horizontal
    box, the objects are inserted horizontally from left to right or right to left depending on the call
    used. In a vertical box, widgets are packed from top to bottom or vice versa. You may use any
    combination of boxes inside or beside other boxes to create the desired effect.
   </para>
   <para>
    To create a new &gtk-box; widget, the function &gtk-box-new; or the call
    <code>(make-instance 'gtk-box)</code> is used. The first argument of the function &gtk-box-new; takes a
    keyword with a value of the <code>GtkOrientation</code> enumeration, which, in the Lisp binding, is
    implemented as the &gtk-orientation; enumeration with the values <code>:horizontal</code> or
    <code>:vertical</code> to determine a horizontal or a vertical box. Because the &gtk-box; widget
    implements the &gtk-orientable; interface an instance of the &gtk-box; widget has the
    &gtk_orientable_orientation; property.
   </para>

   <table id="table-gtk-box">
    <caption>Functions for GtkBox</caption>
    <colgroup>
     <col style="width:30%"/>
     <col style="width:70%"/>
    </colgroup>
    <tr>
     <th align="left">Function</th>
     <th align="left">Description</th>
    </tr>
    <tr>
     <td colspan="2" style="border-top:2px solid #ff9900;"></td>
    </tr>
    <tr>
     <td colspan="2">Slot access functions</td>
    </tr>
    <tr valign="top">
     <td>&gtk-box-baseline-position;</td>
     <td>Accessor of the <code>baseline-position</code> property.</td>
    </tr>
    <tr valign="top">
     <td>&gtk-box-homogeneous;</td>
     <td>Accessor of the <code>homogeneous</code> property.</td>
    </tr>
    <tr valign="top">
     <td>&gtk-box-spacing;</td>
     <td>Accessor of the <code>spacing</code> property.</td>
    </tr>
    <tr>
     <td colspan="2">Child access functions</td>
    </tr>
    <tr valign="top">
     <td>&gtk-box-child-expand;</td>
     <td>Accessor of the <code>expand</code> child property.</td>
    </tr>
    <tr valign="top">
     <td>&gtk-box-child-fill;</td>
     <td>Accessor of the <code>fill</code> child property.</td>
    </tr>
    <tr valign="top">
     <td>&gtk-box-child-pack-type;</td>
     <td>Accessor of the <code>pack-type</code> child property.</td>
    </tr>
    <tr valign="top">
     <td>&gtk-box-child-padding;</td>
     <td>Accessor of the <code>padding</code> child property.</td>
    </tr>
    <tr valign="top">
     <td>&gtk-box-child-position;</td>
     <td>Accessor of the <code>position</code> child property.</td>
    </tr>
    <tr>
     <td colspan="2">More functions</td>
    </tr>
    <tr valign="top">
     <td>&gtk-box-new;</td>
     <td>Creates a new <code>gtk-box</code> widget.</td>
    </tr>
    <tr valign="top">
     <td>&gtk-box-pack-start;</td>
     <td>Adds a child to the box, packed with reference to the start of the box.</td>
    </tr>
    <tr valign="top">
     <td>&gtk-box-pack-end;</td>
     <td>Adds a child to the box, packed with reference to the end of the box.</td>
    </tr>
    <tr valign="top">
     <td>&gtk-box-reorder-child;</td>
     <td>Move the child widget to a new position in the list of the box children.</td>
    </tr>
    <tr valign="top">
     <td>&gtk-box-query-child-packing;</td>
     <td>Obtains information about how the child widget is packed into the box.</td>
    </tr>
    <tr valign="top">
     <td>&gtk-box-child-packing;</td>
     <td>Sets the way the child widget is packed into the box.</td>
    </tr>
    <tr valign="top">
     <td>&gtk-box-center-widget;</td>
     <td>Sets a child widget that will be centered with respect to the full width of the box.</td>
    </tr>
    <tr>
     <td colspan="2" style="border-top:1px solid #ff9900;"></td>
    </tr>
   </table>

   <para>
    The following code fragments show two equivalent ways to create an instance of a horizontal box. The first
    argument of the function &gtk-box-new; takes the value of the &gtk_orientable_orientation; property. The
    second argument is the value of the &gtk_box_spacing; property, which is described in
    <xref linkend="Details_of_Boxes"/>:
   </para>
   <programlisting>
(let ((box (gtk-box-new :horizontal 3)))
  ... )
   </programlisting>
   <para>or</para>
   <programlisting>
(let ((box (make-instance 'gtk-box
                          :orientation :horizontal
                          :spacing 3)))
  ... )
   </programlisting>
   <para>
    The functions &gtk-box-pack-start; and &gtk-box-pack-end; are used to place widgets inside of boxes. The
    function &gtk-box-pack-start; starts at the top and works its way down in a vertical box, and packs left
    to right in a horizontal box. The function &gtk-box-pack-end; does the opposite, packing from bottom to
    top in a vertical box, and right to left in a horizontal box. The widgets, which are packed into a box,
    can be containers, which are composed of other widgets. Using the functions for packing widgets in boxes
    allows to right justify or left justify the widgets. The functions can be mixed in any way to achieve the
    desired effect. Most of the examples in this tutorial use the function &gtk-box-pack-start;. In the
    following example a vertical box is created. Then two label widgets are packed into the box with the
    function &gtk-box-pack-start;:
   </para>
   <programlisting>
(let ((box (gtk-box-new :vertical 3)))
  (gtk-box-pack-start box (gtk-label-new "LABEL 1"))
  (gtk-box-pack-start box (gtk-label-new "LABEL 2"))
  ... )
   </programlisting>
   <para>
    By using boxes, GTK knows where to place the widgets so GTK can do automatic resizing and other nifty
    things. A number of options control as to how the widgets should be packed into boxes. This method of
    packing boxes gives the user quite a bit of flexibility when placing widgets.
   </para>

   <figure id="figure-box-simple">
    <title>Simple Box</title>
    <mediaobject>
     <imageobject>
      <imagedata fileref="figures/box-simple.png" format="png"></imagedata>
     </imageobject>
    </mediaobject>
   </figure>

   <para>
    <xref linkend="figure-box-simple"/> shows a horizontal box with three colored buttons. The red button is
    put at the start position into the box and the green button and the end position. The yellow button is
    centered within the box. The size of the labels within the buttons is enlarged with the slot access
    functions &gtk-widget-width-request; and &gtk-widget-height-request;. The label widget is extracted with
    the function &gtk-bin-child; from the button widget. In this example CSS data is applied to the buttons
    to color the buttons.
   </para>

   <example id="example-box-simple">
    <title>Simple Box</title>
    <programlisting xmlns:xi="http://www.w3.org/2001/XInclude">
<xi:include href="../demo/gtk-example/box-simple.lisp" parse="text"/>
    </programlisting>
   </example>

   <note>
    <para>
     The <code>GtkHBox</code> for horizontal and <code>GtkVBox</code> widgets for vertical boxes are
     deprecated, but still present in GTK 3. In this tutorial these classes are not used. In addition a
     single-row or single-column &gtk-grid; widget provides exactly the same functionality as the &gtk-box;
     widget. See <xref linkend="Packing_Using_Grids"/> for examples to replace the &gtk-box; widget with the
     &gtk-grid; widget.
    </para>
   </note>
  </section>

  <section id="Details_of_Boxes" revision="2021-5-14">
   <title>Details of Boxes</title>
   <para>
    Because of the flexibility, packing boxes in GTK can be confusing at first. A lot of options control the
    packing of boxes, and it is not immediately obvious how the options all fit together. In the end, however,
    basically five different styles are available.
   </para>
   <para>
    Boxes have the &gtk_box_homogeneous; and &gtk_box_spacing; properties. The functions &gtk-box-homogeneous;
    and &gtk-box-spacing; are used to write and read the properties. The &gtk_box_homogeneous; property
    controls whether each widget in the box has the same width in a horizontal box or the same height in a
    vertical box. The &gtk_box_spacing; property controls the amount of space between children in the box. A
    complete example for creating a box is therefore:
   </para>
   <programlisting>
(let ((box (make-instance 'gtk-box
                          :orientation :vertical
                          :spacing 3
                          :homogeneous t)))
  ... )
   </programlisting>
   <para>
    <xref linkend="figure-box-packing"/> shows an example of packing buttons into horizontal boxes. Each line
    of the example contains one horizontal box with several buttons. The first button represents the call of
    the function &gtk-box-pack-start; and the following buttons represent the arguments of the function. The
    first two arguments are <code>box</code> for the box and <code>child</code> for the child widgets to put
    into the box, which are in our example buttons. The further arguments of the function &gtk-box-pack-start;
    are in the C implementation <code>expand</code>, <code>fill</code> and <code>padding</code>. In the Lisp
    binding to GTK these arguments are defined as the keyword arguments <code>:expand</code> and
    <code>:fill</code>, which both have a default value of <emphasis>true</emphasis>, and
    <code>:padding</code> with a default value of <code>0</code>. The keyword arguments can be omitted, in
    which case the default values will be used.
   </para>

   <figure id="figure-box-packing">
    <title>Box Packing</title>
    <mediaobject>
     <imageobject>
      <imagedata fileref="figures/box-packing.png" format="png"></imagedata>
     </imageobject>
    </mediaobject>
   </figure>

   <para>
    The keyword argument <code>:expand</code> with a value <emphasis>true</emphasis> to the functions
    &gtk-box-pack-start; and &gtk-box-pack-end; controls whether the widgets are laid out in the box to fill
    in all the extra space in the box so the box is expanded to fill the area allotted to it, or with a value
    <code>nil</code> the box is shrunk to just fit the widgets. Setting expand to <code>nil</code> allows to
    do right and left justification of the widgets. Otherwise, the widgets expand to fit into the box. The
    same effect can be achieved by using only one of the functions &gtk-box-pack-start; or &gtk-box-pack-end;.
   </para>
   <para>
    The keyword argument <code>:fill</code> with a value <emphasis>true</emphasis> to the
    <code>gtk-box-pack</code> functions control whether the extra space is allocated to the objects
    themselves, or with a value <code>nil</code> as extra padding in the box around these objects. It only
    has an effect if the keyword argument <code>expand</code> is also <emphasis>true</emphasis>.
   </para>
   <para>
    The difference between spacing, set when the box is created, and padding, set when elements are packed,
    is, that spacing is added between objects, and padding is added on either side of a child widget. In
    <xref linkend="figure-box-packing"/> the spacing is set to 6 and padding is 0 for all buttons.
   </para>
   <para>
    The code for <xref linkend="figure-box-packing"/> is shown in <xref linkend="example-box-packing"/>. The
    function <code>example-box-packing</code> takes the optional arguments <code>spacing</code> and
    <code>padding</code>, which have default values 6 and 0, respectively.
   </para>

   <example id="example-box-packing">
    <title>Box Packing</title>
    <programlisting xmlns:xi="http://www.w3.org/2001/XInclude">
<xi:include href="../demo/gtk-example/box-packing.lisp" parse="text"/>
    </programlisting>
   </example>
  </section>

  <section id="Packing_Using_Grids" revision="2021-5-18">
   <title>Packing Using Grids</title>
   <para>
    The &gtk-grid; widget is an attempt to write a comprehensive box-layout container that is flexible enough
    to replace &gtk-box;, &gtk-table; widgets and the like. The layout model of the &gtk-grid; widget is to
    arrange its children in rows and columns. This is done by assigning positions on a two-dimensions grid
    that stretches arbitrarily far in all directions. Children can span multiple rows or columns.
   </para>
   <para>
    Grids can be created with the function &gtk-grid-new;. The function has no arguments. Alternatively, the
    grid is created with the function <code>make-instance</code>.
   </para>
   <para>
    The &gtk-grid; class has the &gtk_grid_column-homogeneous; and &gtk_grid_row-homogeneous; properties. If
    <emphasis>true</emphasis> the columns or the rows have all the same size, respectively. The
    &gtk_grid_column-spacing; and &gtk_grid_row-spacing; properties add space in pixels between two
    consecutive columns or rows.
   </para>
   <para>
    To place a widget into a grid, the function &gtk-grid-attach; can be used. The function takes six
    parameters:
   </para>

   <variablelist>
    <varlistentry>
     <term><code>grid</code></term>
     <listitem>the &gtk-grid; widget</listitem>
    </varlistentry>
    <varlistentry>
     <term><code>child</code></term>
     <listitem>the child widget to add to the grid</listitem>
    </varlistentry>
    <varlistentry>
     <term><code>left</code></term>
     <listitem>the column number to attach the left side of the child widget to</listitem>
    </varlistentry>
    <varlistentry>
     <term><code>top</code></term>
     <listitem>the row number to attach the top side of the child widget to</listitem>
    </varlistentry>
    <varlistentry>
     <term><code>width, height</code></term>
     <listitem>the number of columns and the number of the rows that the child widget will span</listitem>
    </varlistentry>
   </variablelist>

   <para>
    It is also possible to add a child widget next to an existing child widget, using the function
    &gtk-grid-attach-next-to;. Finally, the &gtk-grid; widget can be used like the &gtk-box; widget by just
    using the function &gtk-container-add;, which will place children next to each other in the direction
    determined by the &gtk_orientable_orientation; property of the &gtk-grid; widget. The property is
    inherited from the implemented &gtk-orientable; interface. The default value is <code>:horizontal</code>.
   </para>
  </section>

  <section id="Grid_Packing_Example" revision="2021-5-18">
   <title>Grid Packing Example</title>
   <para>
    <xref linkend="figure-grid-simple"/> shows a window with three buttons in a grid. The first two buttons
    are placed in the upper row. A third button is placed in the lower row, spanning both columns. The code
    of this example is shown in <xref linkend="example-grid-simple"/>.
   </para>

  <figure id="figure-grid-simple">
    <title>Simple Grid</title>
    <mediaobject>
     <imageobject>
      <imagedata fileref="figures/grid-simple.png" format="png"></imagedata>
     </imageobject>
    </mediaobject>
   </figure>

   <example id="example-grid-simple">
    <title>Simple Grid</title>
    <programlisting xmlns:xi="http://www.w3.org/2001/XInclude">
<xi:include href="../demo/gtk-example/grid-simple.lisp" parse="text"/>
    </programlisting>
   </example>

   <para>
    <xref linkend="figure-grid-spacing"/> is an extended example to show the possibility to increase the
    spacing of the rows and columns. This is implemented through two toggle buttons which increase and
    decrease the spacings. Toggle buttons are described in <xref linkend="Toggle_Button"/> later in this
    tutorial. The code of this example is shown in <xref linkend="example-grid-spacing"/>.
   </para>

   <figure id="figure-grid-spacing">
    <title>Grid Packing with more spacing</title>
    <mediaobject>
     <imageobject>
      <imagedata fileref="figures/grid-spacing.png" format="png"></imagedata>
     </imageobject>
    </mediaobject>
   </figure>

   <example id="example-grid-spacing">
    <title>Grid Packing with more spacing</title>
    <programlisting xmlns:xi="http://www.w3.org/2001/XInclude">
<xi:include href="../demo/gtk-example/grid-spacing.lisp" parse="text"/>
    </programlisting>
   </example>
  </section>

  <section id="GtkBox_versus_GtkGrid" revision="2021-5-18">
   <title>GtkBox versus GtkGrid</title>

   <section id="GtkBox_versus_GtkGrid_packing" revision="2021-5-18">
    <title>GtkBox versus GtkGrid - packing</title>
    <para>
     The &gtk-box; widget works by arranging child widgets in a single line, either horizontally or
     vertically. It allows packing children from the beginning or end, using the functions
     &gtk-box-pack-start; and &gtk-box-pack-end;.
    </para>
    <para>
     The following code creates a simple box with two labels:
    </para>
    <programlisting>
(let ((box (gtk-box-new :horizontal 0)))
  (gtk-box-pack-start box (gtk-label-new "ONE") nil nil 0)
  (gtk-box-pack-start box (gtk-label-new "TWO") nil nil 0)
  ... )
    </programlisting>
    <para>
     This can be done with the &gtk-grid; widget as follows:
    </para>
    <programlisting>
(let ((grid (gtk-grid-new))
      (child1 (gtk-label-new "ONE"))
      (child2 (gtk-label-new "TWO")))
  (gtk-grid-attach grid child1 0 0 1 1)
  (gtk-grid-attach-next-to grid child2 child1 :right 1 1)
  ... )
    </programlisting>
    <para>
     And similarly for the function &gtk-box-pack-end;. In that case, you would use <code>:left</code> to
     place the grid children from left to right.
    </para>
    <para>
     If you only need to pack children from the start, using the function &gtk-container-add; is an even
     simpler alternative. The &gtk-grid; widget places children added with the function &gtk-container-add;
     in a single row or column according to its orientation.
    </para>
    <para>
     One difference to keep in mind is that the functions &gtk-box-pack-start; and &gtk-box-pack-end; allow
     you to place an arbitrary number of children from either end without ever 'colliding in the middle'.
     With the &gtk-grid; widget, you have to leave enough space between the two ends, if you want to combine
     packing from both ends towards the middle. In practice, this should be easy to avoid; and the &gtk-grid;
     widget simply ignores entirely empty rows or columns for layout and spacing.
    </para>
    <para>
     On the other hand, the &gtk-grid; widget is more flexible in that its grid extends indefinitively in both
     directions - there is no problem with using negative numbers for the grid positions. So, if you discover
     that you need to place a widget before your existing arrangement, you always can.
    </para>
   </section>

   <section id="GtkBox_versus_GtkGrid_sizing" revision="2021-5-18">
    <title>GtkBox versus GtkGrid - sizing</title>
    <para>
     When adding a child to a &gtk-box; widget, there are two hard-to-remember parameters (child properties,
     more exactly) named <code>expand</code> and <code>fill</code> that determine how the child size behaves
     in the main direction of the box. If <code>expand</code> is set, the box allows the position occupied by
     the child to grow when extra space is available. If <code>fill</code> is also set, the extra space is
     allocated to the child widget itself. Otherwise it is left 'free'. There is no control about the 'minor'
     direction. Children are always given the full size in the minor direction.
    </para>
    <para>
     The &gtk-grid; widget does not have any custom child properties for controlling size allocation to
     children. Instead, it fully supports the newly introduced &gtk_widget_hexpand;, &gtk_widget_vexpand;,
     &gtk_widget_halign;, and &gtk_widget_valign; properties for widgets.
    </para>
    <para>
     The &gtk_widget_hexpand; and &gtk_widget_vexpand; properties operate in a similar way to the expand child
     properties of the &gtk-box; widget. As soon as a column contains a horizontally expanding child,
     the &gtk-grid; widget allows the column to grow when extra space is available (similar for rows and the
     &gtk_widget_vexpand; property). In contrast to the &gtk-box; widget, all the extra space is always
     allocated to the child widget, there are no 'free' areas.
    </para>
    <para>
     To replace the functionality of the <code>fill</code> child property, you can set the &gtk_widget_halign;
     and &gtk_widget_valign; properties. An align value of <code>:fill</code> has the same effect as setting
     <code>fill</code> to <emphasis>true</emphasis>, a value of <code>:center</code> has the same effect as
     setting <code>fill</code> to <code>nil</code>.
    </para>
    <para>
     Expansion and alignment with the &gtk-box; widget:
    </para>
    <programlisting>
(let ((box (gtk-box-new :horizontal 0)))
  (gtk-box-pack-start box (gtk-label-new "ONE") t nil 0)
  (gtk-box-pack-start box (gtk-label-new "TWO") t t 0)
  ... )
    </programlisting>
    <para>
     This can be done with the &gtk-grid; widget as follows:
    </para>
    <programlisting>
(let ((grid (gtk-grid-new))
      (child1 (make-instance 'gtk-label
                             :label "ONE"
                             :hexpand t
                             :halign :center))
      (child2 (make-instance 'gtk-label
                             :label "TWO"
                             :hexpand t
                             :halign :fill))
  (gtk-grid-attach grid child1 0 0 1 1)
  (gtk-grid-attach-next-to grid child2 child1 :right 1 1)
  ... )
    </programlisting>
    <para>
     One difference between the new &gtk-widget; expand properties and the &gtk-box; child property of the
     same name is that widget expandability is 'inherited' from children. What this means is that a container
     will become itself expanding as soon as it has an expanding child. This is typically what you want, it
     lets you e.g. mark the content pane of your application window as expanding, and all the intermediate
     containers between the content pane and the toplevel window will automatically do the right thing. This
     automatism can be overridden at any point by setting the expand flags on a container explicitly.
    </para>
    <para>
     Another difference between the &gtk-box; and &gtk-grid; widget with respect to expandability is when
     there are no expanding children at all. In this case, the &gtk-box; widget will forcibly expand all
     children whereas the &gtk-grid; widget will not. In practice, the effect of this is typically that a
     grid will 'stick to the corner' when the toplevel containing it is grown, instead of spreading out its
     children over the entire area. The problem can be fixed by setting some or all of the children to expand.
    </para>
    <para>
     When you set the &gtk_box_homogeneous; property on a &gtk-box; widget, it reserves the same space for all
     its children. The &gtk-grid; widget does this in a very similar way, with &gtk_grid_row-homogeneous; and
     &gtk_grid_column-homogeneous; properties which control whether all rows have the same height and whether
     all columns have the same width.
    </para>
   </section>

   <section id="GtkBox_versus_GtkGrid_spacing" revision="2021-5-18">
    <title>GtkBox versus GtkGrid - spacing</title>
    <para>
     With the &gtk-box; widget, you have to specify the "spacing" when you construct it. This property
     specifies the space that separates the children from each other. Additionally, you can specify extra
     space to put around each child individually, using the <code>padding</code> child property.
    </para>
    <para>
     The &gtk-grid; widget is very similar when it comes to spacing between the children, except that it has
     two separate properties, &gtk_grid_row-spacing; and &gtk_grid_column-spacing;, for the space to leave
     between rows and columns. Note that the &gtk_grid_row-spacing; property is the space between rows, not
     inside a row. So, if you doing a horizontal layout, you need to set the &gtk_grid_column-spacing;
     property.
    </para>
    <para>
     The &gtk-grid; widget does not have any custom child properties to specify per-child padding; instead you
     can use the &gtk_widget_margin; property. You can also set different padding on each side with the
     &gtk_widget_margin-start;, &gtk_widget_margin-end;, &gtk_widget_margin-top; and
     &gtk_widget_margin-bottom; properties.
    </para>
    <para>
     Example with spacing in boxes:
    </para>
    <programlisting>
(let ((box (gtk-box-new :vertical 6))
      (child (gtk-label-new "Child")))
  (gtk-box-pack-start box child nil nil 12)
  ... )
    </programlisting>
    <para>
     This can be done with the &gtk-grid; widget as follows:
    </para>
    <programlisting>
(let ((grid (gtk-grid-new))
      (child (make-instance 'gtk-label
                            :label "Child"
                            :margin 12)))
  (gtk-grid-attach box child 0 0 1 1)
  ... )
    </programlisting>
   </section>

   <section id="GtkBox_versus_GtkGrid_packing_example" revision="2021-5-18">
    <title>GtkBox versus GtkGrid - packing example</title>
    <para>
     <xref linkend="example-grid-packing"/> shows how to replace the &gtk-box; widget with the &gtk-grid;
     widget to create horizontal boxes. The layout corresponds to the layout of the previous example in
     <xref linkend="figure-box-packing"/>.
    </para>

   <figure id="figure-grid-packing">
    <title>Packing using GtkGrid</title>
    <mediaobject>
     <imageobject>
      <imagedata fileref="figures/grid-packing.png" format="png"></imagedata>
     </imageobject>
    </mediaobject>
   </figure>

   <example id="example-grid-packing">
    <title>Packing using GtkGrid</title>
    <programlisting xmlns:xi="http://www.w3.org/2001/XInclude">
<xi:include href="../demo/gtk-example/grid-packing.lisp" parse="text"/>
    </programlisting>
    </example>

   </section>
  </section>
 </chapter>

 <chapter id="Button_Widgets" revision="2021-5-19">
  <title>Button Widgets</title>

  <section id="Simple_Button" revision="2021-5-19">
   <title>Simple Button</title>
   <para>
    We have almost seen all there is to see of the button widget, which is represented by the &gtk-button;
    widget. The button widget is pretty simple. There is however more than one way to create a button. You can
    use the the function &gtk-button-new-with-label; or the function &gtk-button-new-with-mnemonic; to create
    a button with a label, use the function &gtk-button-new-from-icon-name; to create a button containing the
    image from the current icon theme or use the function &gtk-button-new; to create a blank button. It is
    then up to you to pack a label or pixmap into this new button. To do this, create a new box, and then
    pack your objects into this box using the function &gtk-box-pack-start;, and then use the function
    &gtk-container-add; to pack the box into the button.
   </para>

   <figure id="figure-button-image">
    <title>Button with an image</title>
    <mediaobject>
     <imageobject>
      <imagedata fileref="figures/button-image.png" format="png"></imagedata>
     </imageobject>
    </mediaobject>
   </figure>

   <para>
    <xref linkend="figure-button-image"/> shows an example of using the function <code>make-instance</code>
    to create a button with an image and a label in it. For this example the &gtk_widget_halign; and
    &gtk_widget_valign; properties inherited from the &gtk-widget; class are set to the value
    <code>:center</code>. Therefore, the button is centered in the window and does not fill the available
    space of the window. The image is loaded from a file with the function &gtk-image-new-from-file;. The code
    to create the box is separated in the function <code>image-label-box</code>.
    <xref linkend="example-button-image"/> shows the complete program to create
    <xref linkend="figure-button-image"/>. The function <code>image-label-box</code> can be used to pack
    images and labels into any widget that can be a container.
   </para>

   <example id="example-button-image">
    <title>Button with an image</title>
    <programlisting xmlns:xi="http://www.w3.org/2001/XInclude">
<xi:include href="../demo/gtk-example/button-image.lisp" parse="text"/>
    </programlisting>
   </example>

   <figure id="figure-more-buttons">
    <title>More Buttons</title>
    <mediaobject>
     <imageobject>
      <imagedata fileref="figures/button-more.png" format="png"></imagedata>
     </imageobject>
    </mediaobject>
   </figure>

   <para>
    <xref linkend="figure-more-buttons"/> shows more buttons, which are created with standard functions and
    with the function <code>make-instance</code>. The buttons created with the function
    <code>make-instance</code> show both a label and an image. The images are created with the function
    <code>make-instance</code> from the current icon theme by setting the &gtk_image_icon-name; property to
    the icon name of the image. More about the &gtk-image; widget follows in <xref linkend="Image_Widget"/>.
    To show the images, the &gtk_button_always-show-image; property must be set to the value
    <emphasis>true</emphasis>. This is done in the call to the function <code>make-instance</code>. The code
    is shown in <xref linkend="example-more-buttons"/>.
   </para>

   <example id="example-more-buttons">
    <title>More buttons</title>
    <programlisting xmlns:xi="http://www.w3.org/2001/XInclude">
<xi:include href="../demo/gtk-example/button-more.lisp" parse="text"/>
    </programlisting>
   </example>
  </section>

  <section id="Toggle_Button" revision="2021-5-20">
   <title>Toggle Button</title>
   <para>
    Toggle buttons are derived from the &gtk-button; class and are very similar, except toggle buttons always
    are in one of two states, alternated by a click. Toggle buttons can be depressed, and when clicked again,
    the toggle button will pop back up. Toggle buttons are the basis for check buttons and radio buttons, as
    such, many of the calls used for toggle buttons are inherited by radio and check buttons.
   </para>
   <para>
    Beside <code>make-instance</code>, toggle buttons can be created with the functions
    &gtk-toggle-button-new;, &gtk-toggle-button-new-with-label;, and &gtk-toggle-button-new-with-mnemonic;.
    The first function creates a blank toggle button, and the last two functions, a toggle button with a
    label widget already packed into it. The &gtk-toggle-button-new-with-mnemonic; variant additionally
    parses the label for '_'-prefixed mnemonic characters.
   </para>
   <para>
    To retrieve the state of the toggle button, including radio and check buttons, a construct as shown in
    the example below is used. This tests the state of the toggle button, by accessing the
    &gtk_toggle_button_active; property of the toggle button with the function &gtk-toggle-button-active;.
    The signal of interest to us emitted by toggle buttons (the toggle button, check button, and radio button
    widgets) is the "toggled" signal. To check the state of these buttons, set up a signal handler to catch
    the toggled signal, and access the &gtk_toggle_button_active; property to determine the state of the
    button. A signal handler will look something like:
   </para>
   <programlisting>
(g-signal-connect button "toggled"
   (lambda (widget)
     (if (gtk-toggle-button-active widget)
         (progn
           ;; If control reaches here, the toggle button is down
         )
        (progn
           ;; If control reaches here, the toggle button is up
         ))))
   </programlisting>
   <para>
    To force the state of a toggle button, and its children, the radio and check buttons, use this function
    &gtk-toggle-button-active;. This function can be used to set the state of the toggle button, and its
    children the radio and check buttons. Passing in your created button as the first argument, and a
    <emphasis>true</emphasis> or <emphasis>false</emphasis> value for the second state argument to specify
    whether it should be down (depressed) or up (released). Default is up, or the value
    <emphasis>false</emphasis>.
   </para>
   <para>
    Note that when you use the &gtk-toggle-button-active; function, and the state is actually changed, it
    causes the "clicked" and "toggled" signals to be emitted from the button. The current state of the toggle
    button as a boolean <emphasis>true</emphasis> or <emphasis>false</emphasis> value is returned from the
    function &gtk-toggle-button-active;.
   </para>
   <para>
    In <xref linkend="example-grid-spacing"/> and <xref linkend="figure-grid-spacing"/> the usage of toggle
    buttons is shown.
   </para>

   <section id="Check_Button" revision="2021-5-20">
    <title>Check Button</title>
    <para>
     Check buttons are implemented as the &gtk-check-button; class and inherit many properties and functions
     from the toggle buttons, but look a little different. Rather than being buttons with text inside them,
     they are small squares with the text to the right of them. These are often used for toggling options on
     and off in applications.
    </para>
    <para>
     The creation functions are similar to those of the normal button: &gtk-check-button-new;,
     &gtk-check-button-new-with-label;, &gtk-check-button-new-with-mnemonic;. The function
     &gtk-check-button-new-with-label; creates a check button with a label beside it.
    </para>
    <para>
     Checking the state of the check button is identical to that of the toggle button.
     <xref linkend="figure-toggle-buttons"/> shows check and radio buttons and
     <xref linkend="example-toggle-buttons"/> the code to create the buttons.
    </para>
   </section>

   <section id="Radio_Button" revision="2021-5-20">
    <title>Radio Button</title>
    <para>
     Radio buttons are similar to check buttons except they are grouped so that only one may be selected or
     depressed at a time. This is good for places in your application where you need to select from a short
     list of options.
    </para>
    <para>
     Creating a new radio button is done with one of these calls: &gtk-radio-button-new;,
     &gtk-radio-button-new-with-label;, and &gtk-radio-button-new-with-mnemonic;. These functions take a list
     of radio buttons as the first argument or <code>NIL</code>. When <code>NIL</code> a new list of radio
     buttons is created. The newly created list for the radio buttons can be get with the function
     &gtk-radio-button-get-group;. More radio buttons can then be added to this list. The important thing to
     remember is that the function &gtk-radio-button-get-group; must be called for each new button added to
     the group, with the previous button passed in as an argument. The result is then passed into the next
     call to the function &gtk-radio-button-new; or the other two functions for creating a radio button. This
     allows a chain of buttons to be established. <xref linkend="figure-radio-button"/> shows a radio
     button group with two buttons. The code is shown in <xref linkend="example-radio-button"/>.
    </para>

    <figure id="figure-radio-button">
     <title>Radio Button</title>
     <mediaobject>
      <imageobject>
       <imagedata fileref="figures/radio-button.png" format="png"></imagedata>
      </imageobject>
     </mediaobject>
    </figure>

    <example id="example-radio-button">
     <title>Radio Button</title>
     <programlisting xmlns:xi="http://www.w3.org/2001/XInclude">
<xi:include href="../demo/gtk-example/radio-button.lisp" parse="text"/>
     </programlisting>
    </example>

    <para>
     You can shorten this slightly by using the following syntax, which removes the need for a variable to
     hold the list of buttons:
    </para>
    <programlisting>
(setq button
      (gtk-radio-button-new-with-label (gtk-radio-button-get-group button)
                                       "Button"))
    </programlisting>
    <para>
     Each of these functions has a variant, which take a radio button as the first argument and allows to omit
     the &gtk-radio-button-get-group; call. In this case the new radio button is added to the list of radio
     buttons the argument is already a part of. These functions are: &gtk-radio-button-new-from-widget;,
     &gtk-radio-button-new-with-label-from-widget;, and &gtk-radio-button-new-with-mnemonic-from-widget;.
    </para>
    <para>
     It is also a good idea to explicitly set which button should be the default depressed button with the
     function &gtk-toggle-button-active;. This is described in the section on toggle buttons, and works in
     exactly the same way. Once the radio buttons are grouped together, only one of the group may be active at
     a time. If the user clicks on one radio button, and then on another, the first radio button will first
     emit a "toggled" signal (to report becoming inactive), and then the second will emit its "toggled" signal
     (to report becoming active).
    </para>

    <figure id="figure-toggle-buttons">
     <title>Toggle Buttons</title>
     <mediaobject>
      <imageobject>
       <imagedata fileref="figures/toggle-buttons.png" format="png"></imagedata>
      </imageobject>
     </mediaobject>
    </figure>

    <example id="example-toggle-buttons">
     <title>Toggle Buttons</title>
     <programlisting xmlns:xi="http://www.w3.org/2001/XInclude">
<xi:include href="../demo/gtk-example/toggle-buttons.lisp" parse="text"/>
     </programlisting>
    </example>
   </section>
  </section>

  <section id="Link_Button" revision="2021-5-20">
   <title>Link Button</title>
   <para>
    A &gtk-link-button; widget is a &gtk-button; widget with a hyperlink, similar to the one used by web
    browsers, which triggers an action when clicked. It is useful to show quick links to resources.
   </para>
   <para>
    A link button is created by calling either the functions &gtk-link-button-new; or
    &gtk-link-button-new-with-label;. If using the former, the URI you pass to the constructor is used as a
    label for the widget. The URI bound to a link button can be set specifically or retrieved using the
    slot access function &gtk-link-button-uri;.
   </para>
   <para>
    By default, the &gtk-link-button; widget calls the function &gtk-show-uri; when the button is clicked.
    This behavior can be overridden by connecting to the "activate-link" signal and returning the value
    &gdk-event-stop; from the signal handler.
   </para>
   <para>
    <xref linkend="figure-link-button"/> shows two different styles of link buttons. The code is shown in
    <xref linkend="example-link-button"/>.
   </para>

   <figure id="figure-link-button">
    <title>Link Button</title>
    <mediaobject>
     <imageobject>
      <imagedata fileref="figures/link-button.png" format="png"></imagedata>
     </imageobject>
    </mediaobject>
   </figure>

   <example id="example-link-button">
    <title>Link Button</title>
    <programlisting xmlns:xi="http://www.w3.org/2001/XInclude">
<xi:include href="../demo/gtk-example/link-button.lisp" parse="text"/>
    </programlisting>
   </example>
  </section>

  <section id="Switch" revision="2021-5-20">
   <title>Switch</title>
   <para>
    The &gtk-switch; widget has two states: on or off. The user can control which state should be active by
    clicking the switch, or by dragging the handle. The switch is created with the function &gtk-switch-new;
    or the call <code>(make-instance 'gtk-switch)</code>.
   </para>
   <para>
    The &gtk-switch; widget has the &gtk_switch_active; property, which can be set or retrieved with the slot
    access function &gtk-switch-active;.
   </para>
   <para>
    An example of a switch is shown in <xref linkend="figure-switch"/>. The code is shown in
    <xref linkend="example-switch"/>. Note that in the example the "notify::active" signal is connected to
    the switch to display a label with the state of the switch.
   </para>

   <figure id="figure-switch">
    <title>Switch</title>
    <mediaobject>
     <imageobject>
      <imagedata fileref="figures/switch.png" format="png"></imagedata>
     </imageobject>
    </mediaobject>
   </figure>

   <example id="example-switch">
     <title>Switch</title>
     <programlisting xmlns:xi="http://www.w3.org/2001/XInclude">
<xi:include href="../demo/gtk-example/switch.lisp" parse="text"/>
     </programlisting>
   </example>
  </section>

  <section id="Scale_Button" revision="2021-5-20">
   <title>Scale Button</title>
   <para>
     The &gtk-scale-button; widget provides a button which pops up a scale widget. This kind of widget is
     commonly used for volume controls in multimedia applications, and GTK provides a &gtk-volume-button;
     subclass that is tailored for this use case.
   </para>
   <para>
    The &gtk_scale_button_icons; property holds a list of strings with the names of the icons to be used by
    the scale button. The first item in the list will be used in the button when the current value is the
    lowest value, the second item for the highest value. All the subsequent icons will be used for all the
    other values, spread evenly over the range of values. If there is only one icon name in the icons list,
    it will be used for all the values. If only two icon names are in the icons array, the first one will be
    used for the bottom 50% of the scale, and the second one for the top 50%. It is recommended to use at
    least three icons so that the scale button reflects the current value of the scale better for the users.
   </para>
   <para>
    <xref linkend="figure-scale-button"/> shows an example with seven icons which represents the values
    from 0.0 to 10.0. <xref linkend="example-scale-button"/> shows the code of the example.
   </para>

   <figure id="figure-scale-button">
    <title>Scale Button</title>
    <mediaobject>
     <imageobject>
      <imagedata fileref="figures/scale-button.png" format="png"></imagedata>
     </imageobject>
    </mediaobject>
   </figure>

   <example id="example-scale-button">
    <title>Scale Button</title>
    <programlisting xmlns:xi="http://www.w3.org/2001/XInclude">
<xi:include href="../demo/gtk-example/scale-button.lisp" parse="text"/>
    </programlisting>
   </example>
  </section>
 </chapter>

 <chapter id="Display_Widgets" revision="2021-5-21">
  <title>Display Widgets</title>

  <section id="Label_Widget" revison="2021-5-21">
   <title>Label Widget</title>
   <para>
    Labels are used a lot in GTK, and are relatively simple. The &gtk-label; widget displays a small amount
    of text. As the name implies, most labels are used to label another widget such as a &gtk-button; widget,
    a &gtk-menu-item; widget, or a &gtk-combo-box; widget. Labels emit no signals as they do not have an
    associated X window. If you need to catch signals, or do clipping, place it inside a &gtk-event-box;
    widget or a button widget.
   </para>
   <para>
    To create a new label, use the function <code>make-instance</code> with the class name &gtk-label; or the
    functions &gtk-label-new; or &gtk-label-new-with-mnemonic;. The sole argument of the functions is the
    string you wish the label to display. To retrieve or change the text of the label after creation, use the
    function &gtk-label-text;. The first argument is the label you created previously, and the second is the
    new string. The space needed for the new string will be automatically adjusted if needed. You can produce
    multi-line labels by putting line breaks in the label string.
   </para>

   <figure id="figure-label">
    <title>Labels</title>
    <mediaobject>
     <imageobject>
      <imagedata fileref="figures/label.png" format="png"></imagedata>
     </imageobject>
    </mediaobject>
   </figure>

   <bridgehead>Label with Mnemonics</bridgehead>
    <para>
     Labels may contain mnemonics. Mnemonics are underlined characters in the label, used for keyboard
     navigation. Mnemonics are created by providing a string with an underscore before the mnemonic
     character, such as "_File", to the functions &gtk-label-new-with-mnemonic; or
     &gtk-label-set-text-with-mnemonic;.
    </para>
    <para>
     Mnemonics automatically activate any activatable widget the label is inside, such as a &gtk-button;
     widget. If the label is not inside the target widget of the mnemonic, you have to tell the label about
     the target using the function &gtk-label-mnemonic-widget;.
    </para>
    <para>
     Here is a simple example where the label is inside a button:
    </para> 
    <programlisting>
;; Pressing Alt+H will activate this button
(let* ((button (gtk-button-new))
       (label (gtk-label-new-with-mnemonic "_Hello")))
  (gtk-container-add button label)
  [...] )
    </programlisting>
    <para>
     There is the convenience function &gtk-button-new-with-mnemonic; to create buttons with a mnemonic label
     already inside:
    </para>
    <programlisting>
;; Pressing Alt+H will activate this button
(let ((button (gtk-button-new-with-mnemonic "_Hello")))
  [...] )
    </programlisting>
    <para>
     To create a mnemonic for a widget alongside the label, such as a &gtk-entry; widget, you have to point
     the label at the entry with the function &gtk-label-mnemonic-widget;:
    </para>
    <programlisting>
;; Pressing Alt+H will focus the entry
(let ((entry (gtk-entry-new))
      (label (gtk-label-new-with-mnemonic "_Hello")))
  (setf (gtk-label-mnemonic-widget label) entry)
  [...] )
    </programlisting>

   <bridgehead>Label with Markup (styled text)</bridgehead>
    <para>
     To make it easy to format text in a label (changing colors, fonts, etc.), label text can be provided in
     a simple markup format. Here is how to create a label with a small font:
    </para>
    <programlisting>
(let ((label (gtk-label-new)))
  (gtk-label-set-markup label
                        "&lt;small>Small text&lt;/small>")
  [...] )
    </programlisting>
    <para>
     or
    </para>
    <programlisting>
(let ((label (make-instance 'gtk-label
                            :use-markup t
                            :label "&lt;small>Small text&lt;/small>")))
  [...] )
    </programlisting>
    <para>
     (See complete documentation of available tags in the Pango manual.)
    </para>
    <para>
     The markup passed to the function &gtk-label-set-markup; must be valid. For example, literal &lt;, > and 
     &amp; characters must be escaped as \&lt;, \&gt;, and \&amp;. If you pass text obtained from the user,
     file, or a network to the function &gtk-label-set-markup;, you will want to escape it with the functions
     <code>g_markup_escape_text ()</code> or <code>g_markup_printf_escaped ()</code>. Note: The
     functions <code>g_markup_escape_text ()</code> and <code>g_markup_printf_escaped ()</code> are not
     implemented in the Lisp binding.
    </para>
    <para>
     Markup strings are just a convenient way to set the &pango-attr-list; attributes on a label. The function
     &gtk-label-attributes; may be a simpler way to set attributes in some cases. Be careful though, the
     &pango-attr-list; attributes tends to cause internationalization problems, unless you are applying
     attributes to the entire string (i.e. unless you set the range of each attribute to
     <code>[0, G_MAXINT)</code>). The reason is that specifying the <code>start_index</code> and
     <code>end_index</code> for a <code>PangoAttribute</code> requires knowledge of the exact string being
     displayed, so translations will cause problems.
    </para>

   <bridgehead>Selectable Labels</bridgehead>
    <para>
     Labels can be made selectable with the function &gtk-label-selectable;. Selectable labels allow the user
     to copy the label contents to the clipboard. Only labels that contain useful-to-copy information - such
     as error messages - should be made selectable.
    </para>

   <bridgehead>Text Layout</bridgehead>
    <para>
     A label can contain any number of paragraphs, but will have performance problems if it contains more
     than a small number. Paragraphs are separated by newlines or other paragraph separators understood by
     Pango.
    </para>
    <para>
     The label widget is capable of line wrapping the text automatically. This can be activated using the
     function &gtk-label-line-wrap;. The first argument is the label and the second argument take the values
     <emphasis>true</emphasis> or <emphasis>false</emphasis> to switch on or to switch off the line wrapping.
    </para>
    <para>
     The function &gtk-label-justify; sets how the lines in a label align with one another. The first argument
     is the label and the second argument one of the following values of the &gtk-justification; enumeration. 
     The possible values are shown in <xref linkend="table-gtk-justification"/>. If you want to set how the
     label as a whole aligns in its available space, see the &gtk_widget_halign; and &gtk_widget_valign;
     properties.
    </para>

    <table id="table-gtk-justification">
     <caption>GtkJustification</caption>
     <colgroup>
      <col style="width:30%"/>
      <col style="width:70%"/>
     </colgroup>
     <tr>
      <th align="left">Value</th>
      <th align="left">Description</th>
     </tr>
     <tr>
      <td colspan="2" style="border-top:2px solid #ff9900;"></td>
     </tr>
     <tr valign="top">
      <td><code>:left</code></td>
      <td>The text is placed at the left edge of the label.</td>
     </tr>
     <tr valign="top">
      <td><code>:right</code></td>
      <td>The text is placed at the right edge of the label.</td>
     </tr>
     <tr valign="top">
      <td><code>:center</code></td>
      <td>The text is placed in the center of the label.</td>
     </tr>
     <tr valign="top">
      <td><code>:fill</code></td>
      <td>The text is placed is distributed across the label.</td>
     </tr>
     <tr>
      <td colspan="2" style="border-top:1px solid #ff9900;"></td>
     </tr>
    </table>

    <para>
     The &gtk_label_width-chars; and &gtk_label_max-width-chars; properties can be used to control the size
     allocation of ellipsized or wrapped labels. For ellipsizing labels, if either is specified (and less than
     the actual text size), it is used as the minimum width, and the actual text size is used as the natural
     width of the label. For wrapping labels, the &gtk_label_width-chars; property is used as the minimum
     width, if specified, and the &gtk_label_max-width-chars; property is used as the natural width. Even if
     the &gtk_label_max-width-chars; property specified, wrapping labels will be rewrapped to use all of the
     available width.
    </para>
    <para>
     Note that the interpretation of “width-chars” and “max-width-chars” has changed a bit with the
     introduction of width-for-height geometry management.
    </para>
    <para>
     If you want your label underlined, then you can set a pattern on the label with the function
     &gtk-label-pattern;. The pattern argument indicates how the underlining should look. It consists of a
     string of underscore and space characters. An underscore indicates that the corresponding character in
     the label should be underlined. For example, the string "__ __" would underline the first two characters
     and eight and ninth characters.
    </para>

   <bridgehead>Links</bridgehead>
    <para>
     GTK supports markup for clickable hyperlinks in addition to regular Pango markup. The markup for links
     is borrowed from HTML, using the a with href and title attributes. GTK renders links similar to the
     way they appear in web browsers, with colored, underlined text. The title attribute is displayed as a
     tooltip on the link. An example looks like this:
    </para>
    <programlisting>
(gtk-label-set-markup label
                      "Go to the &lt;a href=\"http://gtk.org/\"> GTK Website&lt;/a> for more ...")))
    </programlisting>
    <para>
     It is possible to implement custom handling for links and their tooltips with the "activate-link" signal
     and the function &gtk-label-current-uri;.
    </para>

   <bridgehead>GtkLabel as GtkBuildable</bridgehead>
    <para>
     The &gtk-label; widget implementation of the &gtk-buildable; interface supports a custom
     <code>&lt;attributes></code> element, which supports any number of <code>&lt;attribute></code> elements.
     The <code>&lt;attribute></code> element has attributes named <code>name</code>, <code>value</code>,
     <code>start</code> and <code>end</code> and allows you to specify <code>PangoAttribute</code> values for
     this label.
    </para>
    <example id="example-label-ui">
     <title>A UI definition fragment specifying Pango attributes</title>
     <programlisting>
&lt;object class="GtkLabel">
  &lt;attributes>
    &lt;attribute name="weight" value="PANGO_WEIGHT_BOLD"/>
    &lt;attribute name="background" value="red" start="5" end="10"/>"
  &lt;/attributes>
&lt;/object>
     </programlisting>
    </example>
    <para>
     The <code>start</code> and <code>end</code> attributes specify the range of characters to which the 
     Pango attribute applies. If <code>start</code> and <code>end</code> are not specified, the attribute
     is applied to the whole text. Note that specifying ranges does not make much sense with translatable
     attributes. Use markup embedded in the translatable content instead.
    </para>

   <bridgehead>Examples</bridgehead>
    <para>
     <xref linkend="figure-label"/> and <xref linkend="figure-label-more"/> illustrate the functions for
     the &gtk-label; widget. The code for these examples is shown in <xref linkend="example-label"/> and
     <xref linkend="example-label-more"/>.
    </para>

    <example id="example-label">
     <title>Labels</title>
    <programlisting xmlns:xi="http://www.w3.org/2001/XInclude">
<xi:include href="../demo/gtk-example/label.lisp" parse="text"/>
    </programlisting>
    </example>

    <figure id="figure-label-more">
     <title>More Labels</title>
     <mediaobject>
      <imageobject>
       <imagedata fileref="figures/label-more.png" format="png"></imagedata>
      </imageobject>
     </mediaobject>
    </figure>

    <example id="example-label-more">
     <title>More Labels</title>
    <programlisting xmlns:xi="http://www.w3.org/2001/XInclude">
<xi:include href="../demo/gtk-example/label-more.lisp" parse="text"/>
    </programlisting>
    </example>
  </section>

  <section id="Image_Widget" revision="2021-5-23">
   <title>Image Widget</title>
   <para>
    The &gtk-image; widget displays an image. Various kinds of object can be displayed as an image. Most
    typically, you would load a &gdk-pixbuf; object ("pixel buffer") from a file, and then display that. There
    is a convenience function &gtk-image-new-from-file; to do this, used as follows:
   </para>
   <programlisting>
(let ((image (gtk-image-new-from-file "myfile.png")))
  ... )
   </programlisting>
   <para>
    If the file is not loaded successfully, the image will contain a "broken image" icon similar to that used
    in many web browsers. If you want to handle errors in loading the file yourself, for example by displaying
    an error message, then load the image with the function &gdk-pixbuf-new-from-file;, then create the
    &gtk-image; widget with the function &gtk-image-new-from-pixbuf;.
   </para>
   <para>
    The image file may contain an animation, if so the &gtk-image; widget will display an animation
    instead of a static image.
   </para>
   <para>
    The &gtk-image; widget is a subclass of the &gtk-misc; class, which implies that you can align it (center,
    left, right) and add padding to it, using the functions of the &gtk-misc; class.
   </para>
   <para>
    The &gtk-image; widget is a "no window" widget (has no &gdk-window; object of its own), so by default does
    not receive events. If you want to receive events on the image, such as button clicks, place the image
    inside a &gtk-event-box; widget, then connect to the event signals on the event box.
   </para>
   <programlisting>
(let ((event-box (make-instance 'gtk-event-box))
      (image (gtk-image-new-from-file "myfile.png")))
  (g-signal-connect event-box "button-press-event"
     (lambda (event-box event)
       (format t "Event Box ~A clicked at (~A, ~A)~%"
                 event-box
                 (gdk-event-button-x event)
                 (gdk-event-button-y event))
       ...

       ;; Returning +gdk-event-stop+ means we handled the event, so the signal
       ;; emission should be stopped (do not call any further callbacks that
       ;; may be connected). Return +gdk-event-propagate+ to continue invoking
       ;; callbacks.
       +gdk-event-stop+))
  ... )
   </programlisting>
   <para>
    When handling events on the event box, keep in mind that coordinates in the image may be different from
    event box coordinates due to the alignment and padding settings on the image (see the &gtk-misc; widget.
    The simplest way to solve this is to set the alignment to 0.0 (left/top), and set the padding to zero.
    Then the origin of the image will be the same as the origin of the event box.
   </para>

   <figure id="figure-image">
    <title>Images</title>
    <mediaobject>
     <imageobject>
      <imagedata fileref="figures/image.png" format="png"></imagedata>
     </imageobject>
    </mediaobject>
   </figure>

   <para>
    <xref linkend="example-image"/> shows various images. The code includes an example of parsing an image
    data file in small chunks with the &gdk-pixbuf-loader; class. The image is reloaded when clicking the
    image. This is an example for using a &gtk-event-box; widget to receive and process the "button-press"
    signal on an image. The output of this example is shown in <xref linkend="figure-image"/>.
   </para>

   <example id="example-image">
    <title>Image Widget</title>
    <programlisting xmlns:xi="http://www.w3.org/2001/XInclude">
<xi:include href="../demo/gtk-example/image.lisp" parse="text"/>
    </programlisting>
   </example>
  </section>

  <section id="Info_Bars">
   <title>Info Bars</title>
   <figure id="figure-info-bar">
    <title>Info Bar</title>
    <mediaobject>
     <imageobject>
      <imagedata fileref="figures/info-bar385x165.png" format="png"></imagedata>
     </imageobject>
    </mediaobject>
   </figure>
   <para>
    <ulink url="&gtk-info-bar;"><code>gtk-info-bar</code></ulink> is a widget that can be used to show
    messages to the user without showing a dialog. It is often temporarily shown at the top or bottom of
    a document. In contrast to &gtk-dialog;, which has a
    horizontal action area at the bottom, <ulink url="&gtk-info-bar;"><code>gtk-info-bar</code></ulink>
    has a vertical action area at the side.
   </para>
   <para>
    The API of <ulink url="&gtk-info-bar;"><code>gtk-info-bar</code></ulink> is very similar to
    &gtk-dialog;, allowing you to add buttons to the action
    area with <ulink url="&gtk-info-bar-add-button;"><code>gtk-info-bar-add-button</code></ulink> or
    <ulink url="&gtk-info-bar-new-with-buttons;"><code>gtk-info-bar-new-with-buttons</code></ulink>. The
    sensitivity of action widgets can be controlled with <ulink url="&gtk-info-bar-set-response-sensitive;">
    <code>gtk-info-bar-set-response-sensitive</code></ulink>. To add widgets to the main content area of a
    <ulink url="&gtk-info-bar;"><code>gtk-info-bar</code></ulink>, use the function
    <ulink url="&gtk-info-bar-content-area;"><code>gtk-info-bar-content-area</code></ulink> and add your
    widgets to the container.
   </para>
   <para>
    Similar to <ulink url="&gtk-message-dialog;"><code>gtk-message-dialog</code></ulink>, the contents of a
    <ulink url="&gtk-info-bar;"><code>gtk-info-bar</code></ulink> can by classified as error message,
    warning, informational message, etc, by using <ulink url="&gtk-info-bar-message-type;">
    <code>gtk-info-bar-message-type</code></ulink>. GTK uses the message type to determine the background
    color of the message area.
   </para>
   <example id="example-info-bar">
    <title>Info Bar</title>
    <programlisting>
(defun example-info-bar ()
  (within-main-loop
    (let* ((window (make-instance 'gtk-window
                                  :type :toplevel
                                  :title "Example Info bar"
                                  :border-width 12
                                  :default-width 250))
           (grid (make-instance 'gtk-grid))
           (info-bar (make-instance 'gtk-info-bar
                                    :no-show-all t))
           (message (make-instance 'gtk-label
                                   :label ""))
           (content (gtk-info-bar-content-area info-bar)))
      (g-signal-connect window "destroy"
                        (lambda (widget)
                          (declare (ignore widget))
                          (leave-gtk-main)))
      (gtk-widget-show message)
      ;; Add a label to the content area of the info bar
      (gtk-container-add content message)
      ;; Add a button OK to the action area
      (gtk-info-bar-add-button info-bar "gtk-ok" 1)
      ;; Add two more buttons to the action area
      (gtk-info-bar-add-buttons info-bar "gtk-cancel" 2
                                         "gtk-no" 3)
      ;; Connect a handler for the "response" signal of the info bar
      (g-signal-connect info-bar "response"
         (lambda (widget response-id)
           (declare (ignore widget))
           (format t "response-id is ~A~%" response-id)
           (gtk-widget-hide info-bar)))
      (gtk-grid-attach grid info-bar 0 2 1 1)
      ;; Show the info bar
      (setf (gtk-label-text message) "An Info Message in the content area.")
      (setf (gtk-info-bar-message-type info-bar) :info)
      (gtk-widget-show info-bar)
      ;; Add the container grid to the window and show all
      (gtk-container-add window grid)
      (gtk-widget-show-all window))))
    </programlisting>
   </example>
  </section>

  <section id="Progress_Bars" revision="2021-5-2">
   <title>Progress Bars</title>

   <figure id="figure-progress-bar">
    <title>Progress Bar</title>
    <mediaobject>
     <imageobject>
      <imagedata fileref="figures/progress-bar.png" format="png"></imagedata>
     </imageobject>
    </mediaobject>
   </figure>

   <para>
    Progress bars are implemented as the &gtk-progress-bar; class and are used to show the status of an
    operation. They are pretty easy to use, as you will see with the code below. But first lets start out
    with the function &gtk-progress-bar-new; to create a new progress bar. Now that the progress bar has been
    created we can use it and set the fraction with the function &gtk-progress-bar-fraction;, which has two
    arguments. The first argument is the progress bar you wish to operate on, and the second argument is
    the amount "completed", meaning the amount the progress bar has been filled from 0 - 100%. This is passed
    to the function as a real number ranging from 0.0 to 1.0.
   </para>
   <para>
    A progress bar may be set to one of a number of orientations using the function
    &gtk-orientable-orientation;. The second argument is the orientation and may take one of the values of
    <code>:horizontal</code> or <code>:vertical</code> of the &gtk-orientation; enumeration. Progress bars
    normally grow from top to bottom or left to right. With the function &gtk-progress-bar-inverted; can be
    set to grow in the opposite direction.
   </para>
   <para>
    As well as indicating the amount of progress that has occurred, the progress bar may be set to just
    indicate that there is some activity. This can be useful in situations where progress cannot be measured
    against a value range. The function &gtk-progress-bar-pulse; indicates that some progress has been made.
    The step size of the activity indicator is set using the function &gtk-progress-bar-pulse-step;.
   </para>
   <para>
    The progress bar can also display a configurable text string within its trough, using the function
    &gtk-progress-bar-text;. You can turn off the display of the string by calling the function
    &gtk-progress-bar-text; again with <code>nil</code> as second argument. The current text setting of a
    progress bar can be retrieved with the function &gtk-progress-bar-text;.
   </para>
   <para>
    Progress bars are usually used with timeouts or other such functions to give the illusion of multitasking.
    All will employ the functions &gtk-progress-bar-fraction; or &gtk-progress-bar-pulse; in the same manner.
   </para>
   <para>
    <xref linkend="example-progress-bar"/> shows an example of the progress bar, updated using timeouts. This
    code also shows how to reset the progress bar. The output of this example is shown in
    <xref linkend="figure-progress-bar"/>.
   </para>

   <example id="example-progress-bar">
    <title>Progress Bar</title>
    <programlisting xmlns:xi="http://www.w3.org/2001/XInclude">
<xi:include href="../demo/gtk-example/progress-bar.lisp" parse="text"/>
    </programlisting>
   </example>
  </section>

  <section id="Statusbars">
   <sectioninfo>
    <itermset>
     <indexterm zone="Statusbars"><primary>GtkStatusbar</primary></indexterm>
     <indexterm zone="Statusbars"><primary>statusbar, gtk-statusbar</primary></indexterm>
    </itermset>
   </sectioninfo>
   <title>Statusbars</title>
   <figure id="figure-statusbar">
    <title>Statusbar</title>
    <mediaobject>
     <imageobject>
      <imagedata fileref="figures/statusbar302x142.png" format="png"></imagedata>
     </imageobject>
    </mediaobject>
   </figure>
   <para>
    Statusbars are simple widgets used to display a text message. They keep a stack of the messages pushed
    onto them, so that popping the current message will re-display the previous text message.
   </para>
   <para>
    In order to allow different parts of an application to use the same statusbar to display messages, the
    statusbar widget issues context Identifiers which are used to identify different "users". The message
    on top of the stack is the one displayed, no matter what context it is in. Messages are stacked in
    last-in-first-out order, not context identifier order.
   </para>
   <para>
    A statusbar is created with a call to <ulink url="&gtk-statusbar-new;">
    <code>gtk-statusbar-new</code></ulink>. A new context Identifier is requested using a call to the
    function <ulink url="&gtk-statusbar-context-id;"><code>gtk-statusbar-context-id</code></ulink> with a
    short textual description of the context as the second argument.
   </para>
   <para>
    There are three functions that can operate on statusbars: <ulink url="&gtk-statusbar-push;">
    <code>gtk-statusbar-push</code></ulink>, <ulink url="&gtk-statusbar-pop;">
    <code>gtk-statusbar-pop</code></ulink>, and <ulink url="&gtk-statusbar-remove;">
    <code>gtk-statusbar-remove</code></ulink>. The first function, <ulink url="&gtk-statusbar-push;">
    <code>gtk-statusbar-push</code></ulink>, is used to add a new message to the statusbar. It returns a
    message identifier, which can be passed later to the function <ulink url="&gtk-statusbar-remove;">
    <code>gtk-statusbar-remove</code></ulink> to remove the message with the given message and context
    identifiers from the stack of the statusbar. The function <ulink url="&gtk-statusbar-pop;">
    <code>gtk-statusbar-pop</code></ulink> removes the message highest in the stack with the given context
    identifier.
   </para>
   <para>
    The example <link linkend="example-statusbar">Statusbar</link> creates a statusbar and two buttons, one
    for pushing items onto the statusbar, and one for popping the last item back off.
   </para>
   <example id="example-statusbar">
    <title>Statusbar</title>
    <programlisting>
(defun example-statusbar ()
  (within-main-loop
    (let* ((window (make-instance 'gtk-window
                                  :type :toplevel
                                  :title "Example Status Bar"
                                  :default-width 300
                                  :border-width 12))
           (vbox (make-instance 'gtk-box
                                :orientation :vertical
                                :homogeneous nil
                                :spacing 3))
           (statusbar (make-instance 'gtk-statusbar))
           (id (gtk-statusbar-context-id statusbar "Example Status Bar"))
           (count 0))
      (g-signal-connect window "destroy"
                        (lambda (widget)
                          (declare (ignore widget))
                          (leave-gtk-main)))
      (gtk-box-pack-start vbox statusbar)
      (let ((button (gtk-button-new-with-label "Push Item")))
        (g-signal-connect button "clicked"
           (lambda (widget)
             (declare (ignore widget))
             (setq count (+ 1 count))
             (gtk-statusbar-push statusbar id (format nil "Item &#x7e;A" count))))
        (gtk-box-pack-start vbox button :expand t :fill t :padding 3))
      (let ((button (gtk-button-new-with-label "Pop Item")))
        (g-signal-connect button "clicked"
           (lambda (widget)
             (declare (ignore widget))
             (gtk-statusbar-pop statusbar id)))
        (gtk-box-pack-start vbox button :expand t :fill t :padding 3))
      (gtk-container-add window vbox)
      (gtk-widget-show window))))
    </programlisting>
   </example>
  </section>
 </chapter>

 <chapter id="Adjustments">
  <sectioninfo>
   <itermset>
    <indexterm zone="Adjustments"><primary>GtkAdjustment</primary></indexterm>
    <indexterm zone="Adjustments"><primary>adjustment, gtk-adjustment</primary></indexterm>
   </itermset>
  </sectioninfo>
  <title>Adjustments</title>

  <section id="Introduction_to_Adjustments">
   <title>Introduction to Adjustments</title>
   <para>
    GTK has various widgets that can be visually adjusted by the user using the mouse or the keyboard, such
    as the range widgets, described in <link linkend="Range_Widgets">Range Widgets</link>. There are also a
    few widgets that display some adjustable portion of a larger area of data, such as the viewport widget
    &gtk-viewport;.
   </para>
   <para>
    Obviously, an application needs to be able to react to changes the user makes in range widgets. One way
    to do this would be to have each widget emit its own type of signal when its adjustment changes, and
    either pass the new value to the signal handler, or require it to look inside the data structure of the
    widget in order to ascertain the value. But you may also want to connect the adjustments of several
    widgets together, so that adjusting one adjusts the others. The most obvious example of this is
    connecting a scrollbar to a panning viewport or a scrolling text area. If each widget has its own way of
    setting or getting the adjustment value, then the programmer may have to write their own signal handlers
    to translate between the "output" of one widget's signal and the "input" of another's adjustment setting
    function.
   </para>
   <para>
    GTK solves this problem using the object &gtk-adjustment;,
    which is not a widget but a way for widgets to store and pass
    adjustment information in an abstract and flexible form. The most obvious use of
    &gtk-adjustment; is to store the configuration
    parameters and values of range widgets, such as scrollbars and scale controls. However, since
    &gtk-adjustment; is derived from
    <ulink url="&g-object;"><code>g-object</code></ulink>, adjustments have some special powers beyond those
    of normal data structures. Most importantly, they can emit signals, just like widgets, and these signals
    can be used not only to allow a program to react to user input on adjustable widgets, but also to
    propagate adjustment values transparently between adjustable widgets.
   </para>
   <para>
    You will see how adjustments fit in when you see the other widgets that incorporate them: Progress Bars,
    Viewports, Scrolled Windows, and others.
   </para>
  </section>

  <section id="Creating_an_Adjustment">
   <sectioninfo>
    <itermset>
     <indexterm zone="Creating_an_Adjustment"><primary>adjustment-new, gtk-adjustment-new</primary></indexterm>
    </itermset>
   </sectioninfo>
   <title>Creating an Adjustment</title>
   <para>
    Many of the widgets which use adjustment objects do so automatically, but some cases will be shown in
    later examples where you may need to create an adjustment yourself. An adjustment can be created with
    the function <ulink url="&gtk-adjustment-new;"><code>gtk-adjustment-new</code></ulink> which has the
    arguments <code>value</code>, <code>lower</code>, <code>upper</code>, <code>step-increment</code>,
    <code>page-increment</code>, and <code>page-size</code>.
   </para>
   <para>
    The argument <code>value</code> is the initial value you want to give to the adjustment, usually
    corresponding to the topmost or leftmost position of an adjustable widget. The argument
    <code>lower</code> specifies the lowest value which the adjustment can hold. The argument
    <code>step-increment</code> specifies the "smaller" of the two increments by which the user can change
    the value, while <code>page-increment</code> is the "larger" one. The argument <code>page-size</code>
    usually corresponds somehow to the visible area of a panning widget. The argument <code>upper</code> is
    used to represent the bottom most or right most coordinate in a panning widget's child. Therefore it is
    not always the largest number that <code>value</code> can take, since <code>page-size</code> of such
    widgets is usually non-zero.
   </para>
  </section>

  <section id="Using_Adjustments_the_Easy_Way">
   <sectioninfo>
    <itermset>
     <indexterm zone="Using_Adjustments_the_Easy_Way"><primary>viewport-new, gtk-viewport-new</primary></indexterm>
     <indexterm zone="Using_Adjustments_the_Easy_Way"><primary>scrollable-get-vadjustment, gtk-scrollable-get-vadjustment</primary></indexterm>
    </itermset>
   </sectioninfo>
   <title>Using Adjustments the Easy Way</title>
   <para>
    The adjustable widgets can be roughly divided into those which use and require specific units for these
    values and those which treat them as arbitrary numbers. The group which treats the values as arbitrary
    numbers includes the range widgets (scrollbars and scales, the progress bar widget, and the spin button
    widget). These widgets are all the widgets which are typically "adjusted" directly by the user with the
    mouse or keyboard. They will treat the lower and upper values of an adjustment as a range within which
    the user can manipulate the value of the adjustment. By default, they will only modify the value of an
    adjustment.
   </para>
   <para>
    The other group includes the text widget, the viewport widget, the compound list widget, and the scrolled
    window widget. All of these widgets use pixel values for their adjustments. These are also all widgets
    which are typically "adjusted" indirectly using scrollbars. While all widgets which use adjustments
    can either create their own adjustments or use ones you supply, you will generally want to let this
    particular category of widgets create its own adjustments. Usually, they will eventually override all
    the values except the value itself in whatever adjustments you give them, but the results are, in
    general, undefined (meaning, you'll have to read the source code to find out, and it may be different
    from widget to widget).
   </para>
   <para>
    Now, you are probably thinking, since text widgets and viewports insist on setting everything except the
    value of their adjustments, while scrollbars will only touch the value of the adjustment, if you share an
    adjustment object between a scrollbar and a text widget, manipulating the scrollbar will automagically
    adjust the viewport widget? Of course it will! Just like this:
   </para>
   <programlisting>
(let (;; A viewport creates its own adjustments
      (viewport (gtk-viewport-new))
      ;; use the adjustment from the viewport for the scrollbar
      (vscrollbar (make-instance 'gtk-scrollbar
                                 :orientation :vertical
                                 :vadjustment
                                 (gtk-scrollable-get-vadjustment viewport))))
  [...] )
   </programlisting>
  </section>

  <section id="Adjustment_Internals">
   <sectioninfo>
    <itermset>
     <indexterm zone="Adjustment_Internals"><primary>adjustment-value, gtk-adjustment-value</primary></indexterm>
    </itermset>
   </sectioninfo>
   <title>Adjustment Internals</title>
   <para>
    Ok, you say, that's nice, but what if I want to create my own handlers to respond when the user adjusts a
    range widget or a spin button, and how do I get at the value of the adjustment in these handlers? To
    answer these questions and more, let's start by taking a look at the Lisp class representing
    &gtk-adjustment; itself:
   </para>
   <programlisting>
(define-g-object-class "GtkAdjustment" gtk-adjustment
  (:superclass gtk-object
   :export t
   :interfaces nil
   :type-initializer "gtk_adjustment_get_type")
  ((lower
    gtk-adjustment-lower
    "lower" "gdouble" t t)
   (page-increment
    gtk-adjustment-page-increment
    "page-increment" "gdouble" t t)
   (page-size
    gtk-adjustment-page-size
    "page-size" "gdouble" t t)
   (step-increment
    gtk-adjustment-step-increment
    "step-increment" "gdouble" t t)
   (upper
    gtk-adjustment-upper
    "upper" "gdouble" t t)
   (value
    gtk-adjustment-value
    "value" "gdouble" t t)))
   </programlisting>
   <para>
    The slots of the class are <code>lower</code>, <code>page-increment</code>, <code>page-size</code>,
    <code>step-increment</code>, <code>upper</code>, and <code>value</code>. The slots represent the
    properties of the C class &gtk-adjustment;. The slots
    can be accessed with the corresponding Lisp accessor functions. Alternativly, the C accessor functions
    like <code>gtk_adjustment_set_value()</code> and <code>gtk_adjustment_set_value()</code> are availabe in
    the Lisp binding through e.g. <ulink url="&gtk-adjustment-value;">
    <code>gtk-adjustment-value</code></ulink> for the property <code>value</code>.
   </para>
   <para>
    As mentioned earlier, an adjustment object is a subclass of <ulink url="&g-object;">
    <code>g-object</code></ulink> just like all the various widgets, and thus it is able to emit signals.
    This is, of course, why updates happen automagically when you share an adjustment object between a
    scrollbar and another adjustable widget; all adjustable widgets connect signal handlers to their
    adjustment's "value-changed" signal, as can your program.
   </para>
   <para>
    The various widgets that use the adjustment object will emit the signal "value-changed" on an adjustment
    whenever they change its value. This happens both when user input causes the slider to move on a range
    widget, as well as when the program explicitly changes the value with
    <ulink url="&gtk-adjustment-value;"><code>gtk-adjustment-value</code></ulink>. So, for example, if you
    have a scale widget, and you want to change the rotation of a picture whenever its value changes, you
    would create a callback like this:
   </para>
   <programlisting>
(defun cb-rotate-picture (adj picture)
  (set-picture-rotation picture (gtk-adjustment-get-value adj))
  ... )
   </programlisting>
   <para>
    and connect it to the scale widget's adjustment like this:
   </para>
   <programlisting>
(g-signal-connect adj "value-changed"
                  (lambda (widget)
                    (cb-rotate-picture widget picture)))
   </programlisting>
   <para>
    What about when a widget reconfigures the upper or lower fields of its adjustment, such as when a user
    adds more text to a text widget? In this case, it emits the signal "changed". Range widgets typically
    connect a handler to this signal, which changes their appearance to reflect the change - for example,
    the size of the slider in a scrollbar will grow or shrink in inverse proportion to the difference
    between the lower and upper values of its adjustment.
   </para>
   <para>
    You probably won't ever need to attach a handler to the signal "changed", unless you are writing a new
    type of range widget. However, if you change any of the values in an adjustment directly, you should
    emit this signal on it to reconfigure whatever widgets are using it, like this
    <code>(g-signal-emit adj "changed")</code>.
   </para>
  </section>
 </chapter>

 <chapter id="Range_Widgets">
  <title>Range Widgets</title>
  <sectioninfo>
   <itermset>
    <indexterm zone="Range_Widgets"><primary>GtkRange</primary></indexterm>
   </itermset>
  </sectioninfo>
  <section id="Introduction_to_Range_Widgets">
   <title>Introduction to Range Widgets</title>
   <para>
    The category of range widgets includes the ubiquitous scrollbar widget and the less common scale widget.
    Though these two types of widgets are generally used for different purposes, they are quite similar in
    function and implementation. All range widgets share" a set of common graphic elements, each of which
    has its own X window and receives events. They all contain a "trough" and a "slider" (what is sometimes
    called a "thumbwheel" in other GUI environments). Dragging the slider with the pointer moves it back and
    forth within the trough, while clicking in the trough advances the slider towards the location of the
    click, either completely, or by a designated amount, depending on which mouse button is used.
   </para>
   <para>
    As mentioned in <link linkend="Adjustments">Adjustments</link>, all range widgets are associated with an
    adjustment object, from which they calculate the length of the slider and its position within the trough.
    When the user manipulates the slider, the range widget will change the value of the adjustment.
   </para>
  </section>

  <section id="Scale_Widgets">
   <title>Scale Widgets</title>
   <para>
    Scale widgets are used to allow the user to visually select and manipulate a value within a specific
    range. You might want to use a scale widget, for example, to adjust the magnification level on a zoomed
    preview of a picture, or to control the brightness of a color, or to specify the number of minutes of
    inactivity before a screensaver takes over the screen.
   </para>
   <para>
    As with scrollbars, the <ulink url="&gtk-scale;"><code>gtk-scale</code></ulink> widget is a horizontal or
    vertical scale, depending on the value of the &gtk_orientable_orientation;
    property. A scale can be created with the function
    <ulink url="&gtk-scale-new;"><code>gtk-scale-new</code></ulink>, which takes two arguments. The first
    argument gives the direction <code>:horizontal</code> or <code>:vertical</code> and the second a
    &gtk-adjustment;.
   </para>
   <para>
    The adjustment argument can either be an adjustment which has already been created with
    <ulink url="&gtk-adjustment-new;"><code>gtk-adjustment-new</code></ulink>, or <code>NIL</code>, in which
    case, an anonymous adjustment is created with all of its values set to 0.0 (which is not very useful in
    this case). In order to avoid confusing yourself, you probably want to create your adjustment with a
    &gtk_adjustment_page-size; of 0.0 so that its upper value
    actually corresponds to the highest value the user can select. The function
    <ulink url="&gtk-scale-new-with-range;"><code>gtk-scale-new-with-range</code></ulink> variant take care
    of creating a suitable adjustment. The function takes four arguments. The first argument is again the
    orientation of the scale and the next arguments represent the values for creating an
    &gtk-adjustment; with intial values for the properties
    &gtk_adjustment_lower;, &gtk_adjustment_upper;, and &gtk_adjustment_step-increment;.
    If you are already thoroughly confused, read the section
    <link linkend="Adjustments">Adjustments</link> again for an explanation of what exactly adjustments do
    and how to create and manipulate them.
   </para>

   <section id="Functions_and_Signals">
   <sectioninfo>
    <itermset>
     <indexterm zone="Functions_and_Signals"><primary>GtkPositionType</primary></indexterm>
     <indexterm zone="Functions_and_Signals"><primary>positon-type, gtk-position-type</primary></indexterm>
     <indexterm zone="Functions_and_Signals"><primary>scale-draw-value, gtk-scale-draw-value</primary></indexterm>
     <indexterm zone="Functions_and_Signals"><primary>scale-set-digits, gtk-scale-set-digits</primary></indexterm>
     <indexterm zone="Functions_and_Signals"><primary>scale-value-pos, gtk-scale-value-pos</primary></indexterm>
    </itermset>
   </sectioninfo>
    <title>Functions and Signals</title>
    <para>
     Scale widgets can display their current value as a number beside the trough.  The default behaviour is
     to show the value, but you can change this with this with the generic function
     <ulink url="&gtk-scale-draw-value;"><code>gtk-scale-draw-value</code></ulink>, which takes as the first
     argument a widget of type <ulink url="&gtk-scale;"><code>gtk-scale</code></ulink> and as the second
     argument <code>draw-value</code>, which is either <code>T</code> or <code>NIL</code>, with predictable
     consequences for either one.
    </para>
    <para>
     The value displayed by a scale widget is rounded to one decimal point by default, as is the value field
     in its adjustment.  You can change this with the function <ulink url="&gtk-scale-digits;">
     <code>gtk-scale-digits</code></ulink>.  The first argument is a widget of type <ulink url="&gtk-scale;">
     <code>gtk-scale</code></ulink> and the second argument <code>digits</code>, where <code>digits</code> is
     the number of decimal places you want.  You can set digits to anything you like, but no more than 13
     decimal places will actually be drawn on screen.
    </para>
    <para>
     Finally, the value can be drawn in different positions relative to the trough with the generic function
     <ulink url="&gtk-scale-value-pos;"><code>gtk-scale-value-pos</code></ulink>.  The first argument is
     again a scale widget.  The second argument <code>pos</code> is of the enumeration type
     <ulink url="&gtk-position-type;"><code>gtk-position-type</code></ulink>.
    </para>
    <para>
     If you position the value on the "side" of the trough (e.g., on the top or bottom of a horizontal scale
     widget), then it will follow the slider up and down the trough.
    </para>
   </section>
  </section>

  <section id="Common_Range_Functions">
   <title>Common Range Functions</title>
   <para>
    The range widget class is fairly complicated internally, but, like all the base class widgets, most of
    its complexity is only interesting if you want to hack on it.  Also, almost all of the functions and
    signals it defines are only really used in writing derived widgets.  There are, however, a few useful
    functions that will work on all range widgets.
   </para>

   <section id="Getting_and_Setting_Adjustments">
    <sectioninfo>
     <itermset>
      <indexterm zone="Getting_and_Setting_Adjustments">
       <primary>range-adjustment, gtk-range-adjustment</primary>
      </indexterm>
      <indexterm zone="Getting_and_Setting_Adjustments">
       <primary>range-adjustment-changed, gtk-range-adjustment-changed</primary>
      </indexterm>     
     </itermset>
    </sectioninfo>
    <title>Getting and Setting Adjustments</title>
    <para>
     Getting and setting the adjustment for a range widget "on the fly" is done with the function
     <ulink url="&gtk-range-adjustment;"><code>gtk-range-adjustment</code></ulink>.  The function
     <ulink url="&gtk-range-adjustment;"><code>gtk-range-adjustment</code></ulink> returns the adjustment to
     which the range is connected.
    </para>
    <para>
     <ulink url="&gtk-range-adjustment;"><code>gtk-range-adjustment</code></ulink> does absolutely nothing
     if you pass it the adjustment that range is already using, regardless of whether you changed any of its
     fields or not.  If you pass it a new adjustment, it will unreference the old one if it exists (possibly
     destroying it), connect the appropriate signals to the new one, and emit the "changed" signal, which
     will recalculate the size or position of the slider and redraw if necessary.  As mentioned in the
     section on adjustments, if you wish to reuse the same adjustment, when you modify its values directly,
     you should emit the "changed" signal on it.
    </para>
   </section>

   <section id="Key_and_Mouse_bindings">
    <title>Key and Mouse bindings</title>
    <para>
     All of the GTK range widgets react to mouse clicks in more or less the same way.  Clicking button-1 in
     the trough will cause its adjustment's <code>page-increment</code> to be added or subtracted from its
     value, and the slider to be moved accordingly.  Clicking mouse button-2 in the trough will jump the
     slider to the point at which the button was clicked.  Clicking button-3 in the trough of a range or any
     button on a scrollbar's arrows will cause its adjustment's value to change by
     <code>step-increment</code> at a time.
    </para>
    <para>
     Scrollbars are not focusable, thus have no key bindings.  The key bindings for the other range widgets
     (which are, of course, only active when the widget has focus) are do not differentiate between
     horizontal and vertical range widgets.
    </para>
    <para>
     All range widgets can be operated with the left, right, up and down arrow keys, as well as with the Page
     Up and Page Down keys.  The arrows move the slider up and down by <code>step-increment</code>, while
     Page Up and Page Down move it by <code>page-increment</code>.
    </para>
    <para>
     The user can also move the slider all the way to one end or the other of the trough using the keyboard.
     This is done with the Home and End keys.
    </para>
   </section>
  </section>

  <section id="Example_Range_Widgets">
   <title>Example Range Widgets</title>
   <figure id="figure-range-widgets">
    <title>Range Widgets</title>
    <mediaobject>
     <imageobject>
      <imagedata fileref="figures/range-widgets269x420.gif" format="gif"></imagedata>
     </imageobject>
    </mediaobject>
   </figure>
   <para>
    The example <link linkend="example-range-widgets">Range Widgets</link> is a somewhat modified version of
    the "range controls" test from <filename>testgtk.c</filename>.  It basically puts up a window with three
    range widgets all connected to the same adjustment, and a couple of controls for adjusting some of the
    parameters mentioned above and in the section on adjustments, so you can see how they affect the way
    these widgets work for the user.
   </para>
   <para>
    You will notice that the program does not call &g-signal-connect;
    for the "delete-event", but only for the "destroy" signal. This
    will still perform the desired function, because an unhandled "delete-event" will result in a "destroy"
    signal being given to the window.
   </para>
   <example id="example-range-widgets">
     <title>Range Widgets</title>
     <programlisting>
(defun example-range-widgets ()
  (within-main-loop
    (let* ((window (make-instance 'gtk-window
                                  :type :toplevel
                                  :title "Example Range Widgets"))
           (box1 (make-instance 'gtk-box
                                :orientation :vertical
                                :homogeneous nil
                                :spacing 0))
           (box2 (make-instance 'gtk-box
                                :orientation :horizontal
                                :homogeneous nil
                                :spacing 12
                                :border-width 12))
           (box3 (make-instance 'gtk-box
                                :orientation :vertical
                                :homogeneous nil
                                :spacing 12))
           (adj1 (make-instance 'gtk-adjustment
                                :value 0.0
                                :lower 0.0
                                :upper 101.0
                                :step-increment 0.1
                                :page-increment 1.0
                                :page-size 1.0))
           (vscale (make-instance 'gtk-scale
                                  :orientation :vertical
                                  :digits 1
                                  :value-pos :top
                                  :draw-value t
                                  :adjustment adj1))
           (hscale (make-instance 'gtk-scale
                                   :orientation :horizontal
                                   :digits 1
                                   :value-pos :top
                                   :draw-value t
                                   :width-request 200
                                   :height-request -1
                                   :adjustment adj1))
           (scrollbar (make-instance 'gtk-scrollbar
                                     :orientation :horizontal
                                     :adjustment adj1)))
      ;; Connect a handler for the signal "destroy" to the main window.
      (g-signal-connect window "destroy"
                        (lambda (widget)
                          (declare (ignore widget))
                          (leave-gtk-main)))
      ;; Packing of the global widgets hscale, vscale, and scrollbar
      (gtk-container-add window box1)
      (gtk-box-pack-start box1 box2)
      (gtk-box-pack-start box2 vscale)
      (gtk-box-pack-start box2 box3)
      (gtk-box-pack-start box3 hscale)
      (gtk-box-pack-start box3 scrollbar)
      ;; A check button to control whether the value is displayed or not.
      (let ((box (make-instance 'gtk-box
                                :orientation :horizontal
                                :homogeneous nil
                                :spacing 12
                                :border-width 12))
            (button (make-instance 'gtk-check-button
                                   :label "Display value on scale widget"
                                   :active t)))
        (g-signal-connect button "toggled"
           (lambda (widget)
             (setf (gtk-scale-draw-value hscale)
                   (gtk-toggle-button-active widget))
             (setf (gtk-scale-draw-value vscale)
                   (gtk-toggle-button-active widget))))
        (gtk-box-pack-start box button)
        (gtk-box-pack-start box1 box))
      ;; A ComboBox to change the position of the value.
      (let ((box (make-instance 'gtk-box
                                :orientation :horizontal
                                :homogeneous nil
                                :spacing 12
                                :border-width 12))
            (combo (make-instance 'gtk-combo-box-text)))
        (gtk-combo-box-text-append-text combo "TOP")
        (gtk-combo-box-text-append-text combo "BOTTOM")
        (gtk-combo-box-text-append-text combo "LEFT")
        (gtk-combo-box-text-append-text combo "RIGHT")
        (setf (gtk-combo-box-active combo) 0)
        (g-signal-connect combo "changed"
           (lambda (widget)
             (let ((pos (gtk-combo-box-text-get-active-text widget)))
               (format t "type      : ~A~%"
                         (g-type-from-instance (pointer widget)))
               (format t "active is : ~A~%"
                         (gtk-combo-box-active widget))
               (setq pos (if pos (intern pos :keyword) :top))
               (setf (gtk-scale-value-pos hscale) pos)
               (setf (gtk-scale-value-pos vscale) pos))))
        (gtk-box-pack-start box
                            (make-instance 'gtk-label
                                           :label "Scale value position")
                            :expand nil :fill nil :padding 0)
        (gtk-box-pack-start box combo)
        (gtk-box-pack-start box1 box))
      ;; Create a scale to change the digits of hscale and vscale.
      (let* ((box (make-instance 'gtk-box
                                 :orientation :horizontal
                                 :homogeneous nil
                                 :spacing 12
                                 :border-width 12))
             (adj (make-instance 'gtk-adjustment
                                 :value 1.0
                                 :lower 0.0
                                 :upper 5.0
                                 :step-increment 1.0
                                 :page-increment 1.0
                                 :page-size 0.0))
             (scale (make-instance 'gtk-scale
                                   :orientation :horizontal
                                   :digits 0
                                   :adjustment adj)))
        (g-signal-connect adj "value-changed"
           (lambda (adjustment)
             (setf (gtk-scale-digits hscale)
                   (truncate (gtk-adjustment-value adjustment)))
             (setf (gtk-scale-digits vscale)
                   (truncate (gtk-adjustment-value adjustment)))))
        (gtk-box-pack-start box
                            (make-instance 'gtk-label
                                           :label "Scale Digits:")
                            :expand nil :fill nil)
        (gtk-box-pack-start box scale)
        (gtk-box-pack-start box1 box))
      ;; Another hscale for adjusting the page size of the scrollbar
      (let* ((box (make-instance 'gtk-box
                                 :orientation :horizontal
                                 :homogeneous nil
                                 :spacing 12
                                 :border-width 12))
             (adj (make-instance 'gtk-adjustment
                                 :value 1.0
                                 :lower 1.0
                                 :upper 101.0
                                 :step-increment 1.0
                                 :page-increment 1.0
                                 :page-size 0.0))
             (scale (make-instance 'gtk-scale
                                   :orientation :horizontal
                                   :digits 0
                                   :adjustment adj)))
        (g-signal-connect adj "value-changed"
           (lambda (adjustment)
             (setf (gtk-adjustment-page-size adj1)
                   (gtk-adjustment-page-size adjustment))
             (setf (gtk-adjustment-page-increment adj1)
                   (gtk-adjustment-page-increment adjustment))))
        (gtk-box-pack-start box
                            (make-instance 'gtk-label
                                           :label "Scrollbar Page Size:")
                            :expand nil :fill nil)
        (gtk-box-pack-start box scale)
        (gtk-box-pack-start box1 box))
      ;; Add a separator
      (gtk-box-pack-start box1
                          (make-instance 'gtk-separator
                                         :orientation :horizontal)
                          :expand nil :fill t)
      ;; Create the quit button.
      (let ((box (make-instance 'gtk-box
                                :orientation :vertical
                                :homogeneous nil
                                :spacing 12
                                :border-width 12))
            (button (make-instance 'gtk-button :label "Quit")))
        (g-signal-connect button "clicked"
                          (lambda (button)
                            (declare (ignore button))
                            (gtk-widget-destroy window)))
        (gtk-box-pack-start box button)
        (gtk-box-pack-start box1 box :expand nil))
      (gtk-widget-show-all window))))
    </programlisting>
   </example>
  </section>
 </chapter>

 <chapter id="Layout_Widgets">
  <title>Layout Widgets</title>
  <section id="Alignment_Widget">
   <sectioninfo>
    <itermset>
     <indexterm zone="Alignment_Widget">
      <primary>GtkAlignment</primary>
     </indexterm>
     <indexterm zone="Alignment_Widget">
      <primary>alignment, gtk-alignment</primary>
     </indexterm>
     <indexterm zone="Alignment_Widget">
      <primary>alignment-new, gtk-alignment-new</primary>
     </indexterm>
     <indexterm zone="Alignment_Widget">
      <primary>alignment-set, gtk-alignment-set</primary>
     </indexterm>
     <indexterm zone="Alignment_Widget">
      <primary>alignment-get-padding, gtk-alignment-get-padding</primary>
     </indexterm>
     <indexterm zone="Alignment_Widget">
      <primary>alignment-set-padding, gtk-alignment-set-padding</primary>
     </indexterm>
    </itermset>
   </sectioninfo>
   <title>Alignment Widget</title>
   <figure id="figure-alignment-widget">
    <title>Alignment Widget</title>
    <mediaobject>
     <imageobject>
      <imagedata fileref="figures/alignment302x329.png" format="png"></imagedata>
     </imageobject>
    </mediaobject>
   </figure>
   <para>
    The alignment container <ulink url="&gtk-alignment;"><code>gtk-alignment</code></ulink> allows to place
    a widget within its window at a position and size relative to the size of the
    <ulink url="&gtk-alignment;"><code>gtk-alignment</code></ulink> container itself.  For example, it can
    be very useful for centering a widget within the window.
   </para>
   <para>
    The <ulink url="&gtk-alignment;"><code>gtk-alignment</code></ulink> container has the four properties
    <code>xalign</code>, <code>yalign</code>, <code>xscale</code>, and <code>yscale</code>.  The properties
    are floating point numbers.  The align settings are used to place the child widget within the available
    area.  The values range from <code>0.0</code> (top or left) to <code>1.0</code> (bottom or right).  Of
    course, if the scale settings are both set to <code>1.0</code>, the alignment settings have no effect.
    The scale settings are used to specify how much the child widget should expand to fill the space
    allocated to the <ulink url="&gtk-alignment;"><code>gtk-alignment</code></ulink>.  The values can range
    from <code>0.0</code> (meaning the child does not expand at all) to <code>1.0</code> (meaning the child
    expands to fill all of the available space).
   </para>
   <para>
    The properties are set when creating the <ulink url="&gtk-alignment;"><code>gtk-alignment</code></ulink>
    container with the function <ulink url="&gtk-alignment-new;"><code>gtk-alignment-new</code></ulink>.  For
    an existing <ulink url="&gtk-alignment;"><code>gtk-alignment</code></ulink> container the properties can
    be set with the function <ulink url="&gtk-alignment-set;"><code>gtk-alignment-set</code></ulink>. A child
    widget can be added to the <ulink url="&gtk-alignment;"><code>gtk-alignment</code></ulink> container
    using the function &gtk-container-add;.
   </para>
   <para>
    In addition, the <ulink url="&gtk-alignment;"><code>gtk-alignment</code></ulink> container has the
    properties <code>top-padding</code>, <code>bottom-padding</code>, <code>left-padding</code>, and
    <code>right-padding</code>.  These properties control how many space is added to the sides of the widget.
    The functions <ulink url="&gtk-alignment-set-padding;"><code>gtk-alignment-set-padding</code></ulink>
    and <ulink url="&gtk-alignment-get-padding;"><code>gtk-alignment-get-padding</code></ulink> are used to
    set or to retrieve the values of the padding properties.
   </para>
   <note>
    <para>
     Note that the desired effect can in most cases be achieved by using the "halign", "valign" and "margin"
     properties on the child widget, so <ulink url="&gtk-alignment;"><code>gtk-alignment</code></ulink>
     should not be used in new code.
    </para>
   </note>
   <example id="example-alignment-widget">
    <title>Alignment Widget</title>
    <programlisting>
(defun example-alignment ()
  (within-main-loop
    (let ((window (make-instance 'gtk-window
                                 :type :toplevel
                                 :title "Example Alignment"
                                 :border-width 12
                                 :width-request 300
                                 :height-request 300))
          (grid (make-instance 'gtk-grid
                                :column-spacing 12
                                :column-homogeneous t
                                :row-spacing 12
                                :row-homogeneous t)))
      (g-signal-connect window "destroy"
                        (lambda (widget)
                          (declare (ignore widget))
                          (leave-gtk-main)))
      (let ((frame (make-instance 'gtk-frame
                                  :label "xalign: 0, yalign: 0"))
            (button (make-instance 'gtk-button
                                   :label "Button"))
            (alignment (make-instance 'gtk-alignment
                                      :xalign 0.00
                                      :yalign 0.00
                                      :xscale 0.50
                                      :yscale 0.25)))
        (gtk-alignment-set-padding alignment 6 6 6 6)
        (gtk-container-add alignment button)
        (gtk-container-add frame alignment)
        (gtk-grid-attach grid frame 0 1 1 1))
      (let ((frame (make-instance 'gtk-frame
                                  :label "xalign: 0, yalign: 1"))
            (button (make-instance 'gtk-button
                                   :label "Button"))
            (alignment (make-instance 'gtk-alignment
                                      :xalign 0.00
                                      :yalign 1.00
                                      :xscale 0.50
                                      :yscale 0.25)))
        (gtk-alignment-set-padding alignment 6 6 6 6)
        (gtk-container-add alignment button)
        (gtk-container-add frame alignment)
        (gtk-grid-attach grid frame 1 1 1 1))
      (let ((frame (make-instance 'gtk-frame
                                  :label "xalign: 1, yalign: 0"))
            (button (make-instance 'gtk-button
                                   :label "Button"))
            (alignment (make-instance 'gtk-alignment
                                      :xalign 1.00
                                      :yalign 0.00
                                      :xscale 0.50
                                      :yscale 0.25)))
        (gtk-alignment-set-padding alignment 6 6 6 6)
        (gtk-container-add alignment button)
        (gtk-container-add frame alignment)
        (gtk-grid-attach grid frame 0 2 1 1))
      (let ((frame (make-instance 'gtk-frame
                                  :label "xalign: 1, yalign: 1"))
            (button (make-instance 'gtk-button
                                   :label "Button"))
            (alignment (make-instance 'gtk-alignment
                                      :xalign 1.00
                                      :yalign 1.00
                                      :xscale 0.50
                                      :yscale 0.25)))
        (gtk-alignment-set-padding alignment 6 6 6 6)
        (gtk-container-add alignment button)
        (gtk-container-add frame alignment)
        (gtk-grid-attach grid frame 1 2 1 1))
      (gtk-container-add window grid)
      (gtk-widget-show-all window))))
    </programlisting>
   </example>
  </section>

  <section id="Fixed_Container" revision="2021-2-9">
   <title>Fixed Container</title>
   <figure id="figure-fixed">
    <title>Fixed Container</title>
    <mediaobject>
     <imageobject>
      <imagedata fileref="figures/fixed.png" format="png"></imagedata>
     </imageobject>
    </mediaobject>
   </figure>
   <para>
    The &gtk-fixed; widget is a container widget which allows to place child widgets at a fixed position
    within the container, relative to the upper left hand corner. The position of the child widgets can be
    changed dynamically. Only a few functions are associated with the fixed container like the functions
    &gtk-fixed-new;, &gtk-fixed-put;, and &gtk-fixed-move;.
   </para>
   <para>
    The function &gtk-fixed-new; creates a new &gtk-fixed; container. The function &gtk-fixed-put; places a
    widget in the container fixed at the position specified by the arguments <code>x</code> and
    <code>y</code>. The function &gtk-fixed-move; allows the specified widget to be moved to a new position.
   </para>
   <para>
    For most applications, you should not use this container. It keeps you from having to learn about the
    other GTK containers, but it results in broken applications. With the fixed container, the following
    things will result in truncated text, overlapping widgets, and other display bugs:
   </para>
   <itemizedlist>
    <listitem>
      Themes, which may change widget sizes.
    </listitem>
    <listitem>
      Fonts other than the one you used to write the application will of course change the size of widgets
      containing text. Keep in mind that users may use a larger font because of difficulty reading the
      default, or they may be using Windows or the framebuffer port of GTK, where different fonts are
      available.
    </listitem>
    <listitem>
      Translation of text into other languages changes its size. Also, display of non-English text will use
      a different font in many cases.
    </listitem>
   </itemizedlist>
   <para>
    In addition, the fixed container can not properly be mirrored in right-to-left languages such as Hebrew
    and Arabic. I.e. normally GTK will flip the interface to put labels to the right of the thing they label,
    but it cannot do that with the fixed container. So your application will not be usable in right-to-left
    languages.
   </para>
   <para>
    Finally, fixed positioning makes it kind of annoying to add/remove GUI elements, since you have to
    reposition all the other elements. This is a long-term maintenance problem for your application.
   </para>
   <para>
    If you know none of these things are an issue for your application, and prefer the simplicity of the
    &gtk-fixed; container, by all means use the widget. But you should be aware of the tradeoffs.
   </para>
   <para>
    The following example illustrates how to use a fixed container. In this example three buttons are put
    into the fixed container at random positions. A click on a button moves the button to a new random
    position. To retrieve the size of the fixed container and the buttons the functions
    &gtk-widget-allocated-width; and &gtk-widget-allocated-height; are used.
   </para>
   <example id="example-fixed">
    <title>Fixed Container</title>
    <programlisting>
(defun move-button (fixed button)
  (let ((width (- (gtk-widget-allocated-width fixed)
                  (gtk-widget-allocated-width button)))
        (height (- (gtk-widget-allocated-height fixed)
                   (gtk-widget-allocated-height button))))
    (gtk-fixed-move fixed button (random width) (random height))))

(defun example-fixed ()
  (within-main-loop
    (let ((window (make-instance 'gtk-window
                                 :type :toplevel
                                 :title "Example Fixed Container"
                                 :default-width 350
                                 :default-height 200
                                 :border-width 12))
          (fixed (make-instance 'gtk-fixed)))
      (g-signal-connect window "destroy"
                        (lambda (window)
                          (declare (ignore window))
                          (leave-gtk-main)))
      (dotimes (i 3)
        (let ((button (gtk-button-new-with-label "Press me")))
          (g-signal-connect button "clicked"
                            (lambda (widget)
                              (move-button fixed widget)))
          (gtk-fixed-put fixed button (random 250) (random 180))))
      (gtk-container-add window fixed)
      (gtk-widget-show-all window))))
    </programlisting>
   </example>
  </section>

  <section id="Button_Boxes" revision="2021-4-30">
   <title>Button Boxes</title>

   <figure id="figure-button-box">
    <title>Button Boxes</title>
    <mediaobject>
     <imageobject>
      <imagedata fileref="figures/button-box.png" format="png"></imagedata>
     </imageobject>
    </mediaobject>
   </figure>

   <para>
    A &gtk-button-box; widget should be used to provide a consistent layout of buttons throughout your
    application. The layout/spacing can be altered by the programmer, or if desired, by the user to alter the
    'feel' of a program to a small degree.
   </para>
   <para>
    The main purpose of &gtk-button-box; widget is to make sure the children have all the same size. The
    &gtk-button-box; widget gives all children the same size, but it does allow 'outliers' to keep their own
    larger size. The function &gtk-button-box-layout-style; retrieves and alters the method used to spread
    the buttons in a button box across the container. To excempt individual children from homogeneous sizing
    regardless of their 'outlier' status, you can set the <code>non-homogeneous</code> child property with
    the function &gtk-button-box-child-non-homogeneous;.
   </para>
   <para>
    You can create a new button box with the function &gtk-button-box-new;, which creates a horizontal or
    vertical button box depending on the argument <code>orientation</code> which takes the values
    <code>:horizontal</code> or <code>:vertical</code>, respectively. Buttons are added to a button box using
    the usual function &gtk-container-add;. The code in <xref linkend="example-button-box"/> shows an example
    that illustrates different layout settings for button boxes.
   </para>

   <example id="example-button-box">
    <title>Button Boxes</title>
    <programlisting xmlns:xi="http://www.w3.org/2001/XInclude">
<xi:include href="../demo/gtk-example/button-box.lisp" parse="text"/>
    </programlisting>
   </example>
  </section>

  <section id="Layout_Widget" revision="2021-4-27">
   <title>Layout Widget</title>

   <para>
    The &gtk-layout; widget is similar to the &gtk-fixed; widget except that it implements an infinite
    scrolling area. A layout widget is created using the function &gtk-layout-new; which accepts the
    optional arguments <code>hadjustment</code> and <code>vadjustment</code> to specify adjustment objects
    that the layout widget will use for its scrolling.
   </para>

   <figure id="figure-layout">
    <title>Layout Widget</title>
    <mediaobject>
     <imageobject>
      <imagedata fileref="figures/layout.png" format="png"></imagedata>
     </imageobject>
    </mediaobject>
   </figure>

   <para>
    Widgets can be added and moved in the layout widget using the functions &gtk-layout-put; and
    &gtk-layout-move;. The size of the layout widget can be set using the function &gtk-layout-size;.
   </para>
   <para>
    The &gtk-layout; class implements the &gtk-scrollable; interface. Therefore, for manipulating the
    horizontal and vertical adjustment objects the functions &gtk-scrollable-hadjustment;
    and &gtk-scrollable-vadjustment; are available.
   </para>

   <example id="example-layout">
    <title>Layout Widget</title>
    <programlisting xmlns:xi="http://www.w3.org/2001/XInclude">
<xi:include href="../demo/gtk-example/layout.lisp" parse="text"/>
    </programlisting>
   </example>
  </section>

  <section id="Frames">
   <title>Frames</title>
   <figure id="figure-frame">
    <title>Frame Widget</title>
    <mediaobject>
     <imageobject>
      <imagedata fileref="figures/frame252x229.png" format="png"></imagedata>
     </imageobject>
    </mediaobject>
   </figure>
   <para>
    Frames can be used to enclose one or a group of widgets with a box which can optionally be labelled.
    The position of the label and the style of the box can be altered to suit.
   </para>
   <para>
    A frame can be created with <code>(make-instance 'gtk-frame)</code> or the function
    <ulink url="&gtk-frame-new;"><code>gtk-frame-new</code></ulink>.  The label is by default placed in the
    upper left hand corner of the frame. A value of <code>NIL</code> for the label argument will result in
    no label being displayed.  The text of the label can be changed using the function
    <ulink url="&gtk-frame-label;"><code>gtk-frame-label</code></ulink>.
   </para>
   <para>
    The position of the label can be changed using the function <ulink url="&gtk-frame-set-label-align;">
    <code>gtk-frame-set-label-align</code></ulink> which has the arguments <code>xalign</code> and
    <code>yalign</code> which take values between 0.0 and 1.0. <code>xalign</code> indicates the position of
    the label along the top horizontal of the frame.  <code>yalign</code> indicates the vertival position of
    the label.  With a value of 0.5 of <code>yalign</code> the label is positioned in the middle of the line
    of the frame.  The default value of <code>xalign</code> is 0.0 which places the label at the left hand
    end of the frame.
   </para>
   <para>
    The function <ulink url="&gtk-frame-shadow-type;"><code>gtk-frame-shadow-type</code></ulink> alters the
    style of the box that is used to outline the frame.  The second argument is a keyword of the enumeration
    type &gtk-shadow-type;.
   </para>
   <para>
    The figure <link linkend="figure-frame">Frame</link> illustrates the use of the frame widget.  The code
    of this example is shown in <link linkend="example-frame">Frame</link>.
   </para>
   <example id="example-frame">
    <title>Frame Widget</title>
    <programlisting>
(defun example-frame ()
  (within-main-loop
    (let ((window (make-instance 'gtk-window
                                 :type :toplevel
                                 :title "Example Frame"
                                 :default-width 250
                                 :default-height 200
                                 :border-width 12))
          (frame (make-instance 'gtk-frame
                                :label "Gtk Frame Widget"
                                :label-xalign 1.0
                                :label-yalign 0.5
                                :shadow-type :etched-in)))
      (g-signal-connect window "destroy"
                        (lambda (widget)
                          (declare (ignore widget))
                          (leave-gtk-main)))
      (gtk-container-add window frame)
      (gtk-widget-show window))))
    </programlisting>
   </example>
  </section>

  <section id="Aspect_Frames">
   <sectioninfo>
    <itermset>
     <indexterm zone="Aspect_Frames">
      <primary>GtkAspectFrame</primary>
     </indexterm>
     <indexterm zone="Aspect_Frames">
      <primary>aspect-frame, gtk-aspect-frame</primary>
     </indexterm>
     <indexterm zone="Aspect_Frames">
      <primary>aspect-frame-new, gtk-aspect-frame-new</primary>
     </indexterm>
    </itermset>
   </sectioninfo>
   <title>Aspect Frames</title>
   <figure id="figure-aspect-frame">
    <title>Aspect Frame Container</title>
    <mediaobject>
     <imageobject>
      <imagedata fileref="figures/aspect-frame302x279.png" format="png"></imagedata>
     </imageobject>
    </mediaobject>
   </figure>
   <para>
    The <ulink url="&gtk-aspect-frame;"><code>gtk-aspect-frame</code></ulink> aspect frame container is like
    a frame container, except that it also enforces the aspect ratio (that is, the ratio of the width to the
    height) of the child widget to have a certain value, adding extra space if necessary.  This is useful,
    for instance, if you want to preview a larger image.  The size of the preview should vary when the user
    resizes the window, but the aspect ratio needs to always match the original image.
   </para>
   <para>
    To create a new aspect frame use <code>(make-instance 'gtk-aspect-frame)</code> or the function
    <ulink url="&gtk-aspect-frame-new;"><code>gtk-aspect-frame-new</code></ulink>.  The arguments
    <code>xalign</code> and <code>yalign</code> specify alignment as with alignment containers.  If the
    property <code>obey-child</code> is <emphasis>true</emphasis>, the aspect ratio of a child widget will
    match the aspect ratio of the ideal size it requests.  Otherwise, it is given by <code>ratio</code>.
   </para>
   <para>
    The options of an existing aspect frame can be changed with the function
    <ulink url="&gtk-aspect-frame-set;"><code>gtk-aspect-frame-set</code></ulink>.
   </para>
   <para>
    As an example, the following program uses an aspect frame widget to present a drawing area whose aspect
    ratio will always be 2:1, no matter how the user resizes the top-level window.
   </para>
   <example id="example-aspect-frame">
    <title>Aspect Frame Container</title>
    <programlisting>
(defun example-aspect-frame ()
  (within-main-loop
    (let ((window (make-instance 'gtk-window
                                 :type :toplevel
                                 :title "Example Aspect Frame"
                                 :default-width 300
                                 :default-height 250
                                 :border-width 12))
          (frame (make-instance 'gtk-aspect-frame
                                :label "2 x 1"
                                :xalign 0.5
                                :yalign 0.5
                                :ratio 2
                                :obey-child nil))
          (area (make-instance 'gtk-drawing-area
                               :width-request 200
                               :hight-request 200)))
      (g-signal-connect window "destroy"
                        (lambda (widget)
                          (declare (ignore widget))
                          (leave-gtk-main)))
      (gtk-container-add window frame)
      (gtk-container-add frame area)
      (gtk-widget-show window))))
    </programlisting>
   </example>
  </section>

  <section id="Paned_Window_Widgets">
   <title>Paned Window Widgets</title>
   <figure id="figure-paned-window">
    <title>Paned Window Widgets</title>
    <mediaobject>
     <imageobject>
      <imagedata fileref="figures/paned-window302x279.png" format="png"></imagedata>
     </imageobject>
    </mediaobject>
   </figure>
   <para>
    <ulink url="&gtk-paned;"><code>gtk-paned</code></ulink> has two panes, arranged either horizontally or
    vertically.  The division between the two panes is adjustable by the user by dragging a handle.
   </para>
   <para>
    A paned window can be created with the function <ulink url="&gtk-paned-new;">
    <code>gtk-paned-new</code></ulink>, which takes as an argument a value of type
    &gtk-orientation;.  With the value
    <code>:horizontal</code> a horizontal paned window is created, and with the value <code>:vertical</code>
    a vertical paned window.
   </para>
   <para>
    Child widgets are added to the panes of the widget with the functions <ulink url="&gtk-paned-pack1;">
    <code>gtk-paned-pack1</code></ulink> and <ulink url="&gtk-paned-pack2;">
    <code>gtk-paned-pack2</code></ulink> or the functions <ulink url="&gtk-paned-add1;">
    <code>gtk-paned-add1</code></ulink> and <ulink url="&gtk-paned-add2;">
    <code>gtk-paned-add2</code></ulink>.  The division between the two children is set by default from the
    size requests of the children, but it can be adjusted by the user.
   </para>
   <para>
    A paned widget draws a separator between the two child widgets and a small handle that the user can drag
    to adjust the division.  It does not draw any relief around the children or around the separator.  (The
    space in which the separator is called the gutter.)  Often, it is useful to put each child inside a
    <ulink url="&gtk-frame;"><code>gtk-frame</code></ulink> with the shadow type set to <code>:in</code> so
    that the gutter appears as a ridge.  No separator is drawn if one of the children is missing.
   </para>
   <para>
    Each child has two options that can be set, <code>resize</code> and <code>shrink</code>.  If
    <code>resize</code> is <code>T</code>, then when the <code>GtkPaned</code> is resized, that child will
    expand or shrink along with the paned widget. If <code>shrink</code> is <code>T</code>, then that child
    can be made smaller than its requisition by the user.  Setting <code>shrink</code> to <code>NIL</code>
    allows the application to set a minimum size.  If <code>resize</code> is <code>NIL</code> for both
    children, then this is treated as if resize is <code>T</code> for both children.
   </para>
   <para>
    The application can set the position of the slider as if it were set by the user, by calling
    <ulink url="&gtk-paned-position;"><code>gtk-paned-position</code></ulink>.
   </para>
   <para>
    The figure <link linkend="figure-paned-window">Paned Window</link> shows a simple example.  The
    corresponding code is shown in example <link linkend="example-paned-window">Paned Window</link>.
   </para>
<!-- TODO: The example is very simple. It is not taken from the GTK 2.0 Tutorial. -->
   <example id="example-paned-window">
    <title>Paned Window Widgets</title>
    <programlisting>
(defun example-paned-window ()
  (within-main-loop
    (let ((window (make-instance 'gtk-window
                                 :type :toplevel
                                 :title "Example Paned Window"
                                 :border-width 12))
          (paned (make-instance 'gtk-paned
                                :orientation :vertical))
          (frame1 (make-instance 'gtk-frame :label "Window 1"))
          (frame2 (make-instance 'gtk-frame :label "Window 2")))
      (g-signal-connect window "destroy"
                        (lambda (widget)
                          (declare (ignore widget))
                          (leave-gtk-main)))
      (setf (gtk-widget-size-request window) '(300 250))
      (gtk-container-add window paned)
      (gtk-paned-add1 paned frame1)
      (gtk-paned-add2 paned frame2)
      (gtk-widget-show-all window))))
    </programlisting>
   </example>
  </section>

  <section id="Scrolled_Windows" revision="2021-3-19">
   <title>Scrolled Windows</title>

   <bridgehead>GtkScrollable</bridgehead>
   <para>
    The &gtk-scrollable; interface is an interface that is implemented by widgets with native scrolling
    ability.This interface provides functions to access the &gtk-adjustment; objects for horizontal and
    vertical srolling and the &gtk-scrollable-policy; settings of the scrollable widget.
   </para>

   <bridgehead>GtkScrollbar</bridgehead>
   <para>
    The &gtk-scrollbar; widget is a horizontal or vertical scrollbar, depending on the value of the
    &gtk_orientable_orientation; property.
   </para>
   <para>
    The position of the thumb in a scrollbar is controlled by the scroll adjustments. See the &gtk-adjustment;
    object for the properties in an adjustment - for the &gtk-scrollbar; widget, the &gtk_adjustment_value;
    property represents the position of the scrollbar, which must be between the &gtk_adjustment_lower;
    value and the difference &gtk_adjustment_upper; - &gtk_adjustment_page-size;. The
    &gtk_adjustment_page-size; property represents the size of the visible scrollable area. The
    &gtk_adjustment_step-increment; and &gtk_adjustment_page-increment; properties are used when the user
    asks to step down, using the small stepper arrows, or page down, using for example the PageDown key.
   </para>

   <bridgehead>GtkViewport</bridgehead>
   <para>
    The &gtk-viewport; widget acts as an adaptor class, implementing scrollability for child widgets that
    lack their own scrolling capabilities. Use the &gtk-viewport; widget to scroll child widgets such as
    &gtk-grid;, &gtk-box;, and so on.
   </para>
   <para>
    If a widget has native scrolling abilities, such as the widgets &gtk-text-view;, &gtk-tree-view; or
    &gtk-icon-view;, it can be added to a &gtk-scrolled-window; widget with the function &gtk-container-add;.
    If a widget does not, you must first add the widget to a &gtk-viewport; widget, then add the viewport to
    the scrolled window. The function &gtk-container-add; does this automatically if a child that does not
    implement the &gtk-scrollable; interface is added to a &gtk-scrolled-window; widget, so you can ignore
    the presence of the viewport.
   </para>
   <para>
    The &gtk-viewport; widget will start scrolling content only if allocated less than the child widget's
    minimum size in a given orientation.
   </para>
   <para>
    A viewport is created with the function &gtk-viewport-new;. The function takes two optional arguments to
    specify the horizontal and vertical adjustments that the widget is to use when you create the widget. It
    will create its own if you use the optional values for the arguments.
   </para>
   <para>
    The &gtk-viewport; widget implement the &gtk-scrollable; interface. Therefore, you can get and set the
    adjustments after the widget has been created using the access functions &gtk-scrollable-hadjustment; and
    &gtk-scrollable-vadjustment;.
   </para>
   <para>
    The viewport function &gtk-viewport-shadow-type; is used to alter the shadow type of the viewport which
    is a value of the &gtk-shadow-type; enumeration.
   </para>

   <bridgehead>GtkScrolledWindow</bridgehead>
   <para>
    The &gtk-scrolled-window; widget is a container that accepts a single child widget, makes that child
    scrollable using either internally added scrollbars or externally associated adjustments, and optionally
    draws a frame around the child.
   </para>
   <para>
    Widgets with native scrolling support, i.e. those whose classes implement the &gtk-scrollable; interface,
    are added directly. For other types of widgets, the &gtk-viewport; class acts as an adaptor, giving
    scrollability to other widgets. The &gtk-scrolled-window; widgets implementation of the function
    &gtk-container-add; intelligently accounts for whether or not the added child is a &gtk-scrollable;
    widget. If it is not, the &gtk-scrolled-window; widget wraps the child in a &gtk-viewport; widget and
    adds that for you. Therefore, you can just add any child widget and not worry about the details.
   </para>
   <para>
    Unless the &gtk_scrolled_window_hscrollbar-policy; and &gtk_scrolled_window_vscrollbar-policy; properties
    are <code>:never</code> or <code>:external</code>, the &gtk-scrolled-window; widget adds internal
    &gtk-scrollbar; widgets around its child. The scroll position of the child, and if applicable the
    scrollbars, is controlled by the &gtk_scrolled_window_hadjustment; and &gtk_scrolled_window_vadjustment;
    properties that are associated with the &gtk-scrolled-window; widget. See the docs on the &gtk-scrollbar;
    widget for the details, but note that the &gtk_adjustment_step-increment; and
    &gtk_adjustment_page-increment; properties are only effective if the policy causes scrollbars to be
    present.
   </para>
   <para>
    If a &gtk-scrolled-window; widget does not behave quite as you would like, or does not have exactly the
    right layout, it is very possible to set up your own scrolling with the &gtk-scrollbar; widget and for
    example a &gtk-grid; widget.
   </para>

   <para>
    The function &gtk-scrolled-window-new; is used to create a new scrolled window, where the first
    optional argument is the adjustment for the horizontal direction, and the second optional argument,
    the adjustment for the vertical direction.
   </para>
   <para>
    The functions &gtk-scrolled-window-hscrollbar-policy; and &gtk-scrolled-window-vscrollbar-policy; set
    the policy to be used with respect to the scrollbars. The scrollbar policy is a value of the
    &gtk-policy-type; enumeration and may be one of <code>:automatic</code> or <code>:always</code>.
    <code>:automatic</code> will automatically decide whether you need scrollbars, whereas
    <code>:always</code> will always leave the scrollbars there. All possible values of the
    &gtk-policy-type; enumeration are listed in <xref linkend="table-gtk-policy-type"/>.
   </para>

   <table id="table-gtk-policy-type">
    <caption>Values of the GtkPolicyType enumeration</caption>
    <colgroup>
       <col style="width:20%"/>
       <col style="width:80%"/>
    </colgroup>
    <tr>
     <th align="left">Value</th>
     <th align="left">Description</th>
    </tr>
    <tr>
     <td colspan="2" style="border-top:2px solid #ff9900;"></td>
    </tr>
    <tr valign="top">
     <td><code>:always</code></td>
     <td>The scrollbar is always visible. The view size is independent of the content.</td>
    </tr>
    <tr>
     <td><code>:automatic</code></td>
     <td>
      The scrollbar will appear and disappear as necessary. For example, when all of a &gtk-tree-view;
      widget cannot be seen.
     </td>
    </tr>
    <tr>
     <td><code>:never</code></td>
     <td>
      The scrollbar should never appear. In this mode the content determines the size.
     </td>
    </tr>
    <tr>
     <td><code>:external</code></td>
     <td>
      Do not show a scrollbar, but do not force the size to follow the content. This can be used e.g. to make
      multiple scrolled windows share a scrollbar.
     </td>
    </tr>
    <tr>
     <td colspan="2" style="border-top:1px solid #ff9900;"></td>
    </tr>
   </table>

   <bridgehead>Example GtkScrolledWindow</bridgehead>

   <figure id="figure-scrolled-window">
    <title>Scrolled Window</title>
    <mediaobject>
     <imageobject>
      <imagedata fileref="figures/scrolled-window.png" format="png"></imagedata>
     </imageobject>
    </mediaobject>
   </figure>

   <para>
    <xref linkend="example-scrolled-window"/> is a simple example that packs an image into a scrolled window.
    Try playing with resizing the window. You will notice how the scrollbars react.
   </para>

   <example id="example-scrolled-window">
    <title>Scrolled Window</title>
    <programlisting xmlns:xi="http://www.w3.org/2001/XInclude">
<xi:include href="../demo/gtk-example/scrolled-window.lisp" parse="text"/>
    </programlisting>
   </example>
  </section>

  <section id="Toolbar">
   <title>Toolbar</title>
   <para>
    A toolbar is created with a call to <ulink url="&gtk-toolbar-new;"><code>gtk-toolbar-new</code></ulink>.
   </para>
   <para>
    A toolbar can contain instances of a subclass of &gtk-tool-item;. To add a &gtk-tool-item;
    to the a toolbar, use <ulink url="&gtk-toolbar-insert;">
    <code>gtk-toolbar-insert</code></ulink>. To remove an item from the toolbar use the function
    &gtk-container-add;. To add a button to the toolbar, add an instance of
    &gtk-tool-button;.
   </para>
   <para>
    Toolbar items can be visually grouped by adding instances of <ulink url="&gtk-separator-tool-item;">
    <code>gtk-separator-tool-item</code></ulink> to the toolbar. If the &gtk-toolbar;
    child property "expand" is <emphasis>true</emphasis> and the property
    <code>"draw"</code> is set to <code>nil</code>, the effect is to force all following items to the end of
    the toolbar.
   </para>
   <para>
    Creating a context menu for the toolbar can be done by connecting to the "popup-context-menu" signal.
   </para>
  </section>

  <section id="Notebook">
   <title>Notebook</title>
   <figure id="figure-notebook">
    <title>Notebook</title>
    <mediaobject>
     <imageobject>
      <imagedata fileref="figures/notebook347x229.png" format="png"></imagedata>
     </imageobject>
    </mediaobject>
   </figure>
   <para>
    The <ulink url="&gtk-notebook;"><code>gtk-notebook</code></ulink> widget is a
    &gtk-container; whose children are pages that can be
    switched between using tab labels along one edge.
   </para>
   <para>
    There are many configuration options for <ulink url="&gtk-notebook;"><code>gtk-notebook</code></ulink>.
    Among other things, you can choose on which edge the tabs appear (see
    <ulink url="&gtk-notebook-tab-pos;"><code>gtk-notebook-tab-pos</code></ulink>), whether, if there are
    too many tabs to fit the notebook should be made bigger or scrolling arrows added (see
    <ulink url="&gtk-notebook-scrollable;"><code>gtk-notebook-scrollable</code></ulink>), and whether there
    will be a popup menu allowing the users to switch pages (see <ulink url="&gtk-notebook-popup-enable;">
    <code>gtk-notebook-popup-enable</code></ulink>, <ulink url="&gtk-notebook-popup-disable;">
    <code>gtk-notebook-popup-disable</code></ulink>).
   </para>
   <example id="example-notebook">
    <title>Notebook</title>
    <programlisting>
(defun example-notebook ()
  (within-main-loop
    (let ((window (make-instance 'gtk-window
                                 :title "Example Notebook"
                                 :type :toplevel
                                 :default-width 250
                                 :default-height 200))
          (expander (make-instance 'gtk-expander
                                   :expanded t
                                   :label "Notebook"))
          (notebook (make-instance 'gtk-notebook
                                   :enable-popup t)))
      (g-signal-connect window "destroy"
                        (lambda (widget)
                          (declare (ignore widget))
                          (leave-gtk-main)))
      (dotimes (i 5)
        (let ((page (make-instance 'gtk-label
                                   :label
                                   (format nil
                                           "Text for page ~A" i)))
              (tab-label (make-instance 'gtk-label
                                        :label (format nil "Tab &#x7e;A" i)))
              (tab-button (make-instance 'gtk-button
                                         :image
                                         (make-instance 'gtk-image
                                                        :stock
                                                        "gtk-close"
                                                        :icon-size 1)
                                         :relief :none)))
          (g-signal-connect tab-button "clicked"
             (let ((page page))
               (lambda (button)
                 (declare (ignore button))
                 (format t "Removing page ~A~%" page)
                 (gtk-notebook-remove-page notebook page))))
          (let ((tab-hbox (make-instance 'gtk-box
                                         :orientation :horizontal)))
            (gtk-box-pack-start tab-hbox tab-label)
            (gtk-box-pack-start tab-hbox tab-button)
            (gtk-widget-show-all tab-hbox)
            (gtk-notebook-add-page notebook page tab-hbox))))
      (gtk-container-add expander notebook)
      (gtk-container-add window expander)
      (gtk-widget-show-all window))))
    </programlisting>
   </example>
  </section>
 </chapter>

 <chapter id="Multiline_Text_Widget">
  <title>Multiline Text Widget</title>

  <section id="Text_Widget_Overview" revision="2021-2-17">
   <title>Text Widget Overview</title>
   <para>
    GTK has a powerful framework for multiline text editing. The primary objects involved in the process
    are the &gtk-text-buffer; object, which represents the text being edited, and the &gtk-text-view; widget,
    a widget which can display a &gtk-text-buffer; object. Each text buffer can be displayed by any number of
    text views.
   </para>
   <para>
    One of the important things to remember about text in GTK is that it is in the UTF-8 encoding. This
    means that one character can be encoded as multiple bytes. Character counts are usually referred to as
    offsets, while byte counts are called indexes. If you confuse these two, things will work fine with
    ASCII, but as soon as your text buffer contains multibyte characters, bad things will happen.
   </para>
   <para>
    Text in a text buffer can be marked with tags. A tag is an attribute that can be applied to some range of
    text. For example, a tag might be called "bold" and make the text inside the tag bold. However, the tag
    concept is more general than that. Tags do not have to affect appearance. They can instead affect the
    behavior of mouse and key presses, "lock" a range of text so the user cannot edit it, or countless other
    things. A tag is represented by a &gtk-text-tag; object. One &gtk-text-tag; object can be applied to any
    number of text ranges in any number of text buffers.
   </para>
   <para>
    Each tag is stored in a &gtk-text-tag-table; object. A tag table defines a set of tags that can be used
    together. Each text buffer has one tag table associated with it. Only tags from that tag table can be
    used with the text buffer. A single tag table can be shared between multiple text buffers, however.
   </para>
   <para>
    Tags can have names, which is convenient sometimes. For example, you can name your tag that makes things
    bold "bold", but they can also be anonymous, which is convenient if you are creating tags on-the-fly.
   </para>
   <para>
    Most text manipulation is accomplished with iterators, represented by a &gtk-text-iter; instance. An
    iterator represents a position between two characters in the text buffer. The &gtk-text-iter; structure
    is a structure designed to be allocated on the stack. It is guaranteed to be copiable by value and never
    contain any heap allocated data. Iterators are not valid indefinitely. Whenever the text buffer is
    modified in a way that affects the number of characters in the text buffer, all outstanding iterators
    become invalid. Note that deleting 5 characters and then reinserting 5 still invalidates iterators,
    though you end up with the same number of characters you pass through a state with a different number.
   </para>
   <para>
    Because of this, iterators cannot be used to preserve positions across text buffer modifications. To
    preserve a position, the &gtk-text-mark; object is ideal. You can think of a text mark as an invisible
    cursor or insertion point. It floats in the text buffer, saving a position. If the text surrounding the
    text mark is deleted, the text mark remains in the position the text once occupied. If text is inserted
    at the text mark, the text mark ends up either to the left or to the right of the new text, depending on
    its gravity. The standard text cursor in left-to-right languages is a text mark with right gravity,
    because it stays to the right of inserted text.
   </para>
   <para>
    Like tags, marks can be either named or anonymous. There are two marks built-in to the &gtk-text-buffer;
    class. These are named "insert" and "selection_bound" and refer to the insertion point and the boundary
    of the selection which is not the insertion point, respectively. If no text is selected, these two marks
    will be in the same position. You can manipulate what is selected and where the cursor appears by moving
    these marks around. If you want to place the cursor in response to a user action, be sure to use the
    function &gtk-text-buffer-place-cursor;, which moves both marks at once without causing a temporary
    selection. Moving one mark then the other temporarily selects the range in between the old and new
    positions.
   </para>
   <para>
    Text buffers always contain at least one line, but may be empty, that is, text buffers can contain zero
    characters. The last line in the text buffer never ends in a line separator (such as newline). The
    other lines in the text buffer always end in a line separator. Line separators count as characters when
    computing character counts and character offsets. Note that some Unicode line separators are represented
    with multiple bytes in UTF-8, and the two-character sequence "\r\n" is also considered a line separator.
   </para>
  </section>

  <section id="Simple_Text_Widget" revision="2021-2-12">
   <title>Simple Text Widget</title>
   <para>
    The &gtk-text-view; widget can be created using the function &gtk-text-view-new;. This function takes no
    arguments. When the text view is created this way, a &gtk-text-buffer; object associated with this text
    view is also created. The text buffer is responsible for storing the text and associated attributes,
    while the text view is responsible for displaying the text, i.e. it provides an I/O interface to buffer.
   </para>
   <para>
    All text modification operations are related to the &gtk-text-buffer; object. The text buffer associated
    with a &gtk-text-view; widget can be obtained using the function &gtk-text-view-buffer; which takes
    the &gtk-text-view; widget as the argument.
   </para>
   <para>
    Some common operations performed on a text view widget are, setting the entire text and reading the
    entire text from the text buffer. The entire text of the text buffer can be set using the slot access
    function &gtk-text-buffer-text;.
   </para>
   <para>
    Getting the entire text of a text buffer, could be a little more complicated than setting the entire text
    of the text buffer. You cannot use the slot access function &gtk-text-buffer-text; to retrieve the text
    from the text buffer, but you must use the function &gtk-text-buffer-get-text;, which takes iterators
    as arguments to select the desired text. Iterators are &gtk-text-iter; objects that represent positions
    between two characters in a text buffer. Iterators in a text buffer can be obtained using many different
    functions, but for our simple case the functions &gtk-text-buffer-start-iter; and
    &gtk-text-buffer-end-iter; can be used to get the iterators at the start and end of the text buffer.
   </para>
   <para>
    To retrieve the entire contents of the text buffer you can use the function &gtk-text-buffer-get-text;
    the following way
   </para>
   <programlisting>
(let* (;; Get the start and end iterators of the text buffer
       (start (gtk-text-buffer-start-iter buffer))
       (end (gtk-text-buffer-end-iter buffer))
       (include-hidden-chars t)
       ;; Get the entire contents of the text buffer
       (text (gtk-text-buffer-get-text buffer start end include-hidden-chars)))
  ... )
   </programlisting>
   <para>
    The argument <code>include-hidden-chars</code> is used to specify whether text for which the text
    attribute invisible is set should be included or not. Text attributes and how to set them will be
    discussed later in this tutorial.
   </para>
   <para>
    In many cases it is also convenient to first create the text buffer with the function
    &gtk-text-buffer-new;, then create a text view for that text buffer with the function
    &gtk-text-view-new-with-buffer;. Or you can change the text buffer the text view displays after the
    text view is created with the slot access function &gtk-text-view-buffer;.
   </para>
   <figure id="figure-simple-text-view">
    <title>Simple Text View</title>
    <mediaobject>
     <imageobject>
      <imagedata fileref="figures/text-view-simple.png" format="png"></imagedata>
     </imageobject>
    </mediaobject>
   </figure>
   <para>
    Below is a sample program, that implements a simple text widget. The program assigns a default text to
    the text buffer. To wrap the text lines at word boundaries the &gtk_text_view_wrap-mode; property is set
    to <code>:word</code>. Other possible values of the &gtk-wrap-mode; enumeration are <code>:none</code>,
    <code>:char</code>, and <code>:word-char</code>. Furthermore, the text gets a small distance of 6 pixel
    to the window using the &gtk_text_view_top-margin;, &gtk_text_view_left-margin;, and
    &gtk_text_view_right-margin; properties of the &gtk-text-view; widget. The text in the text buffer can be
    modified by the user and when the window is closed it prints the contents of the text buffer and quits.
    The window is shown in figure <link linkend="figure-simple-text-view">Simple Text View</link>.
   </para>
   <example id="example-simple-text-view">
    <title>Simple Text View</title>
    <programlisting xmlns:xi="http://www.w3.org/2001/XInclude">
<xi:include href="src/text-view-simple.lisp" parse="text"/>
    </programlisting>
   </example>

   <bridgehead renderas='sect3'>Other functions for text buffers</bridgehead>
   <para>
    The function &gtk-text-buffer-delete; can be used to delete text from a text buffer. It takes the
    &gtk-text-buffer; object and two &gtk-text-iter; iterators for the start and the end of the text as
    arguments. Since this function modifies the text buffer, all outstanding iterators become invalid after
    a call to this function. But, the iterators passed to the function are re-initialized to point to the
    location where the text was deleted.
   </para>
   <para>
    The function &gtk-text-buffer-insert; can be used to insert text into a text buffer at a position
    specified by an iterator or at the current cursor position. In the Lisp implementation the function
    &gtk-text-buffer-insert; combines the functions &gtk-text-buffer-insert;,
    &gtk-text-buffer-insert-at-cursor;, &gtk-text-buffer-insert-interactive;, and
    &gtk-text-buffer-insert-interactive-at-cursor; into one function using the keyword arguments
    <code>position</code>, <code>interative</code>, and <code>editable</code>. As with the function
    &gtk-text-buffer-delete;, the text buffer is modified and hence all outstanding iterators become invalid,
    and the start and end iterators are re-initialized. Hence the same iterator can be used for a series of
    consecutive inserts.
   </para>
   <para>
    The function &gtk-text-buffer-bounds; can be used to get iterators at the beginning and end of the text
    buffer in one go. The variant &gtk-text-buffer-selection-bounds; can be used to obtain iterators at the
    beginning and end of the current selection. The functions &gtk-text-buffer-iter-at-offset;,
    &gtk-text-buffer-iter-at-line;, &gtk-text-buffer-iter-at-line-offset;, and
    &gtk-text-buffer-iter-at-line-index; can be used to obtain an iterator at a specified character offset
    into the text buffer, at the start of the given line, at an character offset into a given line, or at
    a byte offset into a given line, respectively.
   </para>
  </section>

  <section id="Formatted_Text_in_the_Text_Widget">
   <title>Formatted Text in the Text Widget</title>

   <section id="Changing_Text_Attributes" revision="2021-2-12">
    <title>Changing Text Attributes</title>
    <para>
     The way to affect text attributes in the &gtk-text-view; widget is to apply tags that change the
     attributes for a region of text. For text features that come from the theme — such as font and
     foreground color — use CSS to override their default values.
    </para>
    <figure id="figure-text-view-attributes">
     <title>Changing Text Attributes of a Text View</title>
     <mediaobject>
      <imageobject>
       <imagedata fileref="figures/text-view-attributes.png" format="png"></imagedata>
      </imageobject>
     </mediaobject>
    </figure>
    <example id="example-text-view-attributes">
     <title>Changing Text Attributes of a Text View</title>
    <programlisting xmlns:xi="http://www.w3.org/2001/XInclude">
<xi:include href="src/text-view-attributes.lisp" parse="text"/>
    </programlisting>
    </example>
   </section>

   <section id="More_about_Tags" revsion="2021-2-13">
    <title>More about Tags</title>
    <para>
      The &gtk-text-view; widget can also be used to display formatted text. This usually involves creating
      tags which represent a group of attributes and then applying them to a range of text.
    </para>
    <para>
     Tag objects are associated with a text buffer and are created using the function
     &gtk-text-buffer-create-tag;. This function takes as arguments a &gtk-text-buffer; object, a string for
     a optional tag name, and keyword/value pairs for the properties of the &gtk-text-tag; object. Tags can
     be optionally associated with a name. Thus, the tag could be referred using the returned &gtk-text-tag;
     object or using the tag name. For anonymous tags, <code>nil</code> is passed as an argument. The group
     of properties represented by this tag is listed as keyword/value pairs after the tag name argument.
     Common property keywords are <code>:style</code>, <code>:weight</code>, <code>:editable</code>,
     <code>:justification</code>. The following table lists some properties with their meaning and assignable
     values. See the &gtk-text-tag; documentation for a complete list of properties and their corresponding
     values.
    </para>
    <table>
     <caption>Properties used for creating Tags</caption>
     <colgroup>
        <col style="width:20%"/>
        <col style="width:50%"/>
        <col style="width:30%"/>
     </colgroup>
     <tr>
      <th align="left">Property</th>
      <th align="left">Description</th>
      <th align="left">Values</th>
     </tr>
     <tr>
      <td colspan="3" style="border-top:2px solid #ff9900;"></td>
     </tr>
     <tr valign="top">
      <td><code>:style</code></td>
      <td>Font style as a value of the &pango-style; enumeration.</td>
      <td><code>:normal</code> <code>:oblique</code> <code>:italic</code></td>
     </tr>
     <tr valign="top">
      <td><code>:weight</code></td>
      <td>Font weight as an integer. See predefined values in the &pango-weight; enumeration.</td>
      <td><code>:thin</code>, <code>:normal</code>, <code>:bold</code></td>
     </tr>
     <tr valign="top">
      <td><code>:editable</code></td>
      <td>Whether the text can be modified by the user.</td>
      <td><emphasis>true</emphasis> <emphasis>false</emphasis></td>
     </tr>
     <tr valign="top">
      <td><code>:justification</code></td>
      <td>Justification of the text as an value of the &gtk-justification; enumeration.</td>
      <td><code>:left</code> <code>:right</code> <code>:center</code> <code>:fill</code></td>
     </tr>
     <tr valign="top">
      <td><code>:foreground</code></td>
      <td>The foreground color as a string.</td>
      <td>e.g. "Red" or "rgb(255,0,0)"</td>
     </tr>
     <tr valign="top">
      <td><code>:background</code></td>
      <td>The background color as a string.</td>
      <td>e.g. "Red" or "rgb(255,0,0)"</td>
     </tr>
     <tr valign="top">
      <td><code>:wrap-mode</code></td>
      <td>
       A value of the &gtk-wrap-mode; enumeration whether to wrap lines never, at word boundaries, or at
       character boundaries.
      </td>
      <td><code>:none</code> <code>:char</code> <code>:word</code> <code>:word-char</code></td>
     </tr>
     <tr valign="top">
      <td><code>:font</code></td>
      <td>Font description as a string.</td>
      <td>e.g. "Sans Italic 12"</td>
     </tr>
     <tr>
      <td colspan="3" style="border-top:1px solid #ff9900;"></td>
     </tr>
    </table>
    <para>
     The created tag can then be applied to a range of text using the functions &gtk-text-buffer-apply-tag;
     and &gtk-text-buffer-apply-tag-by-name;. The first function specifies the tag to be applied by a
     &gtk-text-tag; object and the second function specifies the tag by it's name. The range of text over
     with the tag is to applies is specified by start and end iterators. Tags applied to a range of text can
     be removed by using the function &gtk-text-buffer-remove-tag;. This function also has the
     &gtk-text-buffer-remove-tag-by-name; variant. All tags on a range of text can be removed in one go using
     the function &gtk-text-buffer-remove-all-tags;.
    </para>

    <figure id="figure-text-tags">
     <title>Applying tags to text</title>
     <mediaobject>
      <imageobject>
       <imagedata fileref="figures/text-view-tags.png" format="png"></imagedata>
      </imageobject>
     </mediaobject>
    </figure>

   <!-- TODO: More text for the example -->

    <para>
     Below is an extension of the previous example, that has a toolbar to apply different tags to selected
     regions of the text.
    </para>

    <example id="example-text-tags">
     <title>Applying tags to text</title>
    <programlisting xmlns:xi="http://www.w3.org/2001/XInclude">
<xi:include href="src/text-view-tags.lisp" parse="text"/>
    </programlisting>
    </example>
   </section>

   <bridgehead renderas='sect3'>More Functions for Applying and Removing tags</bridgehead>
   <para>
    In the previous section, the function &gtk-text-buffer-insert; was introduced. A variant
    &gtk-text-buffer-insert-with-tags; of this function can be used to insert text with tags applied.
    The variant &gtk-text-buffer-insert-with-tags-by-name; is also available, in which the tags to be applied
    are specified by the tag names. 
   </para>

   <bridgehead renderas='sect3'>Formatting the Entire Text View</bridgehead>
   <para>
    The above functions apply attributes to portions of text in a buffer. If attributes have to be applied
    for the entire &gtk-text-view; widget, the functions for the text view can be used. For example, the
    function &gtk-text-view-editable; makes the text view editable/non-editable. See the
    <ulink url="http://crategus.com/books/cl-cffi-gtk">cl-cffi-gtk API documentation</ulink> for a complete
    documentation of available functions. The attributes set by these functions, on the entire widget, can be
    overridden by applying tags to portions of text in the text buffer.
   </para>
  </section>

<!-- TODO: Implement an example
  <section id="Cut_Copy_and_Paste">
   <title>Cut, Copy and Paste</title>
   <para>
   </para>
  </section>
-->

  <section id="Searching_in_the_Text_Widget">
   <title>Searching in the Text Widget</title>

   <section id="Indroduction_to_Searching" revison="2021-2-16">
   <title>Introduction to Searching</title>
    <para>
     The functions &gtk-text-iter-forward-search; and &gtk-text-iter-backward-search; can be used to search
     for a given text within a text buffer. Both functions return as the first value a boolean to indicate
     whether the search was sucessful. If this is the case the second and third values contain the
     <code>match-start</code> and <code>match-end</code> iterators.
    </para>

    <para>
     The function &gtk-text-iter-forward-search; searches for <code>str</code> starting from the
     <code>iter</code> iterator in the forward direction. The start and end iterators of the first matched
     string are return as the values <code>match-start</code> and <code>match-end</code>. The search is
     limited to the <code>limit</code> iterator, if specified. The function returns <code>nil</code>, if no
     match is found. The function &gtk-text-iter-backward-search; is same as &gtk-text-iter-forward-search;
     but searches in the backward direction.
    </para>

    <para>
     In the Lisp binding to GTK, we have in addition the function &gtk-text-iter-search; which combines the
     functions for forward and backward search and handles the arguments <code>flags</code> and
     <code>limit</code> as keyword arguments. In addition the keyword argument <code>direction</code> with a
     default value of <code>:forward</code> indicates the direction of the search. Set the value of
     <code>direction</code> to <code>:backward</code> for backward search.
    </para>

    <para>
     The function &gtk-text-buffer-selection-bounds; was introduced earlier, to obtain the iterators around
     the current selection. To set the current selection programmatically the function
     &gtk-text-buffer-select-range; with the arguments <code>buffer</code>, <code>start</code>,
     <code>end</code> can be used. The function sets the selection bounds of <code>buffer</code> to
     <code>start</code> and <code>end</code>.
    </para>

    <figure id="figure-text-view-search">
     <title>Searching text in a text view</title>
     <mediaobject>
      <imageobject>
       <imagedata fileref="figures/text-view-search.png" format="png"></imagedata>
      </imageobject>
     </mediaobject>
    </figure>

    <para>
     The following example which demonstrates searching, uses this function to highlight matched text.
    </para>

    <example id="example-text-view-search">
     <title>Searching text in a text view</title>
    <programlisting xmlns:xi="http://www.w3.org/2001/XInclude">
<xi:include href="src/text-view-search.lisp" parse="text"/>
    </programlisting>
    </example>
   </section>

   <section id="Continuing_the_Search_with_Marks">
    <title>Continuing the Search with Marks</title>
    <para>
     If you had executed the above program you would have noted that, if there were more than one occurrence
     of the text in the text buffer, typing text into the search entry will only highlight the first
     occurrence of the text. To provide a feature similarly to Find Next the program has to remember the
     location where the previous search stopped. So that you can start searching from that location. And this
     should happen even if the text buffer were modified between the two searches. We could store the
     <code>match-end</code> iterator passed on the function &gtk-text-iter-search; and use it as the starting
     point for the next search. But the problem is that if the text buffer were modified in between,
     the iterator would get invalidated. This takes us to marks.
    </para>
    <para>
     A mark preserves a position in the text buffer between modifications. This is possible because their
     behavior is defined when text is inserted or deleted. When text containing a mark is deleted, the mark
     remains in the position originally occupied by the deleted text. When text is inserted at a mark, a
     mark with left gravity will be moved to the beginning of the newly-inserted text, and a mark with right
     gravity will be moved to the end.
    </para>
    <para>
     The gravity of the mark is specified while creation. The function &gtk-text-buffer-create-mark; with the
     arguments <code>buffer</code>, <code>mark-name</code>, <code>where</code> and <code>left-grafity</code>
     can be used to create a mark associated with a text buffer. The iterator <code>where</code> specifies a
     position in the text buffer which has to be marked. The argument <code>left-gravity</code> determines
     how the mark moves when text is inserted at the mark. The argument <code>mark-name</code> is a string
     that can be used to identify the mark. If <code>mark-name</code> is specified, the mark can be retrieved
     using the function &gtk-text-buffer-mark;.
    </para>
    <para>
     With named marks, you do not have to carry around a pointer to the marker, which can be easily retrieved
     using the function &gtk-text-buffer-mark;. A mark by itself cannot be used for text buffer operations,
     it has to converted into an iterator just before text buffer operations are to be performed. The function
     &gtk-text-buffer-iter-at-mark; with the arguments <code>buffer</code> and <code>mark</code> returns the
     iterator at the position of <code>mark</code>.
    </para>
    <para>
     When a mark is no longer required, it can be deleted using the functions &gtk-text-buffer-delete-mark;
     or &gtk-text-buffer-delete-mark-by-name;.
    </para>
   </section>

   <section id="The_Scrolling_Problem">
    <title>The Scrolling Problem</title>
    <para>
     Before we show an example, we have to solve the problem that the text view should scroll to the matched
     text. It can be irritating when the matched text is not in the visible portion of the text buffer. The
     function &gtk-text-view-scroll-mark-onscreen; with the arguments <code>text-view</code> and
     <code>mark</code> scrolls to a position in the text buffer. The argument <code>mark</code> specifies the
     position to scroll to. Note that this is a method of the &gtk-text-view; widget rather than a
     &gtk-text-buffer; object. Since it does not change the contents of the buffer, it only changes the way a
     text buffer is viewed.
    </para>

    <para>
     The function &gtk-text-view-scroll-mark-onscreen; scrolls just enough, for the mark to be visible. But,
     what if you want the mark to be centered, or to be the first line on the screen. This can be done using
     the function &gtk-text-view-scroll-to-mark;, which scrolls the text view so that the mark is on the
     screen in the position indicated by the arguments <code>xalign</code> and <code>yalign</code>.
    </para>

    <para>
     The following example shows the usage of marks to continue the search. 
    </para>

    <example id="example-text-view-find-next">
     <title>Searching text in a text view</title>
     <programlisting xmlns:xi="http://www.w3.org/2001/XInclude">
<xi:include href="src/text-view-find-next.lisp" parse="text"/>
     </programlisting>
    </example>
   </section>
  </section>

  <section id="Examing_and_Modifying_Text" revision="2021-2-19">
   <title>Examing and Modifying Text</title>
   <para>
    Examining and modifying text is another common operation performed on text buffers. Examples are
    converting a selected portion of text into a comment while editing a program, determining and inserting
    the correct end tag while editing HTML, inserting a pair of HTML tags around the current word, etc. The
    &gtk-text-iter; iterator provides functions to do such processing.
   </para>
   <para>
    In this section we will develop a program to demonstrate these functions. The program will insert
    start/end <code>&lt;li&gt;</code> tags around the current line or a selection of text, when the
    Make List Item button is clicked. Furthermore, the program will insert an end tag for an unclosed start
    tag, when the Insert Close Tag is clicked.
   </para>

   <figure id="figure-text-view-insert">
    <title>Inserting text in the Text View</title>
    <mediaobject>
     <imageobject>
      <imagedata fileref="figures/text-view-insert.png" format="png"></imagedata>
     </imageobject>
    </mediaobject>
   </figure>

   <para>
    To insert <code>&lt;li&gt;</code> tags around the current line, we first obtain an iterator at the
    current cursor position. Then we move the iterator to the beginning of the line, insert the start tag,
    move the iterator to the end of the line, and insert the end tag. An iterator can be moved to a specified
    offset in the same line using the accessor function <code>(setf &gtk-text-iter-line-offset;)</code> with
    the argument <code>iter</code> and the value <code>char-on-line</code>. The function moves
    <code>iter</code> within the line, to the character offset specified by <code>char-on-line</code>. If
    <code>char-on-line</code> is equal to the number of characters in the line, the iterator is moved to the
    start of the next line. A character offset of zero, will move the iterator to the beginning of the line.
    The iterator can be moved to the end of the line using the function &gtk-text-iter-forward-to-line-end;.
   </para>

   <para>
    To insert the <code>&lt;li&gt;</code> tags around the current selection, we use the "insert" mark, the
    "selecton_bound" mark, and create an anonymous mark with right-gravity to remember the selection bound
    of the text. First, we insert the tag at the position of the "insert" mark. We get the mark with the
    function &gtk-text-buffer-mark; and the iterator for the position to insert the text with the function
    &gtk-text-buffer-iter-at-mark;. Then we get the mark at the current selection bound, create an anonymus
    mark with the function &gtk-text-mark-new; and add the mark with the function &gtk-text-buffer-add-mark;
    to the text buffer. Now, we get the iterator at this mark for inserting the end tag. After inserting the
    start and end tags we retrieve the iterators for the "insert" mark and the anonymous mark and reselect
    the previous selection. At last, we delete the anonymous mark.
   </para>

   <para>
    Note: We cannot use the "selection_bound" mark to remember the selection of the text. The
    "selection_bound" mark has left-gravity and changes its position after inserting the end tag. Therefore,
    we create an anonymous mark with right-gravity, which does not change its position in the text buffer.
   </para>

   <para>
    For the second part of the program, we will have to first get the iterator at the current cursor position.
    We then search backwards from the cursor position, through the text buffer till we hit on an unclosed tag.
    We then insert the corresponding end tag at the current cursor position. Note that the procedure given
    does not take care of many special cases, and might not be the best way to determine an unclosed tag. We
    can identify tags using the left angle bracket. So searching for start/end tags involves search for the
    left angle bracket. This can be done using the function &gtk-text-iter-backward-find-char; or the function
    &gtk-text-iter-find-char; with a value <code>:backward</code> for the keyword argument
    <code>direction</code>.
   </para>

   <para>
    The function proceeds backwards from <code>iter</code>, and calls <code>predicate</code> for each
    character in the text buffer, with the character as argument, till <code>predicate</code> returns
    <emphasis>true</emphasis>. If a match is found, the function moves <code>iter</code> to the matching
    position and returns <emphasis>true</emphasis>. If a match is not found, the function moves
    <code>iter</code> to the beginning of the text buffer or the position <code>limit</code> (if not
    <code>nil</code>) and returns <code>nil</code>. For our purpose we write a predicate that returns
    <emphasis>true</emphasis> when the character is a left angle bracket. When we hit on a left angle bracket
    we check whether the corresponding tag is a start tag or an end tag. This is done by examining the
    character immediately after the left angle bracket. If it is a '/' it is an end tag. To extract the
    character after the angle bracket we move the left angle bracket iterator by one character. And
    then extract the character at that position. To move an iterator forward by one character, the
    function &gtk-text-iter-forward-char; can be used.
   </para>
   <para>
    To extract the character at an iterator the function &gtk-text-iter-char; can be used. After determining
    the tag type we do the following:
   </para>
   <itemizedlist>
    <listitem>
     If the tag is an end tag, we push the tag name into a stack and then proceed to find more tags.
    </listitem>
    <listitem>
     If it is a start tag, we pop out it's matching tag from the stack. While poping out, if there were no
     more items in the stack, we have hit on an unmatched start tag. We then insert the corresponding end
     tag at the current cursor position.
    </listitem>
   </itemizedlist>
   <para>
    We have not mentioned how we extract the tag name. The tag name is extracted using two iterators (start
    and end iterators). The start iterator is obtained by starting from the left angle bracket iterator and
    searching for an alphanumeric character, in the forward direction. The end iterator is obtained by
    starting from the start iterator and searching for a non-alphanumeric character, in the forward direction.
    The search can be done using the forward variant of the function &gtk-text-iter-backward-find-char;.
   </para>

   <example id="example-text-view-insert">
    <title>Inserting text in the Text View</title>
     <programlisting xmlns:xi="http://www.w3.org/2001/XInclude">
<xi:include href="src/text-view-insert.lisp" parse="text"/>
     </programlisting>
   </example>
  </section>

  <section id="Images_and_Widgets" revision="2021-2-19">
   <title>Images and Widgets in the Text Widget</title>

   <section id="Inserting_and_Retrieving_Images" revision="2021-2-19">
    <title>Inserting and Retrieving Images</title>
    <para>
     A text buffer can hold images and anchor location for widgets. An image can be inserted into a text
     buffer using the function &gtk-text-buffer-insert-pixbuf; with the arguments <code>buffer</code>,
     <code>iter</code>, and <code>pixbuf</code>. An image represented by <code>pixbuf</code> is inserted
     at the position <code>iter</code> in the text buffer. The pixbuf can be created from an image file using
     the function &gdk-pixbuf-new-from-file;.
    </para>

    <para>
     Images in a text buffer are represented by the character <code>0xFFFC</code> (Unicode object replacement
     character). When text containing images is retrieved from a buffer using the function
     &gtk-text-buffer-get-text; the <code>0xFFFC</code> characters representing images are dropped off in the
     returned text. If these characters representing images are required, use the slice variant -
     &gtk-text-buffer-get-slice;. The image at a given position can be retrieved using the function
     &gtk-text-iter-pixbuf;.
    </para>

    <figure id="figure-text-view-insert-image">
     <title>Insert an Image</title>
     <mediaobject>
      <imageobject>
       <imagedata fileref="figures/text-view-insert-image.png" format="png"></imagedata>
      </imageobject>
     </mediaobject>
    </figure>

    <para>
     The example program given loads an image and inserts the image into the text buffer, whenever the user
     clicks on the Insert Image button.
    </para>

    <example id="example-text-view-insert-image">
     <title>Insert an Image</title>
     <programlisting xmlns:xi="http://www.w3.org/2001/XInclude">
<xi:include href="src/text-view-insert-image.lisp" parse="text"/>
     </programlisting>
    </example>
   </section>

   <section id="Inserting_and_Retrieving_Widgets" revision="2021-2-19">
    <title>Inserting and Retrieving Widgets</title>
    <para>
     Unlike inserting an image, inserting a widget is a two step process. The additional complexity is due
     to the functionality split between the &gtk-text-view; class and the &gtk-text-buffer; class. The first
     step is to create and insert a &gtk-text-child-anchor; object. A widget is held in a text buffer using a
     &gtk-text-child-anchor; object. A child anchor is a spot in the text buffer where child widgets can be
     anchored. A child anchor can be created and inserted into a text buffer using the function
     &gtk-text-buffer-create-child-anchor; with the arguments <code>buffer</code> and <code>iter</code>,
     where the argument <code>iter</code> specifies the position in the buffer, where the widget is to be
     inserted. The next step is to add a child widget to the text view, at the anchor location with the
     function &gtk-text-view-add-child-at-anchor;.
    </para>

    <para>
     An anchor can hold only one widget, it could be a container widget, which in turn can contain many
     widgets, unless you are doing tricky things like displaying the same buffer using different
     &gtk-text-view; objects.
    </para>

    <para>
     Child anchors are represented in the text buffer using the object replacement character
     <code>0xFFFC</code>. Retrieving a widget is also a two step process. First, the child anchor has to be
     retrieved. This can be done using the function &gtk-text-iter-child-anchor;. Next, the widget associated
     with the child anchor has to be retrieved. This can be done using the function
     &gtk-text-child-anchor-widgets;. The function returns a list of widgets. As mentioned earlier, if you
     are not doing tricky things like multiple views for the same text buffer, you will find only one widget
     in this list.
    </para>

    <figure id="figure-text-view-insert-widget">
     <title>Insert a Widget</title>
     <mediaobject>
      <imageobject>
       <imagedata fileref="figures/text-view-insert-widget.png" format="png"></imagedata>
      </imageobject>
     </mediaobject>
    </figure>

    <para>
     The following program inserts a button widget into a text buffer, whenever the user clicks on the
     Insert Widget button.
    </para>

    <example id="example-text-view-insert-widget">
     <title>Insert a widget</title>
     <programlisting xmlns:xi="http://www.w3.org/2001/XInclude">
<xi:include href="src/text-view-insert-widget.lisp" parse="text"/>
     </programlisting>
    </example>

   </section>
  </section>

  <section id="Buffer_and_Window_Coordinates" revision="2021-2-19">
   <title>Text Buffer and Window Coordinates</title>

   <section id="About_Buffer_and_Window_Coordinates" revision="2021-2-19">
    <title>About Text Buffer and Window Coordinates</title>
    <para>
     Sometimes it is necessary to know the position of the text cursor on the screen, or the word in a text
     buffer under the mouse cursor. For example, when you want to display a tooltip, when the user types
     text. To do this, you will have to understand text buffer coordinates and window coordinates.
    </para>
    <para>
     Both the text buffer and window coordinates are pixel level coordinates. The difference is that the
     window coordinates takes into account only the portion of the text buffer displayed on the screen. The
     large white box (with grid lines) in the following figure depicts the text buffer. And the smaller
     inner grey box is the visible portion of the text buffer, displayed by the text view widget.
    </para>

    <figure id="figure-buffercoord">
     <title>Text Buffer and Window Coordinates</title>
     <mediaobject>
      <imageobject>
       <imagedata fileref="figures/buffercoord.png" format="png"></imagedata>
      </imageobject>
     </mediaobject>
    </figure>

    <para>
     The text buffer coordinates of the red dot are (4, 3). But the window coordinates of the red dot are
     (2, 1). This is because the window coordinates are calculated relative to the visible portion of the
     text buffer. Similarly, the buffer coordinates of the blue dot are (3, 5) and the window coordinates are
     (1, 3).
    </para>

    <para>
     The text buffer coordinates of a particular character in a text buffer can be obtained using the
     function &gtk-text-view-iter-location;. The function gets the rectangle that contains the character at
     the iterator and returns it. The <code>x</code> and <code>y</code> members of the rectangle gives us
     the buffer coordinates.
    </para>

    <para>
     The buffer coordinates can be converted into window coordinates using the function
     &gtk-text-view-buffer-to-window-coords;. The function converts text buffer coordinates
     <code>(buffer-x, buffer-y)</code> to window coordinates <code>(window-x, window-y)</code>.
    </para>
    <programlisting>
(let* ((rect (gtk-text-view-iter-location textview location))
       (buffer-x (gdk-rectangle-x rect))
       (buffer-y (gdk-rectangle-y rect))
       (win (gtk-text-view-window textview :widget)))
  (multiple-value-bind (window-x window-y)
      (gtk-text-view-buffer-to-window-coords textview
                                             :widget
                                             buffer-x
                                             buffer-y)
    ... )
    </programlisting>
    <para>
     We can find the position in the text buffer corresponding to a particular (window-x, window-y)
     coordinate. The window coordinates can be converted to text buffer coordinates using the function
     &gtk-text-view-window-to-buffer-coords;. The iterator at a text buffer coordinate can be obtained using
     the function &gtk-text-view-iter-at-location;.
    </para>
   </section>

   <section id="Tooltips_under_the_Text_Cursor" revision="2021-2-19">
    <title>Tooltips under the Text Cursor</title>

    <para>
     We use the functions for text buffer and window coordinates to display tooltips under the cursor in the
     text view. The procedure is as follows,
    </para>
    <itemizedlist>
     <listitem>
      Get the text buffer coordinates of the text cursor with the function &gtk-text-view-iter-location;.
     </listitem>
     <listitem>
      The text buffer coordinates (<code>buffer-x</code>, <code>buffer-y</code>) are converted to window
      coordinates (<code>window-x</code>, <code>window-y</code>) with the function
      &gtk-text-view-buffer-to-window-coords;.
     </listitem>
     <listitem>
      The position (<code>screen-x</code>, <code>screen-y</code>) of the text view widget on the screen is
      obtained with the function &gdk-window-origin;.
     </listitem>
     <listitem>
      The window with the tooltip is displayed at the position (<code>window-x + screen-x</code>,
      <code>window-y + screen-y</code>).
     </listitem>
    </itemizedlist>

    <para>
     Now that we know the position of the character within the text view widget, we will have to find the
     position of the text view widget on the screen. Each GTK widget has a corresponding &gdk-window; object
     associated with it. Once we know the window associated with a widget, we can obtain it's
     (<code>screen-x</code>, <code>screen-y</code>) coordinates using the function &gdk-window-origin;. The
     &gdk-window; object for the text view widget can be obtained using the function &gtk-text-view-window;.
     Here you will have to pass in the value <code>:widget</code> of the &gtk-text-window-type; enumeration
     for the argument <code>win-type</code>.
    </para>

    <para>
     We now know the functions required to display a tooltip under the text cursor. Before we proceed to the
     example, you will have to know which signal has to be trapped to do display the tooltip. Since we want
     the tooltip to be displayed when the user inserts text, the "insert-text" signal emitted by the text
     buffer object can be used. As the signal's name suggests it is called whenever the user inserts text
     into the buffer. The callback prototype of the signal handler is
     <programlisting>
lambda (buffer location text len)
     </programlisting>
     The callback function is called with the position after the inserted text in the <code>location</code>
     iterator, a UTF-8 string with the inserted text in <code>text</code> and an integer with the length of
     the inserted text <code>len</code>.
    </para>

    <figure id="figure-text-view-tooltip">
     <title>Multiline Text Editing</title>
     <mediaobject>
      <imageobject>
       <imagedata fileref="figures/text-view-tooltip.png" format="png"></imagedata>
      </imageobject>
     </mediaobject>
    </figure>

    <para>
     Below is an example program that displays a tooltip when the inserted text matches a Lisp function
     in a list of functions.
    </para>

    <example id="example-text-view-tooltip">
     <title>Show tooltips in a Text View</title>
      <programlisting xmlns:xi="http://www.w3.org/2001/XInclude">
<xi:include href="src/text-view-tooltip.lisp" parse="text"/>
      </programlisting>
    </example>
   </section>
  </section>
 </chapter>

 <chapter id="Tree_and_List_Widgets" revision="2021-3-4">
  <title>Tree and List Widgets</title>

  <section id="Tree_and_List_Widget_Overview" revision="2021-3-4">
   <title>Tree and List Widget Overview</title>
   <para>
    To create a tree or list in GTK, use the &gtk-tree-model; interface in conjunction with the
    &gtk-tree-view; widget. This widget is designed around a Model/View/Controller design and consists of
    four major parts:
   </para>
   <itemizedlist>
    <listitem>
     The tree view widget implemented as the &gtk-tree-view; class.
    </listitem>
    <listitem>
     The view column implemented as the &gtk-tree-view-column; class.
    </listitem>
    <listitem>
     The cell renderers etc. implemented as the &gtk-cell-renderer; class.
    </listitem>
    <listitem>
     The model interface implemented as the &gtk-tree-model; interface.
    </listitem>
   </itemizedlist>
   <para>
    The View is composed of the first three objects, while the last is the Model. One of the prime benefits
    of the MVC design is that multiple views can be created of a single model. For example, a model mapping
    the file system could be created for a file manager. Many views could be created to display various
    parts of the file system, but only one copy need be kept in memory.
   </para>
   <para>
    The purpose of the cell renderers is to provide extensibility to the widget and to allow multiple ways
    of rendering the same type of data. For example, consider how to render a boolean variable. Should it
    render as a string of "True" or "False", "On" or "Off", or should it be rendered as a checkbox?
   </para>

   <bridgehead renderas="sect2">Creating a model</bridgehead>
   <para>
    GTK provides two simple models that can be used: the &gtk-list-store; object and the &gtk-tree-store;
    object. The &gtk-list-store; object is used to model list widgets, while the &gtk-tree-store; object is
    used to model trees. It is possible to develop a new type of model, but the existing models should be
    satisfactory for all but the most specialized of situations. Creating the model is quite simple:
   </para>
   <programlisting>
(let ((model (make-instance 'gtk-list-store
                            :column-types '("gchararray" "gboolean"))))
  ... )
   </programlisting>
   <para>
    or with the function &gtk-list-store-new;
   </para>
   <programlisting>
(let ((model (gtk-list-store-new "gchararray" "gboolean")))
  ... )
   </programlisting>
   <para>
    This creates a list store with two columns: a string column and a boolean column. The next example
    creates a tree store with 3 columns with the function &gtk-tree-store-new;:
   </para>
   <programlisting>
(defun create-and-fill-tree-store ()
  (let ((model (gtk-tree-store-new "gchararray" "gchararray" "guint")))
    ... ))
   </programlisting>
   <para>
    Adding data to the model is done using the functions &gtk-list-store-set; or &gtk-tree-store-set;,
    depending upon which sort of model was created. To do this, a &gtk-tree-iter; iterator must be acquired.
    The iterator points to the location where data will be added.
   </para>
   <para>
    Once an iterator has been acquired, the function &gtk-tree-store-set; is used to apply data to the part
    of the model that the iterator points to. Consider the following example:
   </para>
   <programlisting>
(let ((iter (gtk-tree-store-append model nil))) ; Top-level iterator
  ;; Set the top-level row
  (gtk-tree-store-set model
                      iter
                      "The Art of Computer Programming"
                      "Donald E. Knuth"
                      2011)
... )
   </programlisting>
   <para>
    It can be used to set the data in all columns in a given row.
   </para>
   <para>
    The second argument to the function &gtk-tree-store-append; is the parent iterator. It is used to add a
    row to a &gtk-tree-store; object as a child of an existing row. This means that the new row will only
    be visible when its parent is visible and in its expanded state. Consider the following example:
   </para>
   <programlisting>
(let ((iter (gtk-tree-store-append model nil))) ; Top-level iterator
  ;; Set the top-level row
  (gtk-tree-store-set model
                      iter
                      "The Art of Computer Programming"
                      "Donald E. Knuth"
                      2011)
  ;; Append and set three child rows
  (gtk-tree-store-set model
                      (gtk-tree-store-append model iter) ; Child iterator
                      "Volume 1: Fundamental Algorithms"
                      ""
                      1997)
  ... )
   </programlisting>

   <bridgehead renderas="sect2">Creating the view component</bridgehead>
   <para>
    While there are several different models to choose from, there is only one view widget to deal with.
    It works with either the list or the tree store. Setting up a &gtk-tree-view; widget is not a difficult
    matter. It needs a &gtk-tree-model; object to know where to retrieve its data from. The following
    example uses the function &gtk-tree-view-new-with-model;:
   </para>
   <programlisting>
(defun create-view-and-tree-store ()
  (let* ((model (create-and-fill-tree-store))
         (view (gtk-tree-view-new-with-model model)))
  ... ))
   </programlisting>

   <bridgehead renderas="sect3">Columns and cell renderers</bridgehead>
   <para>
    Once the &gtk-tree-view; widget has a model, it will need to know how to display the model. It does
    this with columns and cell renderers.
   </para>
   <para>
    Cell renderers are used to draw the data in the tree model in a way. There are a number of cell
    renderers that come with GTK, including the &gtk-cell-renderer-text;, &gtk-cell-renderer-pixbuf;
    and the &gtk-cell-renderer-toggle; objects. It is relatively easy to write a custom renderer.
   </para>
   <para>
    A &gtk-tree-view-column; object is the object that the &gtk-tree-view; widget uses to organize the
    vertical columns in the tree view. It needs to know the name of the column to label for the user, what
    type of cell renderer to use, and which piece of data to retrieve from the model for a given row.
   </para>
   <programlisting>
...
;; Create renderer for Title column
(let* ((renderer (gtk-cell-renderer-text-new))
       (column (gtk-tree-view-column-new-with-attributes "Title"
                                                         renderer
                                                         "text"
                                                         col-title)))
  (gtk-tree-view-append-column view column))
...
   </programlisting>
   <para>
    At this point, all the steps in creating a displayable tree have been covered. The model is created,
    data is stored in it, a tree view is created and columns are added to it.
   </para>

   <bridgehead renderas="sect3">Selection handling</bridgehead>
   <para>
    Most applications will need to not only deal with displaying data, but also receiving input events from
    users. To do this, simply get a reference to a selection object, connect to the "changed" signal and
    then to retrieve data for the row selected:
   </para>
   <programlisting>
(let* ((...
       (view (create-view-and-tree-store))
       ;; Get the selection of the view
       (select (gtk-tree-view-selection view)))
  ...
  ;; Setup the selection handler
  (setf (gtk-tree-selection-mode select) :single)
  (g-signal-connect select "changed"
     (lambda (selection)
       (let* ((view (gtk-tree-selection-tree-view selection))
              (model (gtk-tree-view-model view))
              (iter (gtk-tree-selection-selected selection))
              (title (gtk-tree-model-value model iter col-title)))
         (format t "Selected title is ~a~%" title))))
  ... ))
   </programlisting>

   <bridgehead renderas="sect2">Simple Tree View</bridgehead>
   <figure id="figure-tree-view-simple">
    <title>Simple Tree View</title>
    <mediaobject>
     <imageobject>
      <imagedata fileref="figures/tree-view-simple.png" format="png"></imagedata>
     </imageobject>
    </mediaobject>
   </figure>
    <para>
     Here is an example of using a &gtk-tree-view; widget in context of the other widgets. It creates a model
     and view, and puts them together. The window is show in <xref linkend="figure-tree-view-simple"/>.
    </para>
    <example id="example-simple-tree-view">
     <title>Simple Tree View</title>
      <programlisting xmlns:xi="http://www.w3.org/2001/XInclude">
<xi:include href="src/tree-view-simple.lisp" parse="text"/>
      </programlisting>
    </example>
  </section>

  <section id="GtkListStore_and_GtkTreeStore" revision="2021-3-2">
   <title>GtkListStore and GtkTreeStore</title>

   <section id="Introduction_GtkListStore_and_GtkTreeStore" revision="2021-3-2">
   <title>Introduction to GtkListStore and GtkTreeStore</title>

    <para>
     It is important to realise what the &gtk-tree-model; interface is and what it is not. The
     &gtk-tree-model; interface is basically just an 'interface' to the data store, meaning that it is a
     standardised set of functions that allows a &gtk-tree-view; widget (and the application programmer) to
     query certain characteristics of a data store, for example how many rows there are, which rows have
     children, and how many children a particular row has. It also provides functions to retrieve data from
     the data store, and tell the tree view what type of data is stored in the model. Every data store must
     implement the &gtk-tree-model; interface and provide these functions. The &gtk-tree-model; interface
     itself only provides a way to query a data store's characteristics and to retrieve existing data, it
     does not provide a way to remove or add rows to the store or put data into the store. This is done using
     the specific store's functions.
    </para>
    <para>
     GTK comes with two built-in data stores (models): the &gtk-list-store; object and the &gtk-tree-store;
     object. As the names imply, the &gtk-list-store; object is used for simple lists of data items where
     items have no hierarchical parent-child relationships, and the &gtk-tree-store; object is used for
     tree-like data structures, where items can have parent-child relationships. A list of files in a
     directory would be an example of a simple list structure, whereas a directory tree is an example for a
     tree structure. A list is basically just a special case of a tree with none of the items having any
     children, so one could use a tree store to maintain a simple list of items as well. The only reason
     the &gtk-list-store; object exists is in order to provide an easier interface that does not need to
     cater for child-parent relationships, and because a simple list model can be optimised for the special
     case where no children exist, which makes it faster and more efficient.
    </para>
    <para>
     The &gtk-list-store; and &gtk-tree-store; objects should cater for most types of data an application
     developer might want to display in a &gtk-tree-view; widget. However, it should be noted that the
     &gtk-list-store; and &gtk-tree-store; objects have been designed with flexibility in mind. If you plan
     to store a lot of data, or have a large number of rows, you should consider implementing your own custom
     model that stores and manipulates data your own way and implements the &gtk-tree-model; interface. This
     will not only be more efficient, but probably also lead to saner code in the long run, and give you more
     control over your data.
    </para>
    <para>
     Tree model implementations like the &gtk-list-store; and &gtk-tree-store; objects will take care of the
     view side for you once you have configured the &gtk-tree-view; widget to display what you want. If you
     change data in the store, the model will notify the tree view and your data display will be updated. If
     you add or remove rows, the model will also notify the store, and your row will appear in or disappear
     from the view as well.
    </para>
   </section>

   <section id="How_Data_is_Organised_in_a_Store" revision="2021-3-2">
    <title>How Data is Organised in a Store</title>
    <para>
     A model (data store) has model columns and rows. While a tree view will display each row in the model
     as a row in the view, the model's columns are not to be confused with a view's columns. A model column
     represents a certain data field of an item that has a fixed data type. You need to know what kind of
     data you want to store when you create a list store or a tree store, as you can not add new fields later
     on.
    </para>
    <para>
     For example, we might want to display a list of files. We would create a list store with two fields: a
     field that stores the filename (i.e. a string) and a field that stores the file size (i.e. an unsigned
     integer). The filename would be stored in column 0 of the model, and the file size would be stored in
     column 1 of the model. For each file we would add a row to the list store, and set the row's fields to
     the filename and the file size.
    </para>
    <para>
     The GLib type system (GType) is used to indicate what type of data is stored in a model column. These
     are the most commonly used types:
    </para>
    <itemizedlist>
     <listitem><code>"gboolean"</code></listitem>
     <listitem><code>"gint"</code>, <code>"guint"</code></listitem>
     <listitem>
      <code>"glong"</code>, <code>"gulong"</code>, <code>"gint64"</code>, <code>"guint64"</code>
     </listitem>
     <listitem><code>"gfloat"</code>, <code>"gdouble"</code></listitem>
     <listitem><code>"gchararray"</code></listitem>
     <listitem><code>"gpointer"</code></listitem>
     <listitem><code>"GdkPixbuf"</code></listitem>
    </itemizedlist>
    <para>
     You do not need to understand the type system, it will usually suffice to know the above types, so you
     can tell a list store or tree store what kind of data you want to store. Storing GObject-derived types
     is a special case that is dealt with further below.
    </para>
    <para>
     Here is an example of how to create a list store with the funcion &gtk-list-store-new;:
    </para>
    <programlisting>
(let ((model (gtk-list-store-new "gchararray" "gchararray" "guint")))
  ... )
    </programlisting>
    <para>
     This creates a new list store with three columns. Column 0 and 1 store a string and column 3 stores an
     unsigned integer for each row. At this point the model has no rows yet of course. Before we start to add
     rows, let's have a look at the different ways used to refer to a particular row.
    </para>
   </section>

   <section id="Refering_to_Rows" revision="2021-3-4">
    <title>Refering to Rows</title>

    <section id="GtkTreePath" revision="2021-3-4">
     <title>GtkTreePath</title>
     <para>
      There are different ways to refer to a specific row. The two you will have to deal with are a
      &gtk-tree-iter; iterator and a &gtk-tree-path; instance.
     </para>
     <para>
      A &gtk-tree-path; instance is a comparatively straight-forward way to describe the logical position of
      a row in the model. As a &gtk-tree-view; widget always displays all rows in a model, a tree path always
      describes the same row in both model and view.
     </para>

     <figure id="figure-tree-view-path">
      <title>Tree Path</title>
      <mediaobject>
       <imageobject>
        <imagedata fileref="figures/tree-view-path.png" format="png"></imagedata>
       </imageobject>
      </mediaobject>
     </figure>

     <para>
      <xref linkend="figure-tree-view-path"/> shows the tree path in string form. Basically, it just counts
      the children from the imaginary root of the tree view. An empty tree path string would specify that
      imaginary invisible root. Now 'Songs' is the first child (from the root) and thus its tree path is just
      "0". 'Videos' is the second child from the root, and its tree path is "1". 'Oggs' is the second child
      of the first item from the root, so its tree path is "0:1". So you just count your way down from the
      root to the row in question, and you get your tree path.
     </para>
     <para>
      The implication of this way of refering to rows is as follows: if you insert or delete rows in the
      middle or if the rows are resorted, a tree path might suddenly refer to a completely different row than
      it refered to before the insertion/deletion/resorting. This is important to keep in mind. See the
      section on <link linkend="GtkTreeRowReference">GtkTreeRowReference</link> below for a tree path that
      keeps updating itself to make sure it always refers to the same row when the model changes.
     </para>
     <para>
      You can get a new &gtk-tree-path; instance from a path in string form using the function
      &gtk-tree-path-new-from-string;, and you can convert a given &gtk-tree-path; instance into its string
      notation with the function &gtk-tree-path-to-string;. Usually you will rarely have to handle the string
      notation, it is described here merely to demonstrate the concept of tree paths.
     </para>
     <para>
      Instead of the string notation, the &gtk-tree-path; structure uses an integer array internally. You can
      get the depth, i.e. the nesting level, of a tree path with the function &gtk-tree-path-depth;. A depth
      of 0 is the imaginary invisible root node of the tree view and model. A depth of 1 means that the tree
      path describes a top-level row. As lists are just trees without child nodes, all rows in a list always
      have tree paths of depth 1. The function &gtk-tree-path-indices; returns the internal integer array of
      a tree path. You will rarely need to operate with those either.
     </para>
     <para>
      If you operate with tree paths, you are most likely to use a given tree path, and use functions like
      &gtk-tree-path-up;, &gtk-tree-path-down;, &gtk-tree-path-next;, &gtk-tree-path-prev;,
      &gtk-tree-path-is-ancestor;, or &gtk-tree-path-is-descendant;. Note that this way you can construct and
      operate on tree paths that refer to rows that do not exist in model or view. The only way to check
      whether a path is valid for a specific model, i.e. the row described by the path exists, is to convert
      the path into an iterator using the function &gtk-tree-model-iter;.
     </para>
     <para>
      The &gtk-tree-path; structure is an opaque structure. If you need to make a copy of a tree path, use
      the function &gtk-tree-path-copy;.
     </para>
    </section>

    <section id="GtkTreeIter" revision="2021-3-4">
     <title>GtkTreeIter</title>
     <para>
      Another way to refer to a row in a list or tree is a &gtk-tree-iter; iterator. A tree iterator is just
      a structure that contains a couple of pointers that mean something to the model you are using. Tree
      iterators are used internally by models, and they often contain a direct pointer to the internal data
      of the row in question. You should never look at the content of a tree iterator and you must not modify
      it directly either. All tree models, and therefore also &gtk-list-store; and &gtk-tree-store; objects,
      must support the &gtk-tree-model; functions that operate on tree iterators. Some of these functions are
      shown in <xref linkend="table-gtk-tree-model"/>.
     </para>

     <table id="table-gtk-tree-model">
      <caption>Functions for GtkTreeModel</caption>
      <colgroup>
       <col style="width:35%"/>
       <col style="width:65%"/>
      </colgroup>
      <tr>
       <th align="left">Function</th>
       <th align="left">Description</th>
      </tr>
      <tr>
       <td colspan="2" style="border-top:2px solid #ff9900;"></td>
      </tr>
      <tr valign="top">
       <td><code>gtk-tree-model-iter-first</code></td>
       <td>Returns the iterator to the the first top-level item in the list or tree.</td>
      </tr>
      <tr valign="top">
       <td><code>gtk-tree-model-iter-next</code></td>
       <td>Returns the iterator to the next item at the current level in a list or tree.</td>
      </tr>
      <tr valign="top">
       <td><code>gtk-tree-model-iter-previous</code></td>
       <td>Returns the iterator to the previous item at the current level in a list or tree.</td>
      </tr>
      <tr valign="top">
       <td><code>gtk-tree-model-iter-children</code></td>
       <td>
        Returns the iterator to the first child of the row referenced by the given iterator.
        Not very useful for lists, mostly useful for trees.
       </td>
      </tr>
      <tr valign="top">
       <td><code>gtk-tree-model-iter-n-children</code></td>
       <td>
        Returns the number of children the row referenced by the provided iterator has. If you pass
        <code>nil</code> instead of an iterator, this function will return the number of top-level
        rows. You can use this function to count the number of items in a list store.
       </td>
      </tr>
      <tr valign="top">
       <td><code>gtk-tree-model-iter-nth-child</code></td>
       <td>
        Returns the iterator to the n-th child of the row referenced by the given iterator. If you pass
        <code>nil</code> instead of an iterator, you can get the iterator set to the n-th row of a list.
       </td>
      </tr>
      <tr valign="top">
       <td><code>gtk-tree-model-iter-parent</code></td>
       <td>
        Returns the iterator to the parent of the row referenced by the given iterator. Does nothing for
        lists, only useful for trees.
       </td>
      </tr>
      <tr>
       <td colspan="2" style="border-top:1px solid #ff9900;"></td>
      </tr>
     </table>

     <para>
      Almost all of those functions return the iterator if the requested operation succeeded, and return
      <code>nil</code> otherwise. There are more functions that operate on iterators. Check out the
      &gtk-tree-model; API reference for details.
     </para>
     <para>
      Tree iterators are used to retrieve data from the store, and to put data into the store. You also get a
      tree iterator as result if you add a new row to the store using the functions &gtk-list-store-append;
      or &gtk-tree-store-append;.
     </para>
     <para>
      Tree iterators are often only valid for a short time, and might become invalid if the store changes
      with some models. It is therefore usually a bad idea to store tree iterators, unless you really know
      what you are doing. You can use the function &gtk-tree-model-flags; to get a model's flags, and check
      whether the <code>:iters-persist</code> flag is set, in which case a tree iterator will be valid as
      long as a row exists, yet still it is not advisable to store iterator instances unless you really mean
      to do that. There is a better way to keep track of a row over time with a &gtk-tree-row-reference;
      instance.
     </para>
    </section>

    <section id="GtkTreeRowReference" revision="2021-3-4">
     <title>GtkTreeRowReference</title>
     <para>
      A &gtk-tree-row-reference; structure is basically a structure that takes a tree path, and watches a
      model for changes. If anything changes, like rows getting inserted or removed, or rows getting
      re-ordered, the tree row reference object will keep the given tree path up to date, so that it always
      points to the same row as before. In case the given row is removed, the tree row reference will become
      invalid.
     </para>
     <para>
      A new tree row reference can be created with the function &gtk-tree-row-reference-new;, given a model
      and a tree path. After that, the tree row reference will keep updating the path whenever the model
      changes. The current tree path of the row originally refered to when the tree row reference was created
      can be retrieved with the function &gtk-tree-row-reference-path;. If the row has been deleted,
      <code>nil</code> will be returned instead of of a tree path.
     </para>
     <para>
      You can check whether the row referenced still exists with the function &gtk-tree-row-reference-valid;.
     </para>
     <para>
      For the curious: internally, the tree row reference connects to the tree model's "row-inserted",
      "row-deleted", and "rows-reordered" signals and updates its internal tree path whenever something
      happened to the model that affects the position of the referenced row.
     </para>
     <para>
      Note that using tree row references entails a small overhead. This is hardly significant, but when you
      have multiple thousands of rows and/or row references, this might be something to keep in mind, because
      whenever rows are inserted, removed, or reordered, a signal will be sent out and processed for each row
      reference.
     </para>
     <para>
      If you have read the tutorial only up to here so far, it is hard to explain really what tree row
      references are good for. An example where tree row references come in handy can be found further below
      in the section on removing multiple rows in one go.
     </para>
     <para>
      In practice, a programmer can either use tree row references to keep track of rows over time, or store
      tree iterators directly, if, and only if, the model has persistent iterators. Both &gtk-list-store;
      and &gtk-tree-store; objects have persistent iterators, so storing iterators is possible. However,
      using tree row references is definitively the right way to do things, even though it comes with some
      overhead that might impact performance in case of trees that have a very large number of rows
     </para>
    </section>

    <section id="Usage" revision="2021-3-4">
     <title>Usage</title>
     <para>
      Tree iterators can easily be converted into tree paths using the function &gtk-tree-model-path;, and
      tree paths can easily be converted into tree iterators using the function &gtk-tree-model-iter;.
      Here is an example that shows how to get the iterator from the tree path that is passed to us from the
      tree view in the "row-activated" signal callback. We need the iterator here to retrieve data from the
      store.
     </para>

     <example id="example-row-activated">
      <title>Converting a gtk-tree-path into a gtk-tree-iter</title>
      <programlisting>
;; Print the name when double click a row
(g-signal-connect view "row-activated"
    (lambda (view path column)
      (declare (ignore column))
      (let* ((model (gtk-tree-view-model view))
             ;; Lookup iter from path
             (iter (gtk-tree-model-iter model path)))
        (when iter
          (format t "Double click on name ~a~%"
                    (gtk-tree-model-value model iter col-lastname))))))
      </programlisting>
     </example>

     <para>
      Tree row references reveal the current path of a row with the function &gtk-tree-row-reference-path;.
      There is no direct way to get a tree iterator from a tree row reference, you have to retrieve the tree
      row reference's path first and then convert that into a tree iterator.
     </para>
     <para>
      The following example asks the model to return the iterator to the first row in the list store. If
      there is a first row and the list store is not empty, the iterator will be returned by the function
      &gtk-tree-model-iter-first;. If there is no first row, it will just return <code>nil</code>. If a first
      row exists, the do loop will be entered and we change some of the first row's data. Then we ask the
      model to return the iterator to the next row, until there are no more rows, which is when the function
      &gtk-tree-model-iter-next; returns <code>nil</code>. Instead of traversing the list store we could also
      have used the function &gtk-tree-model-foreach;.
     </para>

     <example id="example-traverse-list">
      <title>Going through every row in a list store</title>
      <programlisting>
(do* ((model (gtk-tree-view-model view))
      (iter (gtk-tree-model-iter-first model)
            (gtk-tree-model-iter-next model iter)))
     ((not iter))
     (let ((value (gtk-tree-model-value model iter col-yearborn)))
           (gtk-list-store-set-value model
                                     iter
                                     col-yearborn
                                     (1+ value))))
      </programlisting>
     </example>
    </section>
   </section>

   <section id="Adding_Rows_to_a_Store" revision="2021-3-2">
    <title>Adding Rows to a Store</title>

    <section id="Adding Rows to a List Store" revision="2021-3-2">
     <title>Adding Rows to a List Store</title>
     <para>
      Rows are added to a list store with the function &gtk-list-store-append;. This will insert a new empty
      row at the end of the list. There are other functions, documented in the &gtk-list-store; API reference,
      that give you more control about where exactly the new row is inserted, but as they work very similar
      to the function &gtk-list-store-append; and are fairly straight-forward to use, we will not deal with
      them here. Here is a simple example of how to create a list store and add an empty row to it.
     </para>
     <programlisting>
(let* ((model (gtk-list-store-new "gchararray"))
       ;; Append an empty row to the list store
       (iter (gtk-list-store-append model)))
  ... )
     </programlisting>
     <para>
      This in itself is not very useful yet of course. We will add data to the rows in the next section.
     </para>
    </section>    

    <section id="Adding Rows to a Tree Store" revision="2021-3-2">
     <title>Adding Rows to a Tree Store</title>
     <para>
      Adding rows to a tree store works similar to adding rows to a list store, only that the function
      &gtk-tree-store-append; is the function to use and one more argument is required, namely the tree
      iterator to the parent of the row to insert. If you supply <code>nil</code> instead of providing the
      tree iterator of another row, a new top-level row will be inserted. If you do provide a parent tree
      iterator, the new empty row will be inserted after any already existing children of the parent. Again,
      there are other ways to insert a row into the tree store and they are documented in the &gtk-tree-store;
      API reference manual. Another short example
     </para>
     <programlisting>
(let* ((model (gtk-tree-store-new "gchararray"))
       ;; Append an empty top-level row to the tree store.
       ;; Iter will point to the new row.
       (iter (gtk-tree-store-append model nil))
       (child nil))
  ;; Append another empty top-level row to the tree store.
  (setf iter (gtk-tree-store-append model nil))
  ;; Append a child to the row we just added.
  (setf child (gtk-tree-store-append model iter))
  ;; Get the first row, and add a child to it as well, could have been done
  ;; right away earlier of course, this is just for demonstration purposes
  (setf iter (gtk-tree-model-iter-first model))
  (setf child (gtk-tree-store-append model iter))
  ... )
     </programlisting>
    </section>

    <section id="Speed_Issues_when_Adding_a_Lot_of_Rows" revision="2021-3-2">
     <title>Speed Issues when Adding a Lot of Rows</title>
     <para>
      A common scenario is that a model needs to be filled with a lot of rows at some point, either at
      start-up, or when some file is opened. An equally common scenario is that this takes an awfully long
      time even on powerful machines once the model contains more than a couple of thousand rows, with an
      exponentially decreasing rate of insertion. As already pointed out above, writing a custom model might
      be the best thing to do in this case. Nevertheless, there are some things you can do to work around
      this problem and speed things up a bit even with the stock GTK models:
     </para>
     <para>
      Firstly, you should detach your list store or tree store from the tree view before doing your mass
      insertions, then do your insertions, and only connect your store to the tree view again when you are
      done with your insertions. Like this:
     </para>
     <programlisting>
(let ((model (gtk-tree-view-model view)))
  ;; Detach model from view
  (setf (gtk-tree-view-model view) nil)

  ... insert a couple of thousand rows ...

  ;; Re-attach model to view
  (setf (gtk-tree-view-model view) model)
  ... )
     </programlisting>
     <para>
      Secondly, you should make sure that sorting is disabled while you are doing your mass insertions,
      otherwise your store might be resorted after each and every single row insertion, which is going to be
      everything but fast. Thirdly, you should not keep around a lot of tree row references if you have so
      many rows, because with each insertion (or removal) every single tree row reference will check whether
      its path needs to be updated or not.
     </para>
    </section>
   </section>

   <section id="Manipulating Row Data" revision="2021-3-4">
    <title>Manipulating Row Data</title>
    <para>
     Adding empty rows to a data store is not terribly exciting, so let's see how we can add or change data
     in the store. The functions &gtk-list-store-set; and &gtk-tree-store-set; are used to manipulate a given
     row's data. There are also the functions &gtk-list-store-set-value; and &gtk-tree-store-set-value; to
     set single values in a row.
    </para>
    <para>
     Both functions &gtk-list-store-set; and &gtk-tree-store-set; take a variable number of arguments. The
     first two arguments are the model, and the iterator to the row whose data we want to change. They are
     followed by a variable number of data arguments. The data should be of the same data type as the model
     column. Here is an example where we create a store that stores a string and one integer for the row:
    </para>

    <programlisting>
(let ((model (gtk-list-store-new "gchararray" "gchararray" "guint")))
  ;; Append a row and fill in some data
  (gtk-list-store-set model
                      (gtk-list-store-append model)
                      "Hans" "Müller" 1961)
  ... )
    </programlisting>
   </section>

   <section id="Retrieving Row Data" revision="2021-3-5">
    <title>Retrieving Row Data</title>
    <para>
     Storing data is not very useful if it cannot be retrieved again. This is done using the function
     &gtk-tree-model-get;, which takes similar arguments as the functions &gtk-list-store-set; or
     &gtk-tree-store-set; do, only that it takes column arguments.
    </para>
    <para>
     Here is an example to traverse the list store and print out the data stored. As an extra, we use the
     function &gtk-tree-model-foreach; to traverse the store and retrieve the row number from the
     &gtk-tree-path; instance passed to us in the foreach callback function:
    </para>

      <programlisting xmlns:xi="http://www.w3.org/2001/XInclude">
<xi:include href="src/tree-view-dump-model.lisp" parse="text"/>
      </programlisting>

    <para>
     Note that when a new row is created, all fields of a row are set to a default value appropriate for the
     data type in question. A field of type "gint" will automatically contain the value 0 until it is set to
     a different value, and strings and all kind of pointer types will be <code>NULL</code> until set to
     something else. Those are valid contents for the model, and if you are not sure that row contents have
     been set to something, you need to be prepared to handle <code>NULL</code> pointers and the like in your
     code. Run the above program with an additional empty row and look at the output to see this in effect.
    </para>
   </section>

   <section id="Removing Rows" revision="2021-3-5">
    <title>Removing Rows</title>
    <para>
     Rows can easily be removed with the functions &gtk-list-store-remove; and &gtk-tree-store-remove;.
     The removed row will automatically be removed from the tree view as well.
    </para>
    <para>
     Removing a single row is fairly straight forward: you need to get the iterator that identifies the row
     you want to remove, and then use one of the above functions. Here is a simple example that removes a row
     when you double-click on it (bad from a user interface point of view, but then it is just an example):
    </para>

    <programlisting>
;; Signal handler for the signal "row-activated"
(g-signal-connect view "row-activated"
  (lambda (view path column)
    (declare (ignore column))
    (let* ((model (gtk-tree-view-model view))
           (iter (gtk-tree-model-iter model path)))
      (when iter
        (gtk-list-store-remove model iter)))))
    </programlisting>

    <para>
     If you want to remove the n-th row from a list (or the n-th child of a tree node), you have two
     approaches: either you first create a &gtk-tree-path; instance that describes that row and then turn it
     into an iterator and remove it, or you take the iterator of the parent node and use the function
     &gtk-tree-model-iter-nth-child; (which will also work for list stores if you use <code>nil</code> as the
     parent iterator. Of course you could also start with the iterator of the first top-level row, and then
     step-by-step move it to the row you want, although that seems a rather awkward way of doing it. The
     following code snippet will remove the n-th row of a list if it exists:
    </para>
    <programlisting>
;; Removes the nth row of a list store if it exists.
(defun list-store-remove-nth-row (store n)
  (let (;; nil means the parent is the virtual root node, so the
        ;; n-th top-level element is returned in iter, which is
        ;; the n-th row in a list store as a list store only has
        ;; top-level elements, and no children
        (iter (gtk-tree-model-nth-child store nil n)))
    (when iter
      (gtk-list-store-remove store iter))))
    </programlisting>

    <para>
     Removing multiple rows at once can be a bit tricky at times, and requires some thought on how to do this
     best. For example, it is not possible to traverse a store with the function &gtk-tree-model-foreach;,
     check in the callback function whether the given row should be removed and then just remove it by calling
     one of the stores' remove functions. This will not work, because the model is changed from within the
     foreach loop, which might suddenly invalidate formerly valid tree iterators in the foreach function, and
     thus lead to unpredictable results.
    </para>
    <para>
     Here is an example for an alternative approach to removing multiple rows in one go. Here we want to
     remove all rows from the store that contain persons that are older than 30, but it could just as well be
     all selected rows or some other criterion:
    </para>
    <programlisting>
(let ((rowref-list nil))
  (defun foreach-func (model path iter)
    (let ((age (gtk-tree-model-value model iter col-age)))
      (when (> age 30)
        (let ((rowref (gtk-tree-row-reference-new model path)))
          (setf rowref-list (cons rowref rowref-list))))
      nil))

  (defun remove-people-older-than (model)
    (setf rowref-list nil)
    (gtk-tree-model-foreach model #'foreach-func)
    (dolist (rowref rowref-list)
      (let ((path (gtk-tree-row-reference-path rowref)))
      (when path
        (let ((iter (gtk-tree-model-iter model path)))
          (when iter
            (gtk-list-store-remove model iter))))))))
    </programlisting>
    <para>
     The functions &gtk-list-store-clear; and &gtk-tree-store-clear; come in handy if you want
     to remove all rows.
    </para>
   </section>
  </section>

  <section id="Creating_a_Tree_View" revision="2021-3-5">
   <title>Creating a Tree View</title>

   <section id="Connecting_Tree_View_and_Model" revision="2021-3-5">
    <title>Connecting Tree View and Model</title>
    <para>
     In order to display data in a tree view widget, we need to create one first, and we need to instruct it
     where to get the data to display from. A new tree view is created with:
    </para>
    <programlisting>
(let ((view (gtk-tree-view-new)))
  ... )
    </programlisting>
    <para>
     Before we proceed to the next section where we display data on the screen, we need connect our data
     store to the tree view, so it knows where to get the data to display from. This is achieved with the
     function <code>(setf &gtk-tree-view-model;)</code>, which will by itself do very little. However, it is
     a prerequisite for what we do in the following sections. The function &gtk-tree-view-new-with-model; is
     a convenience function for the previous two.
    </para>
    <para>
     The function &gtk-tree-view-model; will return the model that is currently attached to a given tree view,
     which is particularly useful in callbacks where you only get passed the tree view widget.
    </para>
   </section>

   <section id="Tree_View_Look_and_Feel" revision="2021-3-5">
    <title>Tree View Look and Feel</title>
    <para>
     There are a couple of ways to influence the look and feel of the tree view. You can hide or show
     column headers with the function &gtk-tree-view-headers-visible;, and set them clickable or not with the
     function &gtk-tree-view-headers-clickable; (which will be done automatically for you if you enable
     sorting).
    </para>
    <!-- TODO: The function gtk-tree-view-rules-hint is deprecated. Rework this. -->
    <para>
     The function &gtk-tree-view-rules-hint; will enable or disable rules in the tree view. 'Rules' means
     that every second line of the tree view has a shaded background, which makes it easier to see which cell
     belongs to which row in tree views that have a lot of columns. As the function name implies, this setting
     is only a hint; in the end it depends on the active GTK theme engine if the tree view shows ruled lines
     or not. Users seem to have strong feelings about rules in tree views, so it is probably a good idea to
     provide an option somewhere to disable rule hinting if you set it on tree views (but then, people also
     seem to have strong feelings about options abundance and 'sensible' default options, so whatever you do
     will probably upset someone at some point).
    </para>
    <para>
     The expander column can be set with the function &gtk-tree-view-expander-column;. This is the column
     where child elements are indented with respect to their parents, and where rows with children have an
     'expander' arrow with which a node's children can be collapsed (hidden) or expanded (shown). By default,
     this is the first column.
    </para>
   </section>
  </section>

  <section id="Mapping_Data_to_the_Screen" revision="2021-3-5">
   <title>Mapping Data to the Screen</title>

   <section id="Indrotuction_to_Mapping_Data" revision="2021-3-5">
    <title>Introduction to Mapping Data</title>
    <para>
     As outlined above, tree view columns represent the visible columns on the screen that have a column
     header with a column name and can be resized or sorted. A tree view is made up of tree view columns,
     and you need at least one tree view column in order to display something in the tree view. Tree view
     columns, however, do not display anything by themselves, this is done by specialised &gtk-cell-renderer;
     objects. Cell renderers are packed into tree view columns much like widgets are packed into a &gtk-box;
     widget.
    </para>
    <para>
     Here is a diagram (courtesy of Owen Taylor) that pictures the relationship between tree view columns and
     cell renderers:
    </para>

    <figure id="figure-tree-view-column">
     <title>GtkTreeViewColumn</title>
     <mediaobject>
      <imageobject>
       <imagedata fileref="figures/tree-view-column.png" format="png"></imagedata>
      </imageobject>
     </mediaobject>
    </figure>

    <para>
     In the above diagram, both 'Country' and 'Representative' are tree view columns, where the 'Country' and
     'Representative' labels are the column headers. The 'Country' column contains two cell renderers, one to
     display the flag icons, and one to display the country name. The 'Representative' column only contains
     one cell renderer to display the representative's name.
    </para>
   </section>

   <section id="Cell_Renderers" revision="2021-3-9">
    <title>Cell Renderers</title>
    <para>
     Cell renderers are objects that are responsible for the actual rendering of data within a
     &gtk-tree-view-column;. They are basically just GObjects (i.e. not widgets) that have certain properties,
     and those properties determine how a single cell is drawn.
    </para>
    <para>
     In order to draw cells in different rows with different content, a cell renderer's properties need to be
     set accordingly for each single row/cell to render. This is done either via attributes or cell data
     functions. If you set up attributes, you tell GTK which model column contains the data from which a
     property should be set before rendering a certain row. Then the properties of a cell renderer are set
     automatically according to the data in the model before each row is rendered. Alternatively, you can set
     up cell data functions, which are called for each row to be rendererd, so that you can manually set the
     properties of the cell renderer before it is rendered. Both approaches can be used at the same time as
     well. Lastly, you can set a cell renderer property when you create the cell renderer. That way it will
     be used for all rows/cells to be rendered (unless it is changed later of course).
    </para>
    <para>
     Different cell renderers exist for different purposes:
    </para>

    <table id="table-gtk-cell-renderer">
     <caption>GtkCellRenderer</caption>
     <colgroup>
      <col style="width:30%"/>
      <col style="width:70%"/>
     </colgroup>
     <tr>
      <th align="left">Class</th>
      <th align="left">Description</th>
     </tr>
     <tr>
      <td colspan="2" style="border-top:2px solid #ff9900;"></td>
     </tr>
     <tr valign="top">
      <td><code>gtk-cell-renderer-text</code></td>
      <td>
       Renders strings or numbers or boolean values as text ("Joe", "99.32", "true"). Sets the given
       iterator to the first top-level item in the list or tree.
      </td>
     </tr>
     <tr valign="top">
      <td><code>gtk-cell-renderer-pixbuf</code></td>
      <td>
        Is used to display images, either user-defined images, or one of the stock icons that come with GTK.
      </td>
     </tr>
     <tr valign="top">
      <td><code>gtk-cell-renderer-toggle</code></td>
      <td>
        Displays a boolean value in form of a check box or as a radio button.
      </td>
     </tr>
     <tr valign="top">
      <td><code>gtk-cell-renderer-editable</code></td>
      <td>
        Is a special cell that implements editable cells (i.e. the &gtk-entry; or &gtk-spin-button; widgets
        in a tree view). This is not a cell renderer. If you want to have editable text cells, use
        the &gtk-cell-renderer-text; object and make sure the &gtk_cell_renderer_text_editable; property is
        set. The &gtk-cell-editable; widget is only used by implementations of editable cells and widgets
        that can be inside of editable cells. You are unlikely to ever need it.
      </td>
     </tr>
     <tr>
      <td colspan="2" style="border-top:1px solid #ff9900;"></td>
     </tr>
    </table>

    <para>
     Contrary to what one may think, a cell renderer does not render just one single cell, but is responsible
     for rendering part or whole of a tree view column for each single row. It basically starts in the first
     row and renders its part of the column there. Then it proceeds to the next row and renders its part of
     the column there again. And so on.
    </para>
    <para>
     How does a cell renderer know what to render? A cell renderer object has certain 'properties' that are
     documented in the API reference (just like most other objects, and widgets). These properties determine
     what the cell renderer is going to render and how it is going to be rendered. Whenever the cell renderer 
     is called upon to render a certain cell, it looks at its properties and renders the cell accordingly.
     This means that whenever you set a property or change a property of the cell renderer, this will affect
     all rows that are rendered after the change, until you change the property again.
    </para>
    <para>
     Here is a diagram (courtesy of Owen Taylor) that tries to show what is going on when rows are rendered:
    </para>

    <figure id="figure-cell-renderer-properties">
     <title>Cell Renderer Properties</title>
     <mediaobject>
      <imageobject>
       <imagedata fileref="figures/diagram-cell-renderer-properties.png" format="png"></imagedata>
      </imageobject>
     </mediaobject>
    </figure>

    <para>
     The above diagram shows the process when attributes are used. In the example, a text cell renderer's
     &gtk_cell_renderer_text_text; property has been linked to the first model column. The
     &gtk_cell_renderer_text_text; property contains the string to be rendered. The
     &gtk_cell_renderer_text_foreground; property, which contains the colour of the text to be shown, has
     been linked to the second model column. Finally, the &gtk_cell_renderer_text_strikethrough; property,
     which determines whether the text should be with a horizontal line that strikes through the text, has
     been connected to the third model column (of type "gboolean").
    </para>
    <para>
     With this setup, the cell renderer's properties are 'loaded' from the model before each cell is rendered.
    </para>
    <para>
     Here is little example that demonstrates this behaviour, and introduces some of the most commonly used
     properties of the &gtk-cell-renderer-text; object:
    </para>

    <programlisting xmlns:xi="http://www.w3.org/2001/XInclude">
<xi:include href="src/cell-renderer-properties.lisp" parse="text"/>
    </programlisting>

    <para>
     The above code should produce something looking like this:
    </para>

    <figure id="figure-renderer-properties">
     <title>Persistent Cell Renderer Properties</title>
     <mediaobject>
      <imageobject>
       <imagedata fileref="figures/cell-renderer-properties.png" format="png"></imagedata>
      </imageobject>
     </mediaobject>
    </figure>

    <para>
     It looks like the tree view display is partly correct and partly incomplete. On the one hand the tree
     view renders the correct number of rows, and it displays the hierarchy correctly (on the left), but it
     does not display any of the data that we have stored in the model. This is because we have made no
     connection between what the cell renderers should render and the data in the model. We have simply set
     some cell renderer properties on start-up, and the cell renderers adhere to those set properties
     meticulously.
    </para>
    <para>
     There are two different ways to connect cell renderers to data in the model: attributes and cell data
     functions.
    </para>
   </section>

   <section id="Attributes" revision="2021-3-9">
    <title>Attributes</title>
    <para>
     An attribute is a connection between a cell renderer property and a field/column in the model. Whenever
     a cell is to be rendered, a cell renderer property will be set to the values of the specified model
     column of the row that is to be rendered. It is very important that the column's data type is the same
     type that a property takes according to the API reference manual. Here is some code to look at:
    </para>
    <programlisting>
(let* ((renderer (gtk-cell-renderer-text-new))
       (column (gtk-tree-view-column-new-with-attributes "Example"
                                                         renderer
                                                         "text" 0)))
  (gtk-tree-view-append-column view column)
  ... )
    </programlisting>
    <para>
     This means that the text cell renderer property "text" will be set to the string in model column 0 of
     each row to be drawn.
    </para>
    <para>
     Again, when setting attributes it is very important that the data type stored in a model column is the
     same as the data type that a property requires as argument. Check the API reference manual to see the
     data type that is required for each property. When reading through the example a bit further above, you
     might have noticed that we set the &gtk_cell_renderer_cell-background; property of a
     &gtk-cell-renderer-text; object, even though the API documentation does not list such a property. We can
     do this, because the &gtk-cell-renderer-text; object is derived from the &gtk-cell-renderer; object,
     which does in fact have such a property. Derived classes inherit the properties of their parents. This
     is the same as with widgets that you can cast into one of their ancestor classes. The API reference has
     an object hierarchy that shows you which classes a widget or some other object is derived from.
    </para>
    <para>
     There are two more noteworthy things about &gtk-cell-renderer; properties: one is that sometimes there
     are different properties which do the same, but take different arguments, such as the
     &gtk_cell_renderer_text_foreground; and &gtk_cell_renderer_text_foreground-rgba; properties of the
     &gtk-cell-renderer-text; object (which specify the text colour). The &gtk_cell_renderer_text_foreground;
     property take a colour in string form, such as "Orange" or "CornflowerBlue", whereas
     &gtk_cell_renderer_text_foreground-rgba; property takes a &gdk-rgba; color argument. It is up to you to
     decide which one to use - the effect will be the same. The other thing worth mentioning is that most
     properties have a <code>"foo-set"</code> property taking a boolean value as argument, such as
     &gtk_cell_renderer_text_foreground-set;. This is useful when you want to have a certain setting
     have an effect or not. If you set the &gtk_cell_renderer_text_foreground; property, but set
     &gtk_cell_renderer_text_foreground-set; to <emphasis>false</emphasis>, then your foreground color
     setting will be disregarded. This is useful in cell data functions, or, for example, if you want set the
     foreground colour to a certain value at start-up, but only want this to be in effect in some columns, but
     not in others, in which case you could just connect the &gtk_cell_renderer_text_foreground-set; property
     to a model column of type "gboolean" with the function &gtk-tree-view-column-add-attribute;.
    </para>
    <para>
     Setting column attributes is the most straight-forward way to get your model data to be displayed. This
     is usually used whenever you want the data in the model to be displayed exactly as it is in the model.
    </para>
    <para>
     Another way to get your model data displayed on the screen is to set up cell data functions.
    </para>
   </section>

   <section id="Cell_Data_Functions" revision="2021-3-9">
    <title>Cell Data Functions</title>
    <para>
     A cell data function is a function that is called for a specific cell renderer for each single row
     before that row is rendered. It gives you maximum control over what exactly is going to be rendered, as
     you can set the cell renderer's properties just like you want to have them. Remember not only to set a
     property if you want it to be active, but also to unset a property if it should not be active, and it
     might have been set in the previous row.
    </para>
    <para>
     Cell data functions are often used if you want more fine-grained control over what is to be displayed,
     or if the standard way to display something is not quite like you want it to be. A case in point are
     floating point numbers. If you want floating point numbers to be displayed in a certain way, say with
     only one digit after the colon/comma, then you need to use a cell data function. Use the function
     &gtk-tree-view-column-set-cell-data-func; to set up a cell data function for a particular cell renderer.
     Here is an example:
    </para>

    <programlisting>
(defun age-cell-data (column renderer model iter)
  (declare (ignore column))
  (let ((year (sixth (multiple-value-list (get-decoded-time))))
        (text nil)
        (value (gtk-tree-model-value model iter col-yearborn)))
    (if (and (&lt; value year) (> value 0))
        (progn
          (setf text (format nil "~a  years old" (- year value)))
          (setf (gtk-cell-renderer-text-foreground-set renderer) nil))
        (progn
          (setf text "age unknown")
          (setf (gtk-cell-renderer-text-foreground renderer) "Red")
          (setf (gtk-cell-renderer-text-foreground-set renderer) t)))
    (setf (gtk-cell-renderer-text-text renderer) text)))

...
;; Create renderer for third column
(let* ((renderer (gtk-cell-renderer-text-new))
       (column (gtk-tree-view-column-new-with-attributes "Age"
                                                         renderer
                                                         "text"
                                                         col-yearborn)))
  ;; Set a Cell Data Function on the column
  (gtk-tree-view-column-set-cell-data-func column renderer #'age-cell-data)
  (gtk-tree-view-append-column view column))
...
    </programlisting>

    <para>
     For each row to be rendered by this particular cell renderer, the cell data function is going to be
     called, which then retrieves the year born from the model, and turns it into an age. When the age is not
     a positive value the text "age unknown" in the color red is rendered with the text cell renderer.
    </para>
    <para>
     This is only a simple example, you can make cell data functions a lot more complicated if you want to.
     As always, there is a trade-off to keep in mind though. Your cell data function is going to be called
     every single time a cell in that (renderer) column is going to be rendered. Go and check how often this
     function is called in your program if you ever use one. If you do time-consuming operations within a
     cell data function, things are not going to be fast, especially if you have a lot of rows. The
     alternative in this case would have been to make an additional column <code>col-age</code> of type
     "gchararray, and to set the age in string form and the text "age unknown" whenever you set the year born
     itself in a row, and then hook up the string column to a text cell renderer using attributes. This way
     the age conversion would only need to be done once. This is a CPU cycles / memory trade-off, and it
     depends on your particular case which one is more suitable. Things you should probably not do is to
     convert long strings into UTF8 format in a cell data function, for example.
    </para>
    <para>
     You might notice that your cell data function is called at times even for rows that are not visible at
     the moment. This is because the tree view needs to know its total height, and in order to calculate
     this it needs to know the height of each and every single row, and it can only know that by having it
     measured, which is going to be slow when you have a lot of rows with different heights. If your rows all
     have the same height, there should not be any visible delay though.
    </para>

    <section id="GtkCellRendererText_and_Integer_Boolean_and_Float_Types" revision="2021-3-9">
     <title>GtkCellRendererText and Integer, Boolean and Float Types</title>
     <para>
      It has been said before that, when using attributes to connect data from the model to a cell renderer
      property, the data in the model column specified in the function &gtk-tree-view-column-add-attribute;
      must always be of the same type as the data type that the property requires.
     </para>
     <para>
      This is usually true, but there is an exception: if you use the function
      &gtk-tree-view-column-add-attribute; to connect a text cell renderer's &gtk_cell_renderer_text_text;
      property to a model column, the model column does not need to be of "gchararray", it can also be one of
      most other fundamental GLib types, e.g. "gboolean", "gint", "guint", "glong", "gulong", "gint64",
      "guint64", "gfloat", or "gdouble". The text cell renderer will automatically display the values of
      these types correctly in the tree view. For example:
     </para>

     <programlisting>
(let ((store (gtk-list-store-new "gchararray" "guint"))
      (renderer (gtk-cell-renderer-text-new))
      (column (gtk-tree-view-column-new)))
  (gtk-tree-view-column-add-attribute column renderer "text" 1)
  ... )
     </programlisting>

     <para>
      Even though the &gtk_cell_renderer_text_text; property would require a string value, we use a model
      column of an integer type when setting attributes. The integer will then automatically be converted
      into a string before the cell renderer property is set.
     </para>
     <para>
      If you are using a floating point type, i.e. "gfloat" or "gdouble", there is no way to tell the text
      cell renderer how many digits after the floating point (or comma) should be rendered. If you only want
      a certain amount of digits after the point/comma, you will need to use a cell data function.
     </para>
    </section>
   </section>

   <section id="GtkCellRendererText, UTF8, and Pango markup" revision="2021-3-9">
    <title>GtkCellRendererText, UTF8, and Pango markup</title>
    <para>
     All text used in GTK widgets needs to be in UTF8 encoding, and the &gtk-cell-renderer-text; object is
     no exception. Text in plain ASCII is automatically valid UTF8, but as soon as you have special characters
     that do not exist in plain ASCII (usually characters that are not used in the English language alphabet),
     they need to be in UTF8 encoding. There are many different character encodings that all specify different
     ways to tell the computer which character is meant. GTK uses UTF8, and whenever you have text that is in
     a different encoding, you need to convert it to UTF8 encoding first. If you only use text input from
     other GTK widgets, you are on the safe side, as they will return all text in UTF8 as well.
    </para>
    <para>
     In addition to the &gtk_cell_renderer_text_text; property, the &gtk-cell-renderer-text; object also has
     a &gtk_cell_renderer_text_markup; property that takes text with Pango markup as input. Pango markup
     allows you to place special tags into a text string that affect the style the text is rendered (see the
     Pango documentation). Basically you can achieve everything you can achieve with the other properties also
     with Pango markup (only that using properties is more efficient and less messy). Pango markup has one
     distinct advantage though that you cannot achieve with text cell renderer properties: with Pango markup,
     you can change the text style in the middle of the text, so you could, for example, render one part of a
     text string in bold print, and the rest of the text in normal. Here is an example of a string with Pango
     markup:
    </para>

    <programlisting>
"You can have text in <code>&#x3c;b>bold&#x3c;/b></code> or in a
<code>&#x3c;span color='Orange'>different color&#x3c;/span></code>"
    </programlisting>

    <para>
     It is possible to combine both Pango markup and text cell renderer properties. Both will be 'added'
     together to render the string in question, only that the text cell renderer properties will be applied
     to the whole string. If you set the &gtk_cell_renderer_text_markup; property to normal text without any
     Pango markup, it will render as normal text just as if you had used the &gtk_cell_renderer_text_text;
     property. However, as opposed to the &gtk_cell_renderer_text_text; property, special characters in the
     &gtk_cell_renderer_text_markup; property text would still need to be escaped, even if you do not use
     Pango markup in the text.
    </para>
   </section>

   <section id="A_Working_Example" revision="2021-3-5">
    <title>A Working Example</title>
    <para>
     Here is an example that shows the features mentioned so far in the tutorial. Both attributes and a cell
     data function are used for demonstration purposes.
    </para>

      <programlisting xmlns:xi="http://www.w3.org/2001/XInclude">
<xi:include href="src/tree-view-example.lisp" parse="text"/>
      </programlisting>
   </section>

   <section id="How_to_Make_a_Whole_Row_Bold_or_Coloured" revision="2021-3-5">
    <title>How to Make a Whole Row Bold or Coloured</title>
    <para>
     This seems to be a frequently asked question, so it is worth mentioning it here. You have the two
     approaches mentioned above: either you use cell data functions, and check in each whether a particular
     row should be highlighted in a particular way (bold, coloured, whatever), and then set the renderer
     properties accordingly (and unset them if you want that row to look normal), or you use attributes.
     Cell data functions are most likely not the right choice in this case though.
    </para>
    <!-- TODO: The property rules-hint is deprecated, the theme is responsible  -->
    <para>
     If you only want every second line to have a gray background to make it easier for the user to see which
     data belongs to which line in wide tree views, then you do not have to bother with the stuff mentioned
     here. Instead just set the rules hint on the tree view as described in
     <xref linkend="Tree_View_Look_and_Feel"/>, and everything will be done automatically, in colours that
     conform to the chosen theme even (unless the theme disables rule hints, that is).
    </para>
    <para>
     Otherwise, the most suitable approach for most cases is that you add two columns to your model, one for
     the property itself (e.g. a column <code>col-row-color</code> of type "gchararray", and one for the
     boolean flag of the property (e.g. a column <code>col-row-color-set</code> of type "gboolean"). You
     would then connect these columns with the &gtk_cell_renderer_text_foreground; and
     &gtk_cell_renderer_text_foreground-set; properties of each renderer. Now, whenever you set a row's
     <code>col-row-color</code> field to a colour, and set that row's <code>col-row-color-set</code> field to
     <emphasis>true</emphasis>, then this column will be rendered in the colour of your choice. If you only
     want either the default text colour or one special other colour, you could even achieve the same thing
     with just one extra model column: in this case you could just set all renderer's
     &gtk_cell_renderer_text_foreground; property to whatever special color you want, and only connect the
     <code>col-row-color-set</code> column to all renderer's &gtk_cell_renderer_text_foreground-set; property
     using attributes. This works similar with any other attribute, only that you need to adjust the data
     type for the property of course (e.g. the &gtk_cell_renderer_text_weight; property would take a "gint",
     in form of a &pango-weight; value in this case).
    </para>
    <para>
     As a general rule, you should not change the text colour or the background colour of a cell unless you
     have a really good reason for it.
    </para>
   </section>

   <section id="How_to_Pack_Icons_into_the_Tree_View" revision="2021-3-5">
    <title>How to Pack Icons into the Tree View</title>
    <para>
     So far we have only put text in the tree view. While everything you need to know to display icons in
     the form of &gdk-pixbuf; objects has been introduced in the previous sections, a short example might
     help to make things clearer. The following code will pack an icon and the icon name into the same tree
     view column:
    </para>

    <programlisting xmlns:xi="http://www.w3.org/2001/XInclude">
<xi:include href="src/tree-view-content-type.lisp" parse="text"/>
    </programlisting>

    <para>
     Note that the tree view will not resize icons for you, but displays them in their original size. In this
     example the icons are loaded from an icon theme to obtain the &gdk-pixbuf; object for the icon. We could
     have set the &gtk_cell_renderer_pixbuf_icon-name; property of the &gtk-cell-renderer-pixbuf; class to
     display the themed icon without loading it into a pixbuf. For this case the model column should be of
     type "gchararray", as all themed icons are just strings by which to identify the themend icon.
    </para>
   </section>

   <section id="GtkIconView" revision="2021-3-9">
    <title>GtkIconView</title>
    <para>
     The &gtk-icon-view; widget provides an alternative view on a &gtk-tree-model; object. It displays the
     model as a grid of icons with labels. Like the &gtk-tree-view; widget, it allows to select one or
     multiple items, depending on the selection mode, see the function &gtk-icon-view-selection-mode;. In
     addition to selection with the arrow keys, the &gtk-icon-view; widget supports rubberband selection,
     which is controlled by dragging the pointer.
    </para>

    <figure id="figure-icon-view-example">
     <title>Example Icon View</title>
     <mediaobject>
      <imageobject>
       <imagedata fileref="figures/icon-view-example.png" format="png"></imagedata>
      </imageobject>
     </mediaobject>
    </figure>

    <para>
      The following example shows the icons for the registed content types on the system. The description of
      the content types is shown in a tooltip of the icons.
    </para>

    <programlisting xmlns:xi="http://www.w3.org/2001/XInclude">
<xi:include href="src/icon-view-example.lisp" parse="text"/>
    </programlisting>

   </section>
  </section>

  <section id="Selections_Double-Clicks_and_Context_Menus" revision="2021-3-5">
   <title>Selections, Double-Clicks and Context Menus</title>

   <section id="Handling_Selections" revision="2021-3-5">
    <title>Handling Selections</title>
    <para>
     One of the most basic features of a list or tree view is that rows can be selected or unselected.
     Selections are handled using the &gtk-tree-selection; object of a tree view. Every tree view
     automatically has a &gtk-tree-selection; object associated with it, and you can get it using the funcion
     &gtk-tree-view-selection;. Selections are handled completely on the tree view side, which means that the
     model knows nothing about which rows are selected or not. There is no particular reason why selection
     handling could not have been implemented with functions that access the tree view widget directly, but
     for reasons of API cleanliness and code clarity the GTK developers decided to create this special
     &gtk-tree-selection; object that then internally deals with the tree view widget. You will never need to
     create a tree selection object, it will be created for you automatically when you create a new tree view.
     You only need to use the function &gtk-tree-view-selection; to get the selection object.
    </para>
    <para>
     There are three ways to deal with tree view selections: either you get a list of the currently selected
     rows whenever you need it, for example within a context menu function, or you keep track of all select
     and unselect actions and keep a list of the currently selected rows around for whenever you need them;
     as a last resort, you can also traverse your list or tree and check each single row for whether it is
     selected or not (which you need to do if you want all rows that are not selected for example).
    </para>

    <section id="Selection_Modes" revision="2021-2-25">
     <title>Selection Modes</title>
     <para>
      You can use the function &gtk-tree-selection-mode; to influence the way that selections are handled.
      There are four selection modes available in the &gtk-selection-mode; enumeration:
      <variablelist>
       <varlistentry>
        <term><code>:none</code></term>
        <listitem>no items can be selected</listitem>
       </varlistentry>
       <varlistentry>
        <term><code>:single</code></term>
        <listitem>no more than one item can be selected</listitem>
       </varlistentry>
       <varlistentry>
        <term><code>:browse</code></term>
        <listitem>exactly one item is always selected</listitem>
       </varlistentry>
       <varlistentry>
        <term><code>:multiple</code></term>
        <listitem>anything between no item and all items can be selected</listitem>
       </varlistentry>
      </variablelist>
     </para>
    </section>

    <section id="Getting_the_Currently_Selected_Rows" revision="2021-2-25">
     <title>Getting the Currently Selected Rows</title>

     <para>
      You can access the currently selected rows either by traversing all selected rows using the function
      &gtk-tree-selection-selected-foreach; or get a list of tree paths of the selected rows using the
      function &gtk-tree-selection-selected-rows;.
     </para>
     <para>
      If the selection mode you are using is either <code>:single</code> or <code>:browse</code>, the most
      convenient way to get the selected row is the function &gtk-tree-selection-selected;, which will return
      the specified tree iterator with the selected row (if a row is selected), and return
      <emphasis>false</emphasis> otherwise. It is used like this:
     </para>
     <programlisting>
...
(let* ((model (gtk-tree-view-model view))
       (selection (gtk-tree-view-selection view))
       ;; This will only work in single or browse selection mode
       (iter (gtk-tree-selection-selected selection model)))
  (if iter
      (format t "selected row is: ~a" (gtk-tree-model-value model iter col-name))
      (format t "no row selected"))
  ... )
     </programlisting>
     <para>
      One thing you need to be aware of is that you need to take care when removing rows from the model in a
      &gtk-tree-selection-selected-foreach; callback, or when looping through the list that the function
      &gtk-tree-selection-selected-rows; returns (because it contains paths, and when you remove rows in the
      middle, then the old paths will point to either a non-existing row, or to another row than the one
      selected). You have two ways around this problem: one way is to use the solution to removing multiple
      rows that has been described above, i.e. to get tree row references for all selected rows and then
      remove the rows one by one; the other solution is to sort the list of selected tree paths so that the
      last rows come first in the list, so that you remove rows from the end of the list or tree. You cannot
      remove rows from within a foreach callback in any case, that is simply not allowed.
     </para>
     <para>
      Here is an example of how to use the function &gtk-tree-selection-selected-foreach;:
     </para>
     <programlisting>
(defun view-selected-foreach-func (model path iter)
  (declare (ignore path))
  (let ((value (gtk-tree-model-value model iter col-name)))
    (format t "~a is selected." value))

(defun do-something-with-all-selected-rows (view)
  (let ((selection (gtk-tree-view-selection view)))
    (gtk-tree-selection-selected-foreach selection #'view-selected-foreach-func)))

(defun create-view ()
  (let ((view (gtk-tree-view-new))
        (selection (gtk-tree-view-selection view)))
    ...
    (setf (gtk-tree-selection-mode selection) :multiple)
    ... ))
     </programlisting>
    </section>

    <section id="Using_Selection_Functions" revision="2021-2-28">
     <title>Using Selection Functions</title>
     <para>
      You can set up a custom selection function with the function &gtk-tree-selection-set-select-function;.
      This function will then be called every time a row is going to be selected or unselected (meaning: it
      will be called before the selection status of that row is changed). Selection functions are commonly
      used for the following things:
     </para>
     <para>
      ... to keep track of the currently selected items (then you maintain a list of selected items yourself).
      In this case, note again that your selection function is called before the row's selection status is
      changed. In other words: if the row is going to be selected, then the boolean <code>selected</code>
      variable that is passed to the selection function is still <emphasis>false</emphasis>. Also note that
      the selection function might not always be called when a row is removed, so you either have to unselect
      a row before you remove it to make sure your selection function is called and removes the row from your
      list, or check the validity of a row when you process the selection list you keep. You should not store
      tree paths in your self-maintained list of of selected rows, because whenever rows are added or removed
      or the model is resorted the paths might point to other rows. Use tree row references or other unique
      means of identifying a row instead.
     </para>
     <para>
      ... to tell GTK whether it is allowed to select or unselect that specific row (you should make sure
      though that it is otherwise obvious to a user whether a row can be selected or not, otherwise the user
      will be confused if she just cannot select or unselect a row). This is done by returning
      <emphasis>true</emphasis> or <emphasis>false</emphasis> in the selection function.
     </para>
     <para>
      ... to take additional action whenever a row is selected or unselected.
     </para>
     <para>
      Yet another simple example:
     </para>
     <programlisting>
(defun view-selection-func (selection model path selected)
  (let ((iter (gtk-tree-model-iter model path)))
    (when iter
      (let ((name (gtk-tree-model-value model iter col-name)))
        (if (not selected)
            (format t "~a is going to be selected" name)
            (format t "~a is going to be unselected" name))))
    t  ; allow selection state to change)

(defun create-view ()
  (let* ((view (gtk-tree-view-new))
         (selection (gtk-tree-view-selection view)))
    ...
    (gtk-tree-selection-set-select-function selection #'view-selection-func)
    ... ))
      </programlisting>
    </section>

    <section id="Checking_Whether_a_Row_is_Selected" revision="2021-2-28">
     <title>Checking Whether a Row is Selected</title>
     <para>
      You can check whether a given row is selected or not using the functions the functions
      &gtk-tree-selection-iter-is-selected;. or &gtk-tree-selection-path-is-selected;. If you want to know all
      rows that are not selected, for example, you could just traverse the whole list or tree, and use the
      above functions to check for each row whether it is selected or not.
     </para>
    </section>

    <section id="Selecting and Unselecting Rows" revision="2021-2-28">
     <title>Selecting and Unselecting Rows</title>
     <para>
      You can select or unselect rows manually with the functions &gtk-tree-selection-select-iter;,
      &gtk-tree-selection-select-path;, &gtk-tree-selection-unselect-iter;,
      &gtk-tree-selection-unselect-path;, &gtk-tree-selection-select-all;, and
      &gtk-tree-selection-unselect-all; should you ever need to do that.
     </para>
    </section>

    <section id="Getting the Number of Selected Rows" revision="2021-2-28">
     <title>Getting the Number of Selected Rows</title>
     <para>
      Sometimes you want to know the number of rows that are currently selected (for example to set context
      menu entries active or inactive before you pop up a context menu). If you are using selection mode
      <code>:single</code> or <code>:browse</code>, this is trivial to check with the function
      &gtk-tree-selection-selected;, which will return either <emphasis>true</emphasis> or
      <emphasis>false</emphasis> (meaning one selected row or no selected row).
     </para>
     <para>
      If you are using <code>:multiple</code> or want a more general approach that works for all selection
      modes, the function &gtk-tree-selection-count-selected-rows; will return the information you are
      looking for.
     </para>
    </section>
   </section>

   <section id="Double-Clicks on a Row" revision="2021-2-28">
    <title>Double-Clicks on a Row</title>
    <para>
     Catching double-clicks on a row is quite easy and is done by connecting to a tree view's "row-activated"
     signal, like this:
    </para>
    <programlisting>
(defun view-on-row-activated (view path col)
  (let* ((model (gtk-tree-view-model view))
         (iter (gtk-tree-model-iter model path)))
    (when iter
      (let ((value (gtk-tree-model-value model iter col-name)))
        (format t "Double-clicked row on name ~a" value)))))

(defun create-view ()

  (let ((view (gtk-tree-view-new)))
    ...
    (g-signal-connect view "row-activated" #'view-on-row-activaded)
    ... ))
    </programlisting>
   </section>

   <section id="Context Menus on Right Click" revision="2021-2-28">
    <title>Context Menus on Right Click</title>
    <para>
     Context menus are context-dependent menus that pop up when a user right-clicks on a list or tree and
     usually let the user do something with the selected items or manipulate the list or tree in other ways.
    </para>
    <para>
     Right-clicks on a tree view are caught just like mouse button clicks are caught with any other widgets,
     namely by connecting to the tree view's "button-press-event" signal handler (which is a &gtk-widget;
     signal, and as the &gtk-tree-view; class is derived from the &gtk-widget; class it has this signal as
     well). Additionally, you should also connect to the "popup-menu" signal, so users can access your context
     menu without a mouse. The "popup-menu" signal is emitted when the user presses Shift-F10. Also, you
     should make sure that all functions provided in your context menu can also be accessed by other means
     such as the application's main menu. See the GNOME Human Interface Guidelines (HIG) for more details.
     Straight from the a-snippet-of-code-says-more-than-a-thousand-words-department, some code to look at:
    </para>
    <programlisting xmlns:xi="http://www.w3.org/2001/XInclude">
<xi:include href="src/tree-view-context-menu.lisp" parse="text"/>
    </programlisting>
   </section>
  </section>

  <section id="Sorting" revision="2021-3-9">
   <title>Sorting</title>

   <section id="Indroduction_to_Sorting" revision="2021-3-9">
    <title>Introduction to Sorting</title>
    <para>
     Lists and trees are meant to be sorted. This is done using the &gtk-tree-sortable; interface that can be
     implemented by tree models. Both the &gtk-list-store; and &gtk-tree-store; class implement the tree
     sortable interface.
    </para>
    <para>
     The most straight forward way to sort a list store or tree store is to directly use the tree sortable
     interface on them. This will sort the store in place, meaning that rows will actually be reordered in the
     store if required. This has the advantage that the position of a row in the tree view will always be the
     same as the position of a row in the model, in other words: a tree path refering to a row in the view
     will always refer to the same row in the model, so you can get a row's iterator easily with the function
     &gtk-tree-model-iter; using a tree path supplied by the tree view. This is not only convenient, but also
     sufficient for most scenarios.
    </para>
    <para>
     However, there are cases when sorting a model in place is not desirable, for example when several tree
     views display the same model with different sortings, or when the unsorted state of the model has some
     special meaning and needs to be restored at some point. This is where the &gtk-tree-model-sort; object
     comes in, which is a special model that maps the unsorted rows of a child model (e.g. a list store or
     tree store) into a sorted state without changing the child model.
    </para>
   </section>

   <section id="GtkTreeSortable" revision="2021-3-9">
    <title>GtkTreeSortable</title>
    <para>
     The tree sortable interface is fairly simple and should be easy to use. Basically you define a 'sort
     column ID' integer for every criterion you might want to sort by and tell the tree sortable which
     function should be called to compare two rows (represented by two tree iterators) for every sort ID with
     the function &gtk-tree-sortable-set-sort-func;. Then you sort the model by setting the sort column ID and
     sort order with the function &gtk-tree-sortable-sort-column-id;, and the model will be re-sorted using
     the compare function you have set up. Your sort column IDs can correspond to your model columns, but
     they do not have to (you might want to sort according to a criterion that is not directly represented
     by the data in one single model column, for example). Some code to illustrate this:
    </para>

    <programlisting xmlns:xi="http://www.w3.org/2001/XInclude">
<xi:include href="src/tree-view-sortable.lisp" parse="text"/>
    </programlisting>

    <para>
     Usually things are a bit easier if you make use of the tree view column headers for sorting, in which
     case you only need to assign sort column IDs and your compare functions, but do not need to set the
     current sort column ID or order yourself (see below).
    </para>
    <para>
     Your tree iterator compare function should return a negative value if the row specified by iterator
     <code>iter1</code> comes before the row specified by iterator <code>iter2</code>, and a positive value
     if row <code>iter2</code> comes before row <code>iter1</code>. It should return 0 if both rows are equal
     according to your sorting criterion (you might want to use a second sort criterion though to avoid
     'jumping' of equal rows when the store gets resorted). Your tree iterator compare function should not
     take the sort order into account, but assume an ascending sort order (otherwise bad things will happen).
    </para>
   </section>

   <section id="GtkTreeModelSort" revsion="2021-2-28">
    <title>GtkTreeModelSort</title>
    <para>
     The &gtk-tree-model-sort; class is a wrapper tree model. It takes another tree model such as a list
     store or a tree store as child model, and presents the child model to the 'outside' (i.e. a tree view or
     whoever else is accessing it via the tree model interface) in a sorted state. It does that without
     changing the order of the rows in the child model. This is useful if you want to display the same model
     in different tree views with different sorting criteria for each tree view, for example, or if you need
     to restore the original unsorted state of your store again at some point.
    </para>
    <para>
     The &gtk-tree-model-sort; class implements the &gtk-tree-sortable; interface, so you can treat it just
     as if it was your data store for sorting purposes. Here is the basic setup with a tree view:
    </para>
    <programlisting>
(defun create-list-and-view ()
  (let* ((liststore (gtk-list-store-new "gchararray" "guint"))
         (sortmodel (gtk-tree-model-sort-new-with-model liststore))
         (view (gtk-tree-view-new-with-model sortmodel)))
    ...
    (gtk-tree-sortable-set-sort-func sortmodel sortid-name #'sort-name-func)
    (gtk-tree-sortable-set-sort-func wortmodel wortid-year #'sort-year-func)
    ;; Set initial sort order
    (setf (gtk-tree-sortable-sort-column-id sortmodel) sortid-name)
    ... ))
    </programlisting>
    <para>
     However, when using the sort tree model, you need to be careful when you use iterators and paths with
     the model. This is because a path pointing to a row in the view (and the sort tree model here) does
     probably not point to the same row in the child model which is your original list store or tree store,
     because the row order in the child model is probably different from the sorted order. Similarly, an
     iterator that is valid for the sort tree model is not valid for the child model, and vice versa. You can
     convert paths and iterators from and to the child model using the functions
     &gtk-tree-model-sort-convert-child-path-to-path;, &gtk-tree-model-sort-convert-child-iter-to-iter;,
     &gtk-tree-model-sort-convert-path-to-child-path;, and &gtk-tree-model-sort-convert-iter-to-child-iter;.
     You are unlikely to need these functions frequently though, as you can still directly use the function
     &gtk-tree-model-get; on the sort tree model with a path supplied by the tree view.
    </para>
    <para>
     For the tree view, the sort tree model is the 'real' model - it knows nothing about the sort tree model's
     child model at all, which means that any path or iterator that you get passed from the tree view in a
     callback or otherwise will refer to the sort tree model, and that you need to pass a path or iterator
     refering to the sort tree model as well if you call tree view functions.
    </para>
   </section>

   <section id="Sorting_and_Tree_View_Column_Headers" revision="2021-2-28">
    <title>Sorting and Tree View Column Headers</title>
    <para>
     Unless you have hidden your tree view column headers or use custom tree view column header widgets, each
     tree view column's header can be made clickable. Clicking on a tree view column's header will then sort
     the list according to the data in that column. You need to do two things to make this happen: firstly,
     you need to tell your model which sort function to use for which sort column ID with the function
     &gtk-tree-sortable-set-sort-func;. Once you have done this, you tell each tree view column which sort
     column ID should be active if this column's header is clicked. This is done with the function
     &gtk-tree-view-column-sort-column-id;.
    </para>
    <para>
     And that is really all you need to do to get your list or tree sorted. The tree view columns will
     automatically set the active sort column ID and sort order for you if you click on a column header.
    </para>
   </section>
  </section>

  <section id="Editable_Cells" revision="2021-3-9">
   <title>Editable Cells</title>

   <section id="Editable_Text_Cells" revision="2021-3-9">
    <title>Editable Text Cells</title>
    <para>
     With the &gtk-cell-renderer-text; object you cannot only display text, but you can also allow the user
     to edit a single cell's text right in the tree view by double-clicking on a cell.
    </para>
    <para>
     To make this work you need to tell the cell renderer that a cell is editable, which you can do by
     setting the &gtk_cell_renderer_text_editable; property of the text cell renderer in question to
     <emphasis>true</emphasis>. You can either do this on a per-row basis (which allows you to set each
     single cell either editable or not) by connecting the &gtk_cell_renderer_text_editable; property to a
     boolean type column in your tree model using attributes; or you can just do a ...
    </para>
    <programlisting>
(setf (gtk-cell-renderer-text-editable renderer) t)
    </programlisting>
    <para>
     ... when you create the renderer, which sets all rows in that particular renderer column to be editable.
    </para>
    <para>
     Now that our cells are editable, we also want to be notified when a cell has been edited. This can be
     achieved by connecting to the cell renderer's "edited" signal:
    </para>
    <programlisting>
(g-signal-connect renderer "edited"
                  (lambda (renderer pathstr text)
                    (declare (ignore renderer))
                    (let ((iter (gtk-tree-model-iter-from-string model pathstr)))
                      (gtk-list-store-set-value model
                                                iter
                                                col-product
                                                text))))
    </programlisting>
    <para>
     This callback is then called whenever a cell has been edited.
    </para>
    <para>
     The tree path is passed to the "edited" signal callback in string form. You can convert this into a
     &gtk-tree-path; instance with the function &gtk-tree-path-new-from-string;, or convert it into an
     iterator with the function &gtk-tree-model-iter-from-string;.
    </para>
    <para>
     Note that the cell renderer will not change the data for you in the store. After a cell has been edited,
     you will only receive an "edited" signal. If you do not change the data in the store, the old text will
     be rendered again as if nothing had happened.
    </para>

    <bridgehead renderas='sect3'>Setting the cursor to a specific cell</bridgehead>
    <para>
     You can move the cursor to a specific cell in a tree view with the function &gtk-tree-view-set-cursor;
     (or &gtk-tree-view-set-cursor-on-cell; if you have multiple editable cell renderers packed into one tree
     view column), and start editing the cell if you want to. Similarly, you can get the current row and
     focus column with the function &gtk-tree-view-get-cursor;. Use <code>(gtk-widget-grab-focus view)</code> 
     will make sure that the tree view has the keyboard focus.
    </para>
    <para>
     As the API reference points out, the tree view needs to be realised for cell editing to happen. In other
     words: If you want to start editing a specific cell right at program startup, you need to set up an idle
     timeout with &g-idle-add; that does this for you as soon as the window and everything else has been 
     realised (return <emphasis>false</emphasis> in the timeout to make it run only once). Alternatively you
     could connect to the "realize" signal of the tree view with the function &g-signal-connect-after; to
     achieve the same thing.
    </para>
    <para>
     Connect to the tree view's "cursor-changed" and/or "move-cursor" signals to keep track of the current
     position of the cursor.
    </para>
   </section>

   <section id="Editable_Toggle_and_Radio_Button_Cells" revision="2021-3-9">
    <title>Editable Toggle and Radio Button Cells</title>
    <para>
     Just like you can set a &gtk-cell-renderer-text; object editable, you can specify whether a
     &gtk-cell-renderer-toggle; object should change its state when clicked by setting the
     &gtk_cell_renderer_toggle_activatable; property - either when you create the renderer (in which case all
     cells in that column will be clickable) or by connecting the renderer property to a model column of
     boolean type via attributes.
    </para>
    <para>
     Connect to the "toggled" signal of the toggle cell renderer to be notified when the user clicks on a
     toggle button (or radio button). The user click will not change the value in the store, or the appearance
     of the value rendered. The toggle button will only change state when you update the value in the store.
     Until then it will be in an "inconsistent" state, which is also why you should read the current value of
     that cell from the model, and not from the cell renderer.
    </para>
    <para>
     The callback for the "toggled" signal looks like this (the API reference is a bit lacking in this
     particular case):
    </para>
    <programlisting>
(g-signal-connect renderer "toggled"
                  (lambda (cell pathstr)
                    (let* ((iter (gtk-tree-model-iter-from-string model pathstr))
                           (value (not (gtk-tree-model-value model iter col-done))))
                      (gtk-list-store-set-value model iter col-done value))))
    </programlisting>
    <para>
     Just like with the "edited" signal of the text cell renderer, the tree path is passed to the "toggled"
     signal callback in string form. You can convert this into a &gtk-tree-path; instance with the function
     &gtk-tree-path-new-from-string;, or convert it into an iterator with the function
     &gtk-tree-model-iter-from-string;.
    </para>
   </section>

   <section id="Editable_Spin_Button_Cells" revision="2021-3-9">
    <title>Editable Spin Button Cells</title>
    <para>
     Even though the &gtk-spin-button; widget implements the &gtk-cell-editable; interface (as does the
     &gtk-entry; widget), there is no easy way to get a cell renderer that uses a spin button instead of a
     normal entry when in editing mode.
    </para>
    <para>
     To get this functionality, you need to either write a new cell renderer that works very similar to the
     &gtk-cell-renderer-text; object, or you need to write a new cell renderer class that derives from the
     text cell renderer and changes the behaviour in editing mode.
    </para>
    <para>
     The cleanest solution would probably be to write a 'CellRendererNumeric' that does everything that the
     text cell renderer does, only that it has a float type property instead of the 
     &gtk_cell_renderer_text_text; property, and an additional digits property. However, no one seems to have
     done this yet, so you need to either write one, or find another solution to get spin buttons in editing
     mode.
    </para>
   </section>

   <section id="Example_Editable_Tree_view" revision="2021-3-9">
    <title>Example Editable Tree View</title>
    <para>
     The following examples shows an implementation of editable columns. The first column uses a
     &gtk-cell-renderer-toggle; to render a column with boolean values which are toggled when clicked. The
     second column allows the input of text which is converted into an integer and stored into the model. If
     the input cannot be converted into an integer the value in the cell is not changed. The third column
     uses a &gtk-cell-renderer-combo; object. The model of the combo box is filled in the "editing-started"
     signal handler with values from the column. The last column shows how to connect the &gtk-entry; widget
     with an &gtk-entry-completion; object whose model is filled with some values from a given list.
    </para>

    <programlisting xmlns:xi="http://www.w3.org/2001/XInclude">
<xi:include href="src/tree-view-editable.lisp" parse="text"/>
    </programlisting>

   </section>
  </section>

<!--
  <section id="Drag_and_Drop">
   <title>Drag and Drop</title>
   <para>
   </para>
  </section>
-->

<!--
  <section id="Miscellaneous">
   <title>Miscellaneous</title>
   <para>
   </para>
  </section>
-->

<!--
  <section id="Writing_Custom_Models">
   <title>Writing Custom Models</title>
   <para>
   </para>
  </section>
-->

<!--
  <section id="Writing_Custom_Cell_Renderers">
   <title>Writing Custom Cell Renderers</title>
   <para>
   </para>
  </section>
-->

 </chapter>

 <chapter id="Dialogs">
  <title>Dialogs</title>

  <section id="General_Dialog">
   <title>General Dialog</title>
   <figure id="figure-dialog-window">
    <title>General Dialog Window</title>
    <mediaobject>
     <imageobject>
      <imagedata fileref="figures/dialog-window403x167.png" format="png"></imagedata>
     </imageobject>
    </mediaobject>
   </figure>
   <para>
    The dialog widget is just a window with a few things pre-packed into it.  The dialog widget is of type
    &gtk-dialog; which is represented by the Lisp class
    &gtk-dialog;.  A dialog widget can be created with the
    function <ulink url="&gtk-dialog-new;"><code>gtk-dialog-new</code></ulink> or the call
    <code>(make-instance 'gtk-dialog)</code>.  The function <ulink url="&gtk-dialog-new;">
    <code>gtk-dialog-new</code></ulink> does not take an argument.  In addition the function
    <ulink url="&gtk-dialog-new-with-buttons;"><code>gtk-dialog-new-with-buttons</code></ulink> is available.
    It allows you to set the dialog title, some convenient flags, and add simple buttons.
   </para>
   <para>
    The dialog widget consists of an content area which is of type &gtk-box; with the value
    <code>:vertical</code> of type
    &gtk-orientation;.  The content area can be filled with
    the content of a dialog.  At the button of the window the dialog widget has an action area which takes
    the desired buttons of the dialog.
   </para>
   <para>
    The function <ulink url="&gtk-dialog-content-area;"><code>gtk-dialog-content-area</code></ulink> gets the
    content area of a dialog.  Because the content area is a vertical box of type &gtk-box; any desired
    widgets can be added to the content area with the functions &gtk-box-pack-start; or
    &gtk-box-pack-end;. To display the content area it is
    necessary to call the function &gtk-widget-show;
    explicitly. The function <code>create-dialog</code> in example <link linkend="example-dialog-window">
    Dialog Window</link> shows how to fill widgets into a dialog widget.
   </para>
   <para>
    The action area can be filled with the desired buttons for the dialog window. Standard buttons can be
    added with the function <ulink url="&gtk-dialog-add-button;"><code>gtk-dialog-add-button</code></ulink>.
    The function takes three arguments.  The first argument is the dialog window the button is added to. The
    second argument is a string which is the text of the button or a stock ID. The last argument is a value
    of the &gtk-response-type; enumeration and defines the response type of the button. Possible values of
    the &gtk-response-type; enumeration are shown in table <link linkend="table-gtk-response-type">
    GtkResponseType</link>.
   </para>
   <para>
    Alternatively to the function <ulink url="&gtk-dialog-add-button;">
    <code>gtk-dialog-add-button</code></ulink> buttons can be added with the functions
    &gtk-box-pack-start; or &gtk-box-pack-end; to the action area.  The action
    area is of type &gtk-button-box; with a
    <code>:horizontal</code> orientation and can be get with the function
    <ulink url="&gtk-dialog-action-area;"><code>gtk-dialog-action-area</code></ulink>.
   </para>
   <table id="table-gtk-response-type" frame='all'>
    <title>Values of the GtkResponseType enumeration</title>
    <tgroup cols='2' align='left' colsep='0' rowsep='0'>
     <thead>
      <row>
       <entry>Value</entry>
       <entry>Description</entry>
      </row>
     </thead>
     <tbody>
      <row>
       <entry valign="top"><code>:none</code></entry>
       <entry valign="top">
        Returned if an action widget has no response ID, or if the dialog gets programmatically hidden or
        destroyed.
       </entry>
      </row>
      <row>
       <entry valign="top"><code>:reject</code></entry>
       <entry valign="top">Generic response ID, not used by GTK dialogs.</entry>
      </row>
      <row>
       <entry valign="top"><code>:accept</code></entry>
       <entry valign="top">Generic response ID, not used by GTK dialogs.</entry>
      </row>
      <row>
       <entry valign="top"><code>:event</code></entry>
       <entry valign="top">Returned if the dialog is deleted.</entry>
      </row>
      <row>
       <entry valign="top"><code>:ok</code></entry>
       <entry valign="top">Returned by OK buttons in GTK dialogs.</entry>
      </row>
      <row>
       <entry valign="top"><code>:cancel</code></entry>
       <entry valign="top">Returned by Cancel buttons in GTK dialogs.</entry>
      </row>
      <row>
       <entry valign="top"><code>:close</code></entry>
       <entry valign="top">Returned by Close buttons in GTK dialogs.</entry>
      </row>
      <row>
       <entry valign="top"><code>:yes</code></entry>
       <entry valign="top">Returned by Yes buttons in GTK dialogs.</entry>
      </row>
      <row>
       <entry valign="top"><code>:no</code></entry>
       <entry valign="top">Returned by No buttons in GTK dialogs.</entry>
      </row>
      <row>
       <entry valign="top"><code>:apply</code></entry>
       <entry valign="top">Returned by Apply buttons in GTK dialogs.</entry>
      </row>
      <row>
       <entry valign="top"><code>:help</code></entry>
       <entry valign="top">Returned by Help buttons in GTK dialogs.</entry>
      </row>
     </tbody>
    </tgroup>
   </table>
   <para>
    After creation and configuration of the dialog window the dialog is executed with the function
    <ulink url="&gtk-dialog-run;"><code>gtk-dialog-run</code></ulink>.  The function takes the dialog window
    of type &gtk-dialog; as the only argument. After closing the dialog window with one of the buttons the
    response is returned as an integer value of the &gtk-response-type; enumeration.
   </para>
  </section>

  <section id="Message_Dialog">
   <sectioninfo>
    <itermset>
     <indexterm zone="General_Dialog">
      <primary>GtkMessageDialog</primary>
     </indexterm>
     <indexterm zone="General_Dialog">
      <primary>message-dialog, gtk-message-dialog</primary>
     </indexterm>
     <indexterm zone="General_Dialog">
      <primary>message-dialog-new, gtk-message-dialog-new</primary>
     </indexterm>
     <indexterm zone="General_Dialog">
      <primary>message-dialog-new-with-markup, gtk-message-dialog-new-with-markup</primary>
     </indexterm>
     <indexterm zone="General_Dialog">
      <primary>message-type, gtk-message-type</primary>
     </indexterm>
     <indexterm zone="General_Dialog">
      <primary>buttons-type, gtk-buttons-type</primary>
     </indexterm>
    </itermset>
   </sectioninfo>
   <title>Message Dialog</title>
   <figure id="figure-message-dialog">
    <title>Message Dialog</title>
    <mediaobject>
     <imageobject>
      <imagedata fileref="figures/message-dialog480x157.gif" format="gif"></imagedata>
     </imageobject>
    </mediaobject>
   </figure>
   <para>
    A message dialog <ulink url="&gtk-message-dialog;"><code>gtk-message-dialog</code></ulink> is a subclass
    of the more general class &gtk-dialog; and gives an easy way
    to display messages to the user. The figure <link linkend="figure-message-dialog">Message Dialog</link>
    shows an example for an informational message.
   </para>
   <para>
    A message dialog is created with the call <code>(make-instance 'gtk-message-dialog)</code> or the
    functions <ulink url="&gtk-message-dialog-new;"><code>gtk-message-dialog-new</code></ulink> and
    <ulink url="&gtk-message-dialog-new-with-markup;">
    <code>gtk-message-dialog-new-with-markup</code></ulink>. Various properties control the appearance of a
    message dialog.  The function <code>create-message-dialog</code> in
    <link linkend="example-dialog-window">Dialog Window</link> shows the settings of the properties
    <code>message-type</code>, <code>buttons</code>, <code>text</code>, and <code>secondary-text</code>.
    The type of a message dialog is one of the values of the <ulink url="&gtk-message-type;">
    <code>gtk-message-type</code></ulink> enumeration.  The possible values are listed in table
    <link linkend="table-gtk-message-type">GtkMessageType</link>.  Predefined buttons of the
    <ulink url="&gtk-buttons-type;"><code>gtk-buttons-type</code></ulink> enumeration for a message dialog
    are listed in table <link linkend="table-gtk-buttons-type">GtkButtonsType</link>.
   </para>
   <table id="table-gtk-message-type" frame='all'>
    <title>The type of message being displayed in the dialog</title>
    <tgroup cols='2' align='left' colsep='0' rowsep='0'>
     <thead>
      <row>
       <entry>Value</entry>
       <entry>Description</entry>
      </row>
     </thead>
     <tbody>
      <row>
       <entry valign="top"><code>:info</code></entry>
       <entry valign="top">Informational message.</entry>
      </row>
      <row>
       <entry valign="top"><code>:warning</code></entry>
       <entry valign="top">Nonfatal warning message.</entry>
      </row>
      <row>
       <entry valign="top"><code>:question</code></entry>
       <entry valign="top">Question requiring a choice.</entry>
      </row>
      <row>
       <entry valign="top"><code>:error</code></entry>
       <entry valign="top">Fatal error message.</entry>
      </row>
      <row>
       <entry valign="top"><code>:other</code></entry>
       <entry valign="top">None of the above, does not get an icon.</entry>
      </row>
     </tbody>
    </tgroup>
   </table>
   <table id="table-gtk-buttons-type" frame='all'>
    <title>Prebuilt sets of buttons for a message dialog</title>
    <tgroup cols='2' align='left' colsep='0' rowsep='0'>
     <thead>
      <row>
       <entry>Value</entry>
       <entry>Description</entry>
      </row>
     </thead>
     <tbody>
      <row>
       <entry valign="top"><code>:none</code></entry>
       <entry valign="top">No buttons at all.</entry>
      </row>
      <row>
       <entry valign="top"><code>:ok</code></entry>
       <entry valign="top">An OK button.</entry>
      </row>
      <row>
       <entry valign="top"><code>:close</code></entry>
       <entry valign="top">A Close button.</entry>
      </row>
      <row>
       <entry valign="top"><code>:cancel</code></entry>
       <entry valign="top">A Cancel button.</entry>
      </row>
      <row>
       <entry valign="top"><code>:yes-no</code></entry>
       <entry valign="top">Yes and No buttons.</entry>
      </row>
      <row>
       <entry valign="top"><code>:ok-cancel</code></entry>
       <entry valign="top">Ok and Cancel buttons.</entry>
      </row>
     </tbody>
    </tgroup>
   </table>
  </section>

  <section id="About_Dialog">
   <sectioninfo>
    <itermset>
     <indexterm zone="About_Dialog">
      <primary>GtkAboutDialog</primary>
     </indexterm>
     <indexterm zone="About_Dialog">
      <primary>about-dialog, gtk-about-dialog</primary>
     </indexterm>
    </itermset>
   </sectioninfo>
   <title>About Dialog</title>
   <figure id="figure-about-dialog">
    <title>About Dialog</title>
    <mediaobject>
     <imageobject>
      <imagedata fileref="figures/about-dialog353x228.gif" format="gif"></imagedata>
     </imageobject>
    </mediaobject>
   </figure>
   <para>
    The <ulink url="&gtk-about-dialog;"><code>gtk-about-dialog</code></ulink> offers a simple way to display
    information about a program like its logo, name, copyright, website and license.  It is also possible to
    give credits to the authors, documenters, translators and artists who have worked on the program.  An
    about dialog is typically opened when the user selects the About option from the Help menu.  All parts of
    the dialog are optional.
   </para>
   <para>
    About dialogs often contain links and email addresses. <ulink url="&gtk-about-dialog;">
    <code>gtk-about-dialog</code></ulink> displays these as clickable links.  By default, it calls the
    function &gtk-show-uri; when a user clicks one.  The
    behavior can be overridden with the "activate-link" signal.
   </para>
   <para>
    To make constructing a <ulink url="&gtk-about-dialog;"><code>gtk-about-dialog</code></ulink> as
    convenient as possible, the function <ulink url="&gtk-show-about-dialog;">
    <code>gtk-show-about-dialog</code></ulink> is available which constructs and shows a dialog and keeps it
    around so that it can be shown again.
   </para>
   <para>
    Note that GTK sets a default title of <code>_("About %s")</code> on the dialog window, where
    <code>%s</code> is replaced by the name of the application, but in order to ensure proper translation of
    the title, applications should set the title property explicitly when constructing a
    <ulink url="&gtk-about-dialog;"><code>gtk-about-dialog</code></ulink>.
   </para>
   <para>
    It is possible to show a <ulink url="&gtk-about-dialog;"><code>gtk-about-dialog</code></ulink> like any
    other &gtk-dialog;, e.g. using
    <ulink url="&gtk-dialog-run;"><code>gtk-dialog-run</code></ulink>.  In this case, you might need to know
    that the 'Close' button returns the <code>:cancel</code> response ID.
   </para>
   <example id="example-dialog-window">
    <title>Examples for a general, a message, and an about dialog</title>
    <programlisting>
(defun license-text ()
  (format nil
          "This program is free software: you can redistribute it and/or ~
          modify it under the terms of the GNU Lesser General Public ~
          License for Lisp as published by the Free Software Foundation, ~
          either version 3 of the License, or (at your option) any later ~
          version and with a preamble to the GNU Lesser General Public ~
          License that clarifies the terms for use with Lisp programs and ~
          is referred as the LLGPL.~%~% ~
          This program is distributed in the hope that it will be useful, ~
          but WITHOUT ANY WARRANTY; without even the implied warranty of ~
          MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the ~
          GNU Lesser General Public License for more details. ~%~% ~
          You should have received a copy of the GNU Lesser General Public ~
          License along with this program and the preamble to the Gnu ~
          Lesser General Public License.  If not, see ~
          &#x3c;http://www.gnu.org/licenses/> and ~
          &#x3c;http://opensource.franz.com/preamble.html>."))

(defun create-dialog ()
  (let ((dialog (make-instance 'gtk-dialog
                               :title "Dialog Window"
                               :has-separator t)))
    ;; Add a border width to the vbox of the content area
    (setf (gtk-container-border-width (gtk-dialog-get-content-area dialog))
          12)
    ;; Add a label widget with text to the content area
    (let ((vbox (make-instance 'gtk-box :orientation :vertical :border-width 12))
          (label (make-instance 'gtk-label
                                :wrap t
                                :label
                                (format nil
                                        "The content area is the place to ~
                                         put in the widgets.~%~% ~
                                         The action area is separated from ~
                                         the content area with a horizontal ~
                                         line."))))
      (gtk-box-pack-start vbox label)
      (gtk-box-pack-start (gtk-dialog-get-content-area dialog) vbox)
      ;; Show the content area of the dialog
      (gtk-widget-show (gtk-dialog-get-content-area dialog)))
    ;; Add buttons with a stock ID to the action area
    (gtk-dialog-add-button dialog "gtk-yes" :yes)
    (gtk-dialog-add-button dialog "gtk-no" :no)
    (gtk-dialog-add-button dialog "gtk-cancel" :cancel)
    (gtk-dialog-set-default-response dialog :cancel)
    ;; Change the order of the buttons
    (gtk-dialog-set-alternative-button-order dialog
                                             (list :yes :cancel :no))
    ;; Run the dialog and print the message on the console
    (format t "Response was: ~S~%" (gtk-dialog-run dialog))
    ;; Destroy the dialog
    (gtk-widget-destroy dialog)))

(defun create-message-dialog ()
  (let ((dialog (make-instance 'gtk-message-dialog
                               :message-type :info
                               :buttons :ok
                               :text "Info Message Dialog"
                               :secondary-text
                               (format nil
                                       "This is a message dialog of type ~
                                        :info with a secondary text."))))
    ;; Run the message dialog
    (gtk-dialog-run dialog)
    ;; Destroy the message dialog
    (gtk-widget-destroy dialog)))

(defun create-about-dialog ()
  (let ((dialog (make-instance 'gtk-about-dialog
                               :program-name "Example Dialog"
                               :version "0.00"
                               :copyright "(c) Dieter Kaiser"
                               :website
                               "github.com/crategus/cl-cffi-gtk"
                               :website-label "Project web site"
                               :license (license-text)
                               :authors '("Kalyanov Dmitry"
                                          "Dieter Kaiser")
                               :documenters '("Dieter Kaiser")
                               :artists '("None")
                               :logo-icon-name
                               "applications-development"
                               :wrap-license t)))
    ;; Run the about dialog
    (gtk-dialog-run dialog)
    ;; Destroy the about dialog
    (gtk-widget-destroy dialog)))

(defun example-dialog ()
  (within-main-loop
    (let ((window (make-instance 'gtk-window
                                 :type :toplevel
                                 :title "Example Dialog"
                                 :default-width 250
                                 :border-width 12))
          (vbox (make-instance 'gtk-box
                               :orientation :vertical
                               :spacing 6)))
      (g-signal-connect window "destroy"
                        (lambda (widget)
                          (declare (ignore widget))
                          (leave-gtk-main)))
      (gtk-container-add window vbox)
      (let ((button (make-instance 'gtk-button
                                   :label "Open a Dialog Window")))
        (gtk-box-pack-start vbox button)
        (g-signal-connect button "clicked"
           (lambda (widget)
             (declare (ignore widget))
             ;; Create and show the dialog
             (create-dialog))))
      (let ((button (make-instance 'gtk-button
                                   :label "Open a Message Dialog")))
        (gtk-box-pack-start vbox button)
        (g-signal-connect button "clicked"
           (lambda (widget)
             (declare (ignore widget))
             ;; Create and show the message dialog
             (create-message-dialog))))
      (let ((button (make-instance 'gtk-button
                                   :label "Open an About Dialog")))
        (gtk-box-pack-start vbox button)
        (g-signal-connect button "clicked"
           (lambda (widget)
             (declare (ignore widget))
             ;; Create and show the about dialog
             (create-about-dialog))))
      (gtk-box-pack-start vbox
                          (make-instance 'gtk-hseparator))
      ;; Create a quit button
      (let ((button (make-instance 'gtk-button
                                   :label "Quit")))
        (g-signal-connect button "clicked"
                          (lambda (widget)
                            (declare (ignore widget))
                            (gtk-widget-destroy window)))
        (gtk-box-pack-start vbox button))
      (gtk-widget-show window))))
    </programlisting>
   </example>
  </section>
 </chapter>

 <chapter id="Selecting_Colors_Files_and_Fonts">
  <title>Selecting Colors, Files, and Fonts</title>

  <section id="Selecting_Colors">
   <title>Selecting Colors</title>

   <section id="Representing_Colors">
    <title>Representing Colors</title>
    <para>
     Colors are represented as a &gdk-rgba; structure, which is defined in the GDK library. The structure
     has the properties <code>red</code>, <code>green</code>, <code>blue</code>, and <code>alpha</code> to
     represent RGBA colors. It is based on Cairo's way to deal with colors and mirrors its behavior. All
     values are in the range from 0.0 to 1.0 inclusive. Other values will be clamped to this range when
     drawing.
    </para>
    <para>
     The function &gdk-rgba-new; is the constructor for creating a &gdk-rgba; instance. To create a
     representation of the color red use
     <programlisting>
(gdk-rgba-new :red 1.0)
     </programlisting>
     The color
     <programlisting>
(gdk-rgba-new :red 0.0 :green 0.0 :blue 0.0 :alpha 0.0)
     </programlisting>
     represents transparent black and the color
     <programlisting>
(gdk-rgba-new :red 1.0 :green 1.0 :blue 1.0 :alpha 1.0)
     </programlisting>
     is opaque white. 
    </para>
    <para>
     Alternatively, the function &gdk-rgba-parse; parses a textual representation of a color, filling in the
     <code>red</code>, <code>green</code>, <code>blue</code> and <code>alpha</code> fields of the &gdk-rgba;
     instance. The textual representation can be either one of:
    </para>
    <itemizedlist>
     <listitem>
       A standard name taken from the X11 <code>rgb.txt</code> file.
     </listitem>
     <listitem>
      A hex value in the form <code>rgb</code>, <code>rrggbb</code>, <code>rrrgggbbb</code> or
      <code>rrrrggggbbb</code>.
     </listitem>
     <listitem>
      A RGB color in the form <code>rgb(r,g,b)</code>. In this case the color will have full opacity.
     </listitem>
     <listitem>
      A RGBA color in the form <code>rgba(r,g,b,a)</code>.
     </listitem>
    </itemizedlist>
    <para>
     Where <code>r</code>, <code>g</code>, <code>b</code> and <code>a</code> are respectively the
     <code>red</code>, <code>green</code>, <code>blue</code>, and <code>alpha</code> color values. In the
     last two cases, <code>r</code>, <code>g</code> and <code>b</code> are either integers in the range 0 to
     255 or precentage values in the range 0 % to 100 %, and <code>a</code> is a floating point value in the
     range 0.0 to 1.0.
    </para>
    <para>
     Conversely, the function &gdk-rgba-to-string; returns a textual specification of the RGBA color in the
     form <code>rgb(r,g,b)</code> or <code>rgba(r,g,b,a)</code>. These string forms are supported by the CSS3
     colors module, and can be parsed by the function &gdk-rgba-parse;. Note that this string representation
     may loose some precision, since <code>r</code>, <code>g</code>, and <code>b</code> are represented as
     8-bit integers. If this is a concern, you should use a different representation.
    </para>
    <para>
     A simple example is the representation of the color red, which can be created from a string with the call
     <programlisting>
(gdk-rgba-parse "Red")
=> #S(GDK-RGBA :RED 1.0d0 :GREEN 0.0d0 :BLUE 0.0d0 :ALPHA 1.0d0)
     </programlisting>
     and converted back to a textual representation with
     <programlisting>
(gdk-rgba-to-string (gdk-rgba-parse "Red"))
=> "rgb(255,0,0)"
     </programlisting>
    </para>
    <note>
     GTK knows a second deprecated representation of colors as a &gdk-color; structure. All functions that
     use the &gdk-color; representation are also deprecated.
    </note>
   </section>

   <section id="Color_Button_and_Color_Chooser_Dialog" revision="2021-2-11">
    <title>Color Button and Color Chooser Dialog</title>
    <figure id="figure-color-button-label">
     <title>Color Button</title>
     <mediaobject>
      <imageobject>
       <imagedata fileref="figures/color-button-label.png" format="png"></imagedata>
      </imageobject>
     </mediaobject>
    </figure>
    <para>
     The &gtk-color-button; widget is a button which displays the currently selected color and allows to
     open a color selection dialog to change the color. It is a suitable widget for selecting a color in a
     preference dialog. It implements the &gtk-color-chooser; interface.
    </para>
    <para>
     Example <link linkend="example-color-button-label">Color Button</link> shows a simple implementation
     of a &gtk-color-button; widget. The example displays a color button and a label "Color Button". When
     clicking the button, a color selection dialog is opened. The dialog is shown in figure
     <link linkend="figure-color-chooser-dialog">Color Chooser Dialog</link>. To get the currently selected
     color you should connect a handler to the signal "color-set" and retrieve the color with the slot access
     function &gtk-color-chooser-rgba;. To change the color of the label the CSS color is loaded in a CSS
     provider with the function &gtk-css-provider-load-from-data; and the style context of the label is
     updated with the function &gtk-style-context-add-provider;.
    </para>
    <figure id="figure-color-chooser-dialog">
     <title>Color Chooser Dialog</title>
     <mediaobject>
      <imageobject>
       <imagedata fileref="figures/color-chooser-dialog.png" format="png"></imagedata>
      </imageobject>
     </mediaobject>
    </figure>
    <example id="example-color-button-label">
     <title>Color Button</title>
     <programlisting xmlns:xi="http://www.w3.org/2001/XInclude">
<xi:include href="src/color-button-label.lisp" parse="text"/>
     </programlisting>
    </example>
    <para>
     The &gtk-color-chooser-dialog; widget is a dialog for choosing a color. It implements the
     &gtk-color-chooser; interface. The &gtk-color-chooser-widget; widget is used in the dialog to provide a
     dialog for selecting colors.
    </para>
    <para>
     By default, the chooser presents a prefined palette of colors, plus a small number of settable custom
     colors. The dialog is shown in figure <link linkend="figure-color-chooser-dialog">
     Color Chooser Dialog</link> It is also possible to select a different color with the single-color editor.
     To enter the single-color editing mode, use the context menu of any color of the palette, or use the '+'
     button to add a new custom color. The chooser automatically remembers the last selection, as well as
     custom colors. To change the initially selected color or to get the selected color use the slot access
     function &gtk-color-chooser-rgba;.
    </para>
    <para>
     Example <link linkend="example-color-chooser-palette">Color Chooser Palette</link> shows how to replace
     the default color palette and the default gray palette with the function &gtk-color-chooser-add-palette;.
     The custom color palettes are shown in figure <link linkend="figure-color-chooser-palette">
     Color Chooser Palette</link>. Clicking on the drawing area opens a color chooser dialog to select a new
     background color for the drawing area.
    </para>
    <figure id="figure-color-chooser-palette">
     <title>Color Chooser Dialog with a custom color and gray palette</title>
     <mediaobject>
      <imageobject>
       <imagedata fileref="figures/color-chooser-palette.png" format="png"></imagedata>
      </imageobject>
     </mediaobject>
    </figure>
    <example id="example-color-chooser-palette">
     <title>Color Chooser Dialog with custom palettes</title>
     <programlisting xmlns:xi="http://www.w3.org/2001/XInclude">
<xi:include href="src/color-chooser-dialog.lisp" parse="text"/>
     </programlisting>
    </example>
   </section>
  </section>

  <section id="Selecting_Files" revision="2021-2-11">
   <title>Selecting Files</title>
   <figure id="figure-file-chooser-dialog">
    <title>File Chooser Dialog</title>
    <mediaobject>
     <imageobject>
      <imagedata fileref="figures/file-chooser-dialog.png" format="png"></imagedata>
     </imageobject>
    </mediaobject>
   </figure>
   <para>
    The &gtk-file-chooser; interface is an interface that can be implemented by file selection widgets. In
    GTK, the main objects that implement this interface are the &gtk-file-chooser-widget;,
    &gtk-file-chooser-dialog;, and &gtk-file-chooser-button; widgets. You do not need to write an object that
    implements the &gtk-file-chooser; interface unless you are trying to adapt an existing file selector to
    expose a standard programming interface.
   </para>
   <para>
    The &gtk-file-chooser; interface allows for shortcuts to various places in the filesystem.  In the
    default implementation these are displayed in the left pane. It may be a bit confusing at first that
    these shortcuts come from various sources and in various flavours, so lets explain the terminology here:
   </para>
   <variablelist>
    <varlistentry>
     <term>Bookmarks</term>
     <listitem>
      are created by the user, by dragging folders from the right pane to the left pane, or by using the
      "Add". Bookmarks can be renamed and deleted by the user.
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>Shortcuts</term>
     <listitem>
      can be provided by the application or by the underlying filesystem abstraction (e.g. both the gnome-vfs
      and the Windows filesystems provide "Desktop" shortcuts). Shortcuts cannot be modified by the user.
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>Volumes</term>
     <listitem>
      are provided by the underlying filesystem abstraction. Volumes are the "roots" of the filesystem.
     </listitem>
    </varlistentry>
   </variablelist>

   <bridgehead renderas='sect3'>File Names and Encodings</bridgehead>
   <para>
    When the user has finished selecting files in a &gtk-file-chooser; object, the program can receive the
    selected names either as filenames or as URIs. For URIs, the normal escaping rules are applied if the URI
    contains non-ASCII characters. However, filenames are always returned in the character set specified by
    the <code>G_FILENAME_ENCODING</code> environment variable. Please see the Glib documentation for more
    details about this variable.
   </para>
   <para>
    <emphasis>Note:</emphasis> You may not be able to directly set the result of the function
    &gtk-file-chooser-filename; as the text of a &gtk-label; widget unless you convert it first to UTF-8,
    which all GTK widgets expect. You should use the function &g-filename-to-utf8; to convert filenames into
    strings that can be passed to GTK widgets.
   </para>

   <bridgehead renderas='sect3'>Adding a Preview Widget</bridgehead>
   <para>
    You can add a custom preview widget to a file chooser and then get notification about when the preview
    needs to be updated. To install a preview widget, use the function &gtk-file-chooser-preview-widget;.
    Then, connect to the "update-preview" signal to get notified when you need to update the contents of the
    preview.
   </para>
   <para>
    Your callback should use the function &gtk-file-chooser-preview-filename; to see what needs previewing.
    Once you have generated the preview for the corresponding file, you must call the function
    &gtk-file-chooser-preview-widget-active; with a boolean flag that indicates whether your callback could
    successfully generate a preview.
   </para>

   <bridgehead renderas='sect3'>Adding Extra Widgets</bridgehead>
   <para>
    You can add extra widgets to a file chooser to provide options that are not present in the default
    design. For example, you can add a toggle button to give the user the option to open a file in read-only
    mode. You can use the function &gtk-file-chooser-extra-widget; to insert additional widgets in a file
    chooser.
   </para>
   <para>
    <emphasis>Note:</emphasis> If you want to set more than one extra widget in the file chooser, you can
    use a container such as a &gtk-box; or a &gtk-grid; widget and include your widgets in it. Then, set the
    container as the whole extra widget.
   </para>
   <para>
    The &gtk-file-chooser-dialog; widget is a dialog box suitable for use with "File/Open" or "File/Save as"
    commands. This widget works by putting a &gtk-file-chooser-widget; widget inside a &gtk-dialog; widget.
    It exposes the &gtk-file-chooser; interface, so you can use all of the &gtk-file-chooser; functions on
    the file chooser dialog as well as those for the &gtk-dialog; class.
   </para>
   <para>
    Note that the &gtk-file-chooser-dialog; class does not have any methods of its own. Instead, you should
    use the functions that work on a &gtk-file-chooser; object.
   </para>

   <section id="Setting_up_a_file_chooser_dialog">
    <title>Setting up a file chooser dialog</title>
    <para>
     The &gtk-file-chooser-action; enumeration describes whether a &gtk-file-chooser; widget is being used
     to open existing files or to save to a possibly new file. These are the cases in which you may need to
     use a &gtk-file-chooser-dialog; widget.
    </para>
    <itemizedlist>
     <listitem>
      To select a file for opening, as for a File/Open command. Use the keyword <code>:open</code> for the
      slot <code>:action</code>, when creating a file chooser dialog.
     </listitem>
     <listitem>
      To save a file for the first time, as for a File/Save command. Use the keyword <code>:save</code>,
      and suggest a name such as "Untitled" with the function &gtk-file-chooser-current-name;.
     </listitem>
     <listitem>
      To save a file under a different name, as for a File/Save As command. Use the keyword
      <code>:save</code>, and set the existing filename with the function &gtk-file-chooser-filename;.
     </listitem>
     <listitem>
      To choose a folder instead of a file. Use the keyword <code>:select-folder</code>.
     </listitem>
    </itemizedlist>
   </section>

   <section id="Response_Codes">
    <title>Response Codes</title>
    <para>
     The &gtk-file-chooser-dialog; class inherits from the &gtk-dialog; class, so buttons that go in its
     action area have response codes such as <code>:accept</code> and <code>:canel</code>. For example, you
     could create a file chooser dialog as follows:
    </para>
    <programlisting>
(let ((dialog (gtk-file-chooser-dialog-new "Save"
                                           nil
                                           :save
                                           "gtk-save" :accept
                                           "gtk-cancel" :cancel)))
  [...] )
    </programlisting>
    <para>
     This will create buttons for "Cancel" and "Save" that use stock response identifiers from the
     &gtk-response-type; enumeration. For most dialog boxes you can use your own custom response codes rather
     than the ones in the &gtk-response-type; enumeration, but the &gtk-file-chooser-dialog; widget assumes
     that its "accept"-type action, e.g. an "Open" or "Save" button, will have one of the following response
     codes <code>:accept</code>, <code>:ok</code>, <code>:yes</code>, or <code>:apply</code>.
    </para>
    <para>
     This is because the &gtk-file-chooser-dialog; widget must intercept responses and switch to folders if
     appropriate, rather than letting the dialog terminate - the implementation uses these known response
     codes to know which responses can be blocked if appropriate. To summarize, make sure you use a stock
     response code when you use the &gtk-file-chooser-dialog; widget to ensure proper operation.
    </para>
    <para>
     Example <link linkend="example-file-chooser-dialog">File Chooser Dialog</link> shows an example for
     selecting a file for open. The dialog is shown in figure <link linkend="figure-file-chooser-dialog">
     File Chooser Dialog</link>.
    </para>
    <example id="example-file-chooser-dialog">
     <title>File Chooser Dialog</title>
     <programlisting>
(defun create-file-chooser-dialog ()
  (let ((dialog (gtk-file-chooser-dialog-new "Example File Chooser Dialog"
                                             nil
                                             :open
                                             "gtk-open" :accept
                                             "gtk-cancel" :cancel)))
    (when (eq :accept (gtk-dialog-run dialog))
      (format t "Save to file ~A~%"
                (gtk-file-chooser-filename dialog)))
    (gtk-widget-destroy dialog)))
     </programlisting>
    </example>
    <figure id="figure-file-chooser-button">
     <title>File Chooser Button</title>
     <mediaobject>
      <imageobject>
       <imagedata fileref="figures/file-chooser-button.png" format="png"></imagedata>
      </imageobject>
     </mediaobject>
    </figure>
    <para>
     The &gtk-file-chooser-button; widget is a widget that lets the user select a file. It implements the
     &gtk-file-chooser; interface. Visually, it is a file name with a button to bring up a
     &gtk-file-chooser-dialog; widget. The user can then use that dialog to change the file associated with
     that button.
    </para>
    <para>
     Example <link linkend="example-file-chooser-button">File Chooser Button</link> shows an example for a
     file chooser button to select a folder and a second file chooser button to select a file. When a folder
     is selected, the second button is set to that folder accordingly and vice versa. Also, this example
     shows how to set some filters to allow the user to filter text and images files.
    </para>
    <example id="example-file-chooser-button">
     <title>File Chooser Button</title>
     <programlisting xmlns:xi="http://www.w3.org/2001/XInclude">
<xi:include href="src/file-chooser-button.lisp" parse="text"/>
     </programlisting>
    </example>
   </section>
  </section>

  <section id="Selecting_Fonts" revision="2021-2-11">
   <title>Selecting Fonts</title>
   <figure id="figure-font-chooser-dialog">
    <title>Font Chooser Dialog</title>
    <mediaobject>
     <imageobject>
      <imagedata fileref="figures/font-chooser-dialog.png" format="png"></imagedata>
     </imageobject>
    </mediaobject>
   </figure>
   <para>
    The &gtk-font-chooser-widget; widget lists the available fonts, styles and sizes, allowing the user to
    select a font. It is used in the &gtk-font-chooser-dialog; widget to provide a dialog box for selecting
    fonts. It implements the &gtk-font-chooser; interface.
   </para>
   <para>
    To set or get the font which is initially selected, use the slot access functions &gtk-font-chooser-font;
    or &gtk-font-chooser-font-desc;. To change the text which is shown in the preview area, use the function
    &gtk-font-chooser-preview-text;.
   </para>
   <figure id="figure-font-button">
    <title>Font Button</title>
    <mediaobject>
     <imageobject>
      <imagedata fileref="figures/font-button-label.png" format="png"></imagedata>
     </imageobject>
    </mediaobject>
   </figure>
   <para>
    The &gtk-font-button; is a button which displays the currently selected font and allows to open a font
    chooser dialog to change the font. It is a suitable widget for selecting a font in a preference dialog.
    The example <link linkend="example-font-button">Font Button</link> shows how to retrieve the Pango font
    description from the font chooser dialog with the function &gtk-font-chooser-font-desc; and to use it to
    change the font of a label with CSS.
   </para>
   <example id="example-font-button">
    <title>Font Button with a filter to select fonts</title>
     <programlisting xmlns:xi="http://www.w3.org/2001/XInclude">
<xi:include href="src/font-button-label.lisp" parse="text"/>
     </programlisting>
   </example>
  </section>
 </chapter>
    
 <chapter id="Miscellaneous Widgets">
  <title>Miscellaneous Widgets</title>

  <section id="Arrows">
   <title>Arrows</title>
   <figure id="figure-arrows">
    <title>Arrows</title>
    <mediaobject>
     <imageobject>
      <imagedata fileref="figures/arrow-buttons.gif" format="gif"></imagedata>
     </imageobject>
    </mediaobject>
   </figure>
   <para>
    The arrow widget draws an arrowhead, facing in a number of possible directions and having a number of
    possible styles.  It can be very useful when placed on a button.  Like the label widget, the arrow
    widget emits no signals. There are only two functions for manipulating an arrow widget
    <ulink url="&gtk-arrow-new;"><code>gtk-arrow-new</code></ulink> and <ulink url="&gtk-arrow-set;">
    <code>gtk-arrow-set</code></ulink>.  The first function creates a new arrow widget with the indicated
    type and appearance.  The second function allows these values to be altered retrospectively.  The type
    of an arrow can be one of of the values of the enumeration type <ulink url="&gtk-arrow-type;">
    <code>gtk-arrow-type</code></ulink>. Possible values are <code>:up</code>, <code>:down</code>,
    <code>:left</code> and <code>:right</code>.  These values obviously indicate the direction in which the
    arrow will point.
   </para>
   <para>
    The shadow type argument is of the enumeration type &gtk-shadow-type;
    and may take one of the the values <code>:none</code>,
    <code>:in</code>, <code>:etched-in</code> and <code>:etched-out</code>.
   </para>
   <para>
    The amount of space used by the arrow is controlled by the style property <code>arrow-scaling</code>.
    The style property <code>arrow-scaling</code> takes values of type <code>double</code> in a range of
    <code>[0,1]</code>.  The default value is <code>0.7</code>.
   </para>
   <para>
    Example <link linkend="example-arrows">Arrows</link> shows a brief example to illustrate the use of
    arrows in buttons.  In addition, this example introduces the function
    <ulink url="&gtk-widget-tooltip-text;"><code>gtk-widget-tooltip-text</code></ulink>, which attaches a
    tooltip to the button widget.  The tooltip pops up, when the mouse is over the button.
   </para>
   <example id="example-arrows">
    <title>Buttons with Arrows</title>
    <programlisting>
(defun create-arrow-button (arrow-type shadow-type)
  (let (;; Create a button
        (button (make-instance 'gtk-button
                               ;; Add a small margin around the button
                               :margin 3
                               ;; Make big buttons of size 75 x 75
                               :width-request 75
                               :height-request 75)))
    ;; Add an arrow to the button
    (gtk-container-add button
                       (make-instance 'gtk-arrow
                                      :arrow-type arrow-type
                                      :shadow-type shadow-type))
    ;; Add a tooltip to the button
    (setf (gtk-widget-tooltip-text button)
          (format nil "Arrow of type ~A" (symbol-name arrow-type)))
    button))

(defun example-arrows ()
  (within-main-loop
    (let ((;; Create the main window
           window (make-instance 'gtk-window
                                 :type :toplevel
                                 :title "Example Arrow Buttons"
                                 :default-width 275
                                 :default-height 125
                                 :border-width 12))
          ;; Create a grid for the buttons
          (grid (make-instance 'gtk-grid
                               :orientation :horizontal
                               :column-homogeneous t)))
      ;; Connect a signal handler to the window
      (g-signal-connect window "destroy"
                        (lambda (widget)
                          (declare (ignore widget))
                          (leave-gtk-main)))
      ;; Create buttons with an arrow and add the buttons to the grid
      (gtk-container-add grid (create-arrow-button :up :in))
      (gtk-container-add grid (create-arrow-button :down :out))
      (gtk-container-add grid (create-arrow-button :left :etched-in))
      (gtk-container-add grid (create-arrow-button :right :etched-out))
      ;; Add the grid to the window
      (gtk-container-add window grid)
      ;; Show the window
      (gtk-widget-show-all window))))
    </programlisting>
   </example>
  </section>

  <section id="Calendar">
   <title>Calendar</title>
   <figure id="figure-calendar">
    <title>Calendar</title>
    <mediaobject>
     <imageobject>
      <imagedata fileref="figures/calendar.gif" format="gif"></imagedata>
     </imageobject>
    </mediaobject>
   </figure>
   <para>
    The <ulink url="&gtk-calendar;"><code>gtk-calendar</code></ulink> widget displays a Gregorian calendar,
    one month at a time.  It can be created with the function <ulink url="&gtk-calendar-new;">
    <code>gtk-calendar-new</code></ulink>.
   </para>
   <para>
    The month and year currently displayed can be altered with the function
    <ulink url="&gtk-calendar-select-month;"><code>gtk-calendar-select-month</code></ulink>.  The exact day
    can be selected from the displayed month using the function <ulink url="&gtk-calendar-select-day;">
    <code>gtk-calendar-select-day</code></ulink>.
   </para>
   <para>
    To place a visual marker on a particular day, use the function <ulink url="&gtk-calendar-mark-day;">
    <code>gtk-calendar-mark-day</code></ulink> and to remove the marker the function
    <ulink url="&gtk-calendar-unmark-day;"><code>gtk-calendar-unmark-day</code></ulink>.  Alternative, all
    marks can be cleared with the function <ulink url="&gtk-calendar-clear-marks;">
    <code>gtk-calendar-clear-marks</code></ulink>.
   </para>
   <para>
    The way in which the calendar itself is displayed can be altered using the function
    <ulink url="&gtk-calendar-display-options;"><code>gtk-calendar-display-options</code></ulink>.
   </para>
   <para>
    The selected date can be retrieved from a <ulink url="&gtk-calendar;"><code>gtk-calendar</code></ulink>
    using the function <ulink url="&gtk-calendar-date;"><code>gtk-calendar-date</code></ulink>.
   </para>
   <para>
    Users should be aware that, although the Gregorian calendar is the legal calendar in most countries, it
    was adopted progressively between 1582 and 1929.  Display before these dates is likely to be historically
    incorrect.
   </para>
   <para>
    Example <link linkend="example-calendar">Calendar</link> shows a brief example of the calendar widget.
    It is possible to set a special function with the function <ulink url="&gtk-calendar-set-detail-func;">
    <code>gtk-calendar-set-detail-func</code></ulink>.  The example uses this to show a tooltip
    whenever the 12th day of a month is selected.
   </para>
   <example id="example-calendar">
    <title>Calendar</title>
    <programlisting>
(defun example-calendar ()
  (within-main-loop
    (let ((window (make-instance 'gtk-window
                                 :title "Example Calendar"
                                 :type :toplevel
                                 :border-width 24
                                 :default-width 250
                                 :default-height 100))
          (frame (make-instance 'gtk-frame))
          (calendar (make-instance 'gtk-calendar
                                   :show-details nil)))
      ;; Connect a signal handler to the window
      (g-signal-connect window "destroy"
                        (lambda (widget)
                          (declare (ignore widget))
                          (leave-gtk-main)))
      ;; Connect a signal handler to print the selected day
      (g-signal-connect calendar "day-selected"
                        (lambda (widget)
                          (declare (ignore widget))
                          (format t "selected: year ~A month ~A day ~A~%"
                                  (gtk-calendar-year calendar)
                                  (gtk-calendar-month calendar)
                                  (gtk-calendar-day calendar))))
      ;; Install a calendar detail function
      (gtk-calendar-set-detail-func calendar
                                    (lambda (calendar year month day)
                                      (declare (ignore calendar year month))
                                      (when (= day 12)
                                        "This day has a tooltip.")))
      ;; Mark a day
      (gtk-calendar-mark-day calendar 6)
      ;; Put the calendar into the frame and the frame into the window.
      (gtk-container-add frame calendar)
      (gtk-container-add window frame)
      (gtk-widget-show-all window))))
    </programlisting>
   </example>
  </section>

  <section id="Event_Box">
   <sectioninfo>
    <itermset>
     <indexterm zone="Event_Box">
      <primary>GtkEventBox</primary>
     </indexterm>
     <indexterm zone="Event_Box">
      <primary>event-box, gtk-event-box</primary>
     </indexterm>
     <indexterm zone="Event_Box">
      <primary>event-box-new, gtk-event-box-new</primary>
     </indexterm>
     <indexterm zone="Event_Box">
      <primary>widget-events, gtk-widget-events</primary>
     </indexterm>
     <indexterm zone="Event_Box">
      <primary>widget-realize, gtk-widget-realize</primary>
     </indexterm>
     <indexterm zone="Event_Box">
      <primary>GdkWindow</primary>
     </indexterm>
     <indexterm zone="Event_Box">
      <primary>window, gdk-window</primary>
     </indexterm>
     <indexterm zone="Event_Box">
      <primary>GdkCursor</primary>
     </indexterm>
     <indexterm zone="Event_Box">
      <primary>cursor, gdk-cursor</primary>
     </indexterm>
     <indexterm zone="Event_Box">
      <primary>cursor-new-from-name, gdk-cursor-new-from-name</primary>
     </indexterm>
     <indexterm zone="Event_Box">
      <primary>widget-window, gtk-widget-window</primary>
     </indexterm>
     <indexterm zone="Event_Box">
      <primary>window-cursor, gdk-window-cursor</primary>
     </indexterm>
    </itermset>
   </sectioninfo>

   <title>Event Box</title>

   <figure id="figure-event-box-2">
    <title>Event Box</title>
    <mediaobject>
     <imageobject>
      <imagedata fileref="figures/event-box.png" format="png"></imagedata>
     </imageobject>
    </mediaobject>
   </figure>

   <para>
    Some GTK widgets do not have associated X windows, so these widgets just draw on their parents.  Because
    of this, they cannot receive events and if they are incorrectly sized, they do not clip so you can get
    messy overwriting.  If you require more from these widgets, the &gtk-event-box;
     widget is for you.
   </para>
   <para>
    At first glance, the &gtk-event-box; widget might appear
    to be totally useless. It draws nothing on the screen and responds to no events. However, it does serve
    a function - it provides an X window for its child widget. This is important as many GTK widgets do not
    have an associated X window. Not having an X window saves memory and improves performance, but also has
    some drawbacks. A widget without an X window cannot receive events, and does not perform any clipping on
    its contents. Although the name &gtk-event-box;
    emphasizes the event-handling function, the widget can also be used for clipping.
   </para>
   <para>
    To create a new &gtk-event-box; widget, use the call
    <code>(make-instance 'gtk-event-box)</code> or the function <ulink url="&gtk-event-box-new;">
    <code>gtk-event-box-new</code></ulink>. A child widget can then be added to this event box with the
    function &gtk-container-add;. With the function
    <ulink url="&gtk-widget-events;"><code>gtk-widget-events</code></ulink> the events are set for the event
    box which can be connected to a signal handler. To create the resources associated with an event box,
    the function <ulink url="&gtk-widget-realize;"><code>gtk-widget-realize</code></ulink> has to be called
    explicitly for the &gtk-event-box; widget.
   </para>
   <para>
    Example <link linkend="example-event-box">Event Box</link> demonstrates both uses of a
    &gtk-event-box; widget - a label is created that is
    clipped to a small box, and set up so that a mouse-click on the label causes the program to exit.
    Resizing the window reveals varying amounts of the label.
   </para>
   <para>
    In addition, example <link linkend="example-event-box">Event Box</link> shows how to change the cursor
    over a window. Every widget has an associated window of type &gdk-window;,
    which can be get with the function <ulink url="&gtk-widget-window;">
    <code>gtk-widget-window</code></ulink>. The function <ulink url="&gdk-window-cursor;">
    <code>gdk-window-cursor</code></ulink> sets a cursor for this &gdk-window;.
    A new cursor is created with the function
    <ulink url="&gdk-cursor-new-from-name;"><code>gdk-cursor-new-from-name</code></ulink>. The function
    takes two arguments. The first argument is the <ulink url="&gdk-display;">
    <code>gdk-display</code></ulink> object for which the cursor will be created. The second argument is a
    string with the name of the cursor. Look at the documentation of the function
    <ulink url="&gdk-cursor-new-from-name;"><code>gdk-cursor-new-from-name</code></ulink> for available
    cursor names. In example <link linkend="example-event-box">Event Box</link> the cursor with the name
    "pointer" is choosen. This cursor is associated to the &gdk-window;
    with the function <ulink url="&gdk-window-cursor;">
    <code>gdk-window-cursor</code></ulink>.
   </para>
   <example id="example-event-box">
    <title>Event Box</title>
    <programlisting>
(defun example-event-box ()
  (within-main-loop
    (let ((window (make-instance 'gtk-window
                                 :type :toplevel
                                 :title "Example Event Box"
                                 :default-height 150
                                 :border-width 24))
          (eventbox (make-instance 'gtk-event-box))
          (label (make-instance 'gtk-label
                                :ellipsize :end
                                :label
                                "Click here to quit this Example Event Box.")))
      (g-signal-connect window "destroy"
                        (lambda (widget)
                          (declare (ignore widget))
                          (leave-gtk-main)))
      ;; Set the available events for the event box
      (setf (gtk-widget-events eventbox) :button-press-mask)
      ;; Connect a signal handler to the eventbox
      (g-signal-connect eventbox "button-press-event"
                        (lambda (widget event)
                          (declare (ignore widget event))
                          (gtk-widget-destroy window)))
      ;; Add the label to the event box and the event box to the window
      (gtk-container-add eventbox label)
      (gtk-container-add window eventbox)
      ;; Realize the event box
      (gtk-widget-realize eventbox)
      ;; Set a new cursor for the event box
      (setf (gdk-window-cursor (gtk-widget-window eventbox))
            (gdk-cursor-new-from-name (gdk-display-default) "pointer"))
      ;; Show the window
      (gtk-widget-show-all window))))
    </programlisting>
   </example>
  </section>

  <section id="Text_Entries">
   <title>Text Entries</title>

   <figure id="figure-text-entry">
    <title>Text Entry</title>
    <mediaobject>
     <imageobject>
      <imagedata fileref="figures/text-entry256x106.gif" format="gif"></imagedata>
     </imageobject>
    </mediaobject>
   </figure>

   <para>
    The entry widget allows text to be typed and displayed in a single line text box.  The text may be set
    with function calls that allow new text to replace, prepend or append the current contents of the Entry
    widget.
   </para>
   <para>
    Create a new Entry widget with the function <ulink url="&gtk-entry-new;">
    <code>gtk-entry-new</code></ulink>.  The generic function <ulink url="&gtk-entry-text;">
    <code>gtk-entry-text</code></ulink> alters the text which is currently within the entry widget.  The
    function <ulink url="&gtk-entry-text;"><code>gtk-entry-text</code></ulink> sets the contents of the entry   
    widget, replacing the current contents.  Note that the class entry implements the editable interface
    which contains some more functions for manipulating the contents.
   </para>
   <para>
    The contents of the entry can be retrieved by using a call to the function <ulink url="&gtk-entry-text;">
    <code>gtk-entry-text</code></ulink>.  This is useful in the callback functions described below.
   </para>
   <para>
    If we do not want the contents of the entry to be changed by someone typing into it, we can change its
    editable state with the function <ulink url="&gtk-editable-editable;">
    <code>gtk-editable-editable</code></ulink>.  This function allows us to toggle the editable state of the
    entry widget by passing in a <code>T</code> or <code>NIL</code> value for the editable argument.
   </para>
   <para>
    If we are using the entry where we do not want the text entered to be visible, for example when a
    password is being entered, we can use the function <ulink url="&gtk-entry-visibility;">
    <code>gtk-entry-visibility</code></ulink>, which also takes a boolean flag.
   </para>
   <para>
    A region of the text may be set as selected by using the function
    <ulink url="&gtk-editable-select-region;"><code>gtk-editable-select-region</code></ulink>.  This would
    most often be used after setting some default text in an Entry, making it easy for the user to remove it.
   </para>
   <para>
    If we want to catch when the user has entered text, we can connect to the activate or changed signal.
    Activate is raised when the user hits the enter key within the entry widget.  Changed is raised when the
    text changes at all, e.g., for every character entered or removed.
   </para>
   <para>
    Example <link linkend="example-text-entry">Text Entry</link> is an example of using an entry widget.
   </para>
   <example id="example-text-entry">
    <title>Text Entry</title>
    <programlisting>
(defun example-text-entry ()
  (within-main-loop
    (let* ((window (make-instance 'gtk-window
                                  :type :toplevel
                                  :title "Example Text Entry"
                                  :default-width 250))
           (vbox (make-instance 'gtk-box :orientation :vertical))
           (hbox (make-instance 'gtk-box :orientation :horizontal))
           (entry (make-instance 'gtk-entry
                                 :text "Hello"
                                 :max-length 50))
           (pos (gtk-entry-text-length entry)))
      (g-signal-connect window "destroy"
                        (lambda (widget)
                          (declare (ignore widget))
                          (leave-gtk-main)))
      (g-signal-connect entry "activate"
                        (lambda (widget)
                          (declare (ignore widget))
                          (format t "Entry contents: ~A"
                                  (gtk-entry-text entry))))
      (gtk-editable-insert-text entry " world" pos)
      (gtk-editable-select-region entry 0 (gtk-entry-text-length entry))
      (gtk-box-pack-start vbox entry :expand t :fill t :padding 0)
      (let ((check (gtk-check-button-new-with-label "Editable")))
        (g-signal-connect check "toggled"
           (lambda (widget)
             (declare (ignore widget))
             (gtk-editable-set-editable
                                      entry
                                      (gtk-toggle-button-active check))))
        (gtk-box-pack-start hbox check))
      (let ((check (gtk-check-button-new-with-label "Visible")))
        (setf (gtk-toggle-button-active check) t)
        (g-signal-connect check "toggled"
           (lambda (widget)
             (declare (ignore widget))
             (setf (gtk-entry-visibility entry)
                   (gtk-toggle-button-active check))))
        (gtk-box-pack-start hbox check))
      (gtk-box-pack-start vbox hbox)
      (let ((button (gtk-button-new-with-label "Close")))
        (g-signal-connect button "clicked"
                          (lambda (widget)
                            (declare (ignore widget))
                            (gtk-widget-destroy window)))
        (gtk-box-pack-start vbox button))
      (gtk-container-add window vbox)
      (gtk-widget-show window))))
    </programlisting>
   </example>
  </section>

  <section id="Spin_Buttons">
   <title>Spin Buttons</title>
   <figure id="figure-spin-button">
    <title>Spin Button</title>
    <mediaobject>
     <imageobject>
      <imagedata fileref="figures/spin-button306x347.gif" format="gif"></imagedata>
     </imageobject>
    </mediaobject>
   </figure>
   <para>
    The spin button widget is generally used to allow the user to select a value from a range of numeric
    values.  It consists of a text entry box with up and down arrow buttons attached to the side.  Selecting
    one of the buttons causes the value to "spin" up and down the range of possible values.  The entry box
    may also be edited directly to enter a specific value.
   </para>
   <para>
    The spin button allows the value to have zero or a number of decimal places and to be incremented or
    decremented in configurable steps.  The action of holding down one of the buttons optionally results in
    an acceleration of change in the value according to how long it is depressed.
   </para>
   <para>
    The spin button uses an adjustment object to hold information about the range of values that the spin
    button can take. This makes for a powerful spin button widget.
   </para>
   <para>
    Recall that an adjustment object is created with the function <ulink url="&gtk-adjustment-new;">
    <code>gtk-adjustment-new</code></ulink>, which has the arguments <code>value</code>, <code>lower</code>,
    <code>step-increment</code>, <code>page-increment</code>, and <code>page-size</code>.  These properties
    of an adjustment are used by the spin button in the following way:
   </para>
   <table id="table-gtk-adjustment-properties" frame='all'>
    <title>Properties of GtkAdjustment</title>
    <tgroup cols='2' align='left' colsep='0' rowsep='0'>
     <thead>
      <row>
       <entry>Value&#x2001;&#x2001;&#x2001;&#x2001;&#x2001;</entry>
       <entry>Description</entry>
      </row>
     </thead>
     <tbody>
      <row>
       <entry valign="top"><code>value</code></entry>
       <entry valign="top">initial value for the Spin Button</entry>
      </row>
      <row>
       <entry valign="top"><code>lower</code></entry>
       <entry valign="top">lower range value</entry>
      </row>
      <row>
       <entry valign="top"><code>upper</code></entry>
       <entry valign="top">upper range value</entry>
      </row>
      <row>
       <entry valign="top"><code>step-increment</code></entry>
       <entry valign="top">value to increment/decrement when pressing mouse button 1 on a button</entry>
      </row>
      <row>
       <entry valign="top"><code>page-increment</code></entry>
       <entry valign="top">value to increment/decrement when pressing mouse button 2 on a button</entry>
      </row>
      <row>
       <entry valign="top"><code>page-size</code></entry>
       <entry valign="top">unused</entry>
      </row>
     </tbody>
    </tgroup>
   </table>
   <para>
    Additionally, mouse button 3 can be used to jump directly to the upper or lower values when used to
    select one of the buttons. A spin button is created with the function <ulink url="&gtk-spin-button-new;">
    <code>gtk-spin-button-new</code></ulink>, which as the arguments <code>adjustment</code>,
    <code>climb-rate</code>, and <code>digits</code>.
   </para>
   <para>
    The <code>climb-rate</code> argument take a value between 0.0 and 1.0 and indicates the amount of
    acceleration that the spin button has.  The <code>digits</code> argument specifies the number of decimal
    places to which the value will be displayed.
   </para>
   <para>
    A spin button can be reconfigured after creation using the function
    <ulink url="&gtk-spin-button-configure;"><code>gtk-spin-button-configure</code></ulink>.  The first
    argument specifies the spin button that is to be reconfigured.  The other arguments are as specified for
    the function <ulink url="&gtk-spin-button-new;"><code>gtk-spin-button-new</code></ulink>.
   </para>
   <para>
    The adjustment can be set and retrieved independently using the function
    <ulink url="&gtk-spin-button-adjustment;"><code>gtk-spin-button-adjustment</code></ulink>.
   </para>
   <para>
    The number of decimal places can also be altered using the function
    <ulink url="&gtk-spin-button-digits;"><code>gtk-spin-button-digits</code></ulink> and the value that a
    spin button is currently displaying can be changed using the function
    <ulink url="&gtk-spin-button-value;"><code>gtk-spin-button-value</code></ulink>.
   </para>
   <para>
    The current value of a spin button can be retrieved as either a floating point or integer value with the
    functions <ulink url="&gtk-spin-button-value;"><code>gtk-spin-button-value</code></ulink> and
    <ulink url="&gtk-spin-button-value-as-int;"><code>gtk-spin-button-value-as-int</code></ulink>.
   </para>
   <para>
    If you want to alter the value of a spin button relative to its current value, then the function
    <ulink url="&gtk-spin-button-spin;"><code>gtk-spin-button-spin</code></ulink> can be used, which has the
    three arguments <code>spin-button</code>, <code>direction</code>, and <code>increment</code>.  The
    argument <code>direction</code> is of the enumeration type <code>GtkSpinType</code>, which can take one
    of the values shown in table <link linkend="table-gtk-spin-type">GtkSpinType</link>.
   </para>
   <table id="table-gtk-spin-type" frame='all'>
    <title>Values of the type <code>GtkSpinType</code></title>
    <tgroup cols='2' align='left' colsep='0' rowsep='0'>
     <thead>
      <row>
       <entry>Value&#x2001;&#x2001;&#x2001;&#x2001;&#x2001;</entry>
       <entry>Description</entry>
      </row>
     </thead>
     <tbody>
      <row>
       <entry valign="top"><code>:step-forward</code></entry>
       <entry valign="top">Increment by the adjustments step increment.</entry>
      </row>
      <row>
       <entry valign="top"><code>:backward</code></entry>
       <entry valign="top">Decrement by the adjustments step increment.</entry>
      </row>
      <row>
       <entry valign="top"><code>:forward</code></entry>
       <entry valign="top">Increment by the adjustments page incremstent.</entry>
      </row>
      <row>
       <entry valign="top"><code>:page-backward</code></entry>
       <entry valign="top">Decrement by the adjustments page increment.</entry>
      </row>
      <row>
       <entry valign="top"><code>:home</code></entry>
       <entry valign="top">Go to the adjustments lower bound.</entry>
      </row>
      <row>
       <entry valign="top"><code>:end</code></entry>
       <entry valign="top">Go to the adjustments upper bound.</entry>
      </row>
      <row>
       <entry valign="top"><code>:user-defined</code></entry>
       <entry valign="top">Change by a specified amount.</entry>
      </row>
     </tbody>
    </tgroup>
   </table>
   <para>
    <code>:step-forward</code> and <code>:step-backward</code> change the value of the spin button by the
    amount specified by increment, unless increment is equal to 0, in which case the value is changed by the
    value of <code>step-increment</code> in the adjustment.
   </para>
   <para>
    <code>:page-forward</code> and <code>:page-backward</code> simply alter the value of the spin button by
    <code>increment</code>.
   </para>
   <para>
    <code>:home</code> sets the value of the spin button to the bottom of the adjustments range and
    <code>:end</code> sets the value of the spin button to the top of the adjustments range.
   </para>
   <para>
    <code>:user-defined</code> simply alters the value of the spin button by the specified amount.
   </para>
   <para>
    We move away from functions for setting and retrieving the range attributes of the spin button now, and
    move onto functions that affect the appearance and behavior of the spin button widget itself.
   </para>
   <para>
    The first of these functions is <ulink url="&gtk-spin-button-numeric;">
    <code>gtk-spin-button-numeric</code></ulink>, which is used to constrain the text box of the spin button
    such that it may only contain a numeric value.  This prevents a user from typing anything other than
    numeric values into the text box of a spin button.
   </para>
   <para>
    You can set whether a Spin Button will wrap around between the upper and lower range values with the
    function <ulink url="&gtk-spin-button-wrap;"><code>gtk-spin-button-wrap</code></ulink>.  You can set a
    spin button to round the value to the nearest <code>step-increment</code>, which is set within the
    adjustment object used with the spin button.  This is accomplished with the function
    <ulink url="&gtk-spin-button-snap-to-ticks;"><code>gtk-spin-button-snap-to-ticks</code></ulink>.
   </para>
   <para>
    The update policy of a spin button can be changed with the function
    <ulink url="&gtk-spin-button-update-policy;"><code>gtk-spin-button-update-policy</code></ulink>.  The
    possible values of policy are either <code>:always</code> or <code>:if-valid</code>.  These policies
    affect the behavior of a Spin Button when parsing inserted text and syncing its value with the values of
    the adjustment.
   </para>
   <para>
    In the case of <code>:if-valid</code> the spin button value only gets changed if the text input is a
    numeric value that is within the range specified by the adjustment.  Otherwise the text is reset to the
    current value.  In case of <code>:always</code> we ignore errors while converting text into a numeric
    value.
   </para>
   <para>
    Finally, you can explicitly request that a spin button update itself with the function
    <ulink url="&gtk-spin-button-update;"><code>gtk-spin-button-update</code></ulink>.
   </para>
   <example id="example-spin-button">
    <title>Spin Button</title>
    <programlisting>
(defun example-spin-button ()
  (within-main-loop
    (let ((window (make-instance 'gtk-window
                                 :type :toplevel
                                 :title "Example Spin Button"
                                 :default-width 300))
          (vbox (make-instance 'gtk-box
                               :orientatin :vertical
                               :homogeneous nil
                               :spacing 6
                               :border-width 12))
          (vbox1 (make-instance 'gtk-box
                                :orientation :vertical
                                :homogeneous nil
                                :spacing 0
                                :border-width 6))
          (vbox2 (make-instance 'gtk-box
                                :orientation :vertical
                                :homogeneous nil
                                :spacing 0
                                :boder-width 6))
          (hbox (make-instance 'gtk-box :orientation :horizontal))
          (frame1 (make-instance 'gtk-frame
                                 :label "Not accelerated"))
          (frame2 (make-instance 'gtk-frame
                                 :label "Accelerated"))
          (label (make-instance 'gtk-label
                                :label "0")))
      (g-signal-connect window "destroy"
                        (lambda (widget)
                          (declare (ignore widget))
                          (leave-gtk-main)))
      (let ((vbox (make-instance 'gtk-box :orientation :vertical))
            (spinner (make-instance 'gtk-spin-button
                                    :adjustment
                                    (make-instance 'gtk-adjustment
                                                   :value 1.0
                                                   :lower 1.0
                                                   :upper 31.0
                                                   :step-increment 1.0
                                                   :page-increment 5.0
                                                   :page-size 0.0)
                                    :climb-rate 0
                                    :digits 0
                                    :wrap t)))
        (gtk-box-pack-start vbox
                            (make-instance 'gtk-label
                                           :label "Day :"
                                           :xalign 0
                                           :yalign 0.5)
                            :expand nil)
        (gtk-box-pack-start vbox spinner :expand nil)
        (gtk-box-pack-start hbox vbox :padding 6))
      (let ((vbox (make-instance 'gtk-box :orientation :vertical))
            (spinner (make-instance 'gtk-spin-button
                                    :adjustment
                                    (make-instance 'gtk-adjustment
                                                   :value 1.0
                                                   :lower 1.0
                                                   :upper 12.0
                                                   :step-increment 1.0
                                                   :page-increment 5.0
                                                   :page-size 0.0)
                                    :climb-rate 0
                                    :digits 0
                                    :wrap t)))
        (gtk-box-pack-start vbox
                            (make-instance 'gtk-label
                                           :label "Month :"
                                           :xalign 0
                                           :yalign 0.5)
                            :expand nil)
        (gtk-box-pack-start vbox spinner :expand nil)
        (gtk-box-pack-start hbox vbox :padding 6))
      (let ((vbox (make-instance 'gtk-box :orientation :vertical))
            (spinner (make-instance 'gtk-spin-button
                                    :adjustment
                                    (make-instance 'gtk-adjustment
                                                   :value 1.0
                                                   :lower 1998.0
                                                   :upper 2100.0
                                                   :step-increment 1.0
                                                   :page-increment 100.0
                                                   :page-size 0.0)
                                    :climb-rate 0
                                    :digits 0
                                    :wrap t)))
        (gtk-box-pack-start vbox
                            (make-instance 'gtk-label
                                           :label "Year :"
                                           :xalign 0
                                           :yalign 0.5)
                            :expand nil)
        (gtk-box-pack-start vbox spinner :expand nil :fill t)
        (gtk-box-pack-start hbox vbox :padding 6))
      (gtk-box-pack-start vbox1 hbox :padding 6)
      (gtk-container-add frame1 vbox1)
      (gtk-box-pack-start vbox frame1)
      (setq hbox (make-instance 'gtk-box :orientation :horizontal))
      (let ((vbox (make-instance 'gtk-box :orientation :vertical))
            (spinner1 (make-instance 'gtk-spin-button
                                     :adjustment
                                     (make-instance 'gtk-adjustment
                                                    :value 1.0
                                                    :lower -10000.0
                                                    :upper  10000.0
                                                    :step-increment 0.5
                                                    :page-increment 100.0
                                                    :page-size 0.0)
                                     :climb-rate 1.0
                                     :digits 2
                                     :wrap t))
            (spinner2 (make-instance 'gtk-spin-button
                                     :adjustment
                                     (make-instance 'gtk-adjustment
                                                    :value 2
                                                    :lower 1
                                                    :upper 5
                                                    :step-increment 1
                                                    :page-increment 1
                                                    :page-size 0)
                                     :climb-rate 0.0
                                     :digits 0
                                     :wrap t)))
        (gtk-box-pack-start vbox
                            (make-instance 'gtk-label
                                           :label "Value :"
                                           :xalign 0
                                           :yalign 0.5)
                            :fill t)
        (gtk-box-pack-start vbox spinner1 :expand nil)
        (gtk-box-pack-start hbox vbox :padding 6)
        (g-signal-connect spinner2 "value-changed"
           (lambda (widget)
             (declare (ignore widget))
             (gtk-spin-button-set-digits
                               spinner1
                               (gtk-spin-button-get-value-as-int spinner2))))
        (setq vbox (make-instance 'gtk-box :orientation :vertical))
        (gtk-box-pack-start vbox
                            (make-instance 'gtk-label
                                           :label "Digits :"
                                           :xalign 0
                                           :yalign 0.5)
                            :expand nil)
        (gtk-box-pack-start vbox spinner2 :expand nil)
        (gtk-box-pack-start hbox vbox :padding 6)
        (gtk-box-pack-start vbox2 hbox :padding 6)
        (let ((check (make-instance 'gtk-check-button
                                    :label "Snap to 0.5-ticks"
                                    :active t)))
          (g-signal-connect check "clicked"
             (lambda (widget)
               (gtk-spin-button-set-snap-to-ticks
                                     spinner1
                                     (gtk-toggle-button-active widget))))
          (gtk-box-pack-start vbox2 check))
        (let ((check (make-instance 'gtk-check-button
                                    :label "Numeric only input mode"
                                    :active t)))
          (g-signal-connect check "clicked"
             (lambda (widget)
               (gtk-spin-button-set-numeric
                                     spinner1
                                     (gtk-toggle-button-active widget))))
          (gtk-box-pack-start vbox2 check))
        (gtk-container-add frame2 vbox2)
        (setq hbox (make-instance 'gtk-box :orientation :horizontal))
        (let ((button (gtk-button-new-with-label "Value as Int")))
          (g-signal-connect button "clicked"
             (lambda (widget)
               (declare (ignore widget))
               (setf (gtk-label-text label)
                     (format nil "~A"
                             (gtk-spin-button-get-value-as-int spinner1)))))
            (gtk-box-pack-start hbox button))
        (let ((button (gtk-button-new-with-label "Value as Float")))
          (g-signal-connect button "clicked"
             (lambda (widget)
               (declare (ignore widget))
               (setf (gtk-label-text label)
                     (format nil "~A"
                             (gtk-spin-button-value spinner1)))))
          (gtk-box-pack-start hbox button))
        (gtk-box-pack-start vbox2 hbox)
        (gtk-box-pack-start vbox2 label))
      (gtk-box-pack-start vbox frame2)
      (let ((button (make-instance 'gtk-button
                                   :label "Close")))
        (g-signal-connect button "clicked"
                          (lambda (widget)
                            (declare (ignore widget))
                            (gtk-widget-destroy window)))
        (gtk-box-pack-start vbox button))
      (gtk-container-add window vbox)
      (gtk-widget-show window))))
    </programlisting>
   </example>
  </section>

  <section id="Combo_Box" revision="2021-3-15">
   <title>Combo Box</title>

   <figure id="figure-combo-box">
    <title>Combo Box</title>
    <mediaobject>
     <imageobject>
      <imagedata fileref="figures/combo-box.png" format="png"></imagedata>
     </imageobject>
    </mediaobject>
   </figure>

   <para>
    A &gtk-combo-box; widget allows the user to choose from a list of valid choices. The &gtk-combo-box;
    widget displays the selected choice. When activated, the &gtk-combo-box; widget displays a popup which
    allows the user to make a new choice. The style in which the selected value is displayed, and the style
    of the popup is determined by the current theme. It may be similar to a Windows-style combo box.
   </para>
   <para>
    The &gtk-combo-box; widget uses the model-view pattern; the list of valid choices is specified in the
    form of a tree model, and the display of the choices can be adapted to the data in the model by using
    cell renderers, as you would in a tree view. This is possible since the &gtk-combo-box; widget
    implements the &gtk-cell-layout; interface. The tree model holding the valid choices is not restricted
    to a flat list, it can be a real tree, and the popup will reflect the tree structure.
   </para>
   <para>
    To allow the user to enter values not in the model, the &gtk_combo_box_has-entry; property allows the
    &gtk-combo-box; widget to contain a &gtk-entry; widget. This entry can be accessed by calling the
    function &gtk-bin-child; on the combo box.
   </para>
   <para>
    For a simple list of textual choices, the model-view API of the &gtk-combo-box; widget can be a bit
    overwhelming. In this case, the &gtk-combo-box-text; widget offers a simple alternative. Both
    the &gtk-combo-box; and the &gtk-combo-box-text; widget can contain an entry.
   </para>

   <example id="example-combo-box">
    <title>Combo Box</title>
   <programlisting xmlns:xi="http://www.w3.org/2001/XInclude">
<xi:include href="../demo/gtk-example/combo-box.lisp" parse="text"/>
   </programlisting>
   </example>

   <para>
    A &gtk-combo-box-text; widget is a simple variant of a &gtk-combo-box; widget that hides the model-view
    complexity for simple text-only use cases.
   </para>

   <figure id="figure-combo-box-text">
    <title>Combo Box Text</title>
    <mediaobject>
     <imageobject>
      <imagedata fileref="figures/combo-box-text.png" format="png"></imagedata>
     </imageobject>
    </mediaobject>
   </figure>

   <para>
    To create a &gtk-combo-box-text; widget, use the functions &gtk-combo-box-text-new; or
    &gtk-combo-box-text-new-with-entry;. You can add items to a &gtk-combo-box-text; widget with the
    functions &gtk-combo-box-text-append-text;, &gtk-combo-box-text-insert-text;
    or &gtk-combo-box-text-prepend-text; and remove options with the function &gtk-combo-box-text-remove;.
   </para>
   <para>
    If the &gtk-combo-box-text; widget contains an entry via the &gtk_combo_box_has-entry; property, its
    contents can be retrieved using the function &gtk-combo-box-text-active-text;. The entry itself can be
    accessed by calling the function &gtk-bin-child; on the combo box.
   </para>

   <example id="example-combo-box-text">
    <title>Combo Box Text</title>
   <programlisting xmlns:xi="http://www.w3.org/2001/XInclude">
<xi:include href="../demo/gtk-example/combo-box-text.lisp" parse="text"/>
   </programlisting>
   </example>
  </section>

  <section id="Tool Palette" revision="2021-3-15">
   <title>Tool Palette</title>

   <figure id="figure-tool-palette">
    <title>Tool Palette</title>
    <mediaobject>
     <imageobject>
      <imagedata fileref="figures/tool-palette.png" format="png"></imagedata>
     </imageobject>
    </mediaobject>
   </figure>

   <para>
    A &gtk-tool-palette; widget is similar to a &gtk-toolbar; widget but can contain a grid of items,
    categorized into groups. The user may hide or expand each group. As in a toolbar, the items may be
    displayed as only icons, as only text, or as icons with text.
   </para>
   <para>
    The tool palette items might be dragged or simply activated. For instance, the user might drag objects to
    a canvas to create new items there. Or the user might click an item to activate a certain brush size in a
    drawing application.
   </para>
   <para>
    A &gtk-tool-item-group; widget should be added to the tool palette via the function &gtk-container-add;,
    for instance like this:
   </para>
   <programlisting>
(let ((group-brushes (gtk-tool-item-group-new "Brushes")))
  (gtk-container-add palette group-brushes)
  ... )
   </programlisting>
   <para>
    &gtk-tool-item; widgets can then be added to the group. For instance, like this:
   </para>
   <programlisting>
(let ((button (gtk-tool-button-new icon "Big")))
  (setf (gtk-tool-button-tooltip-text button) "Big Brush")
  (gtk-tool-item-group-insert group-brushes button -1)
  ... )
   </programlisting>
   <para>
    You might then handle the &gtk-tool-button; widgets "clicked" signal. Alternatively, you could allow the
    item to be dragged to another widget, by calling the function &gtk-tool-palette-add-drag-dest; and then
    using the function &gtk-tool-palette-drag-item; in the other widget's "drag-data-received" signal handler.
   </para>

   <bridgehead renderas='sect3'>Drag and Drop</bridgehead>
   <para>
    Call the function &gtk-tool-palette-add-drag-dest; to allow items or groups to be dragged from the tool
    palette to a particular destination widget. You can then use the function &gtk-tool-palette-drag-item;
    to discover which &gtk-tool-item; widget or &gtk-tool-item-group; widget is being dragged. For instance,
    you might use this in your "drag-data-received" signal handler, to add a dropped item, or to show a
    suitable icon while dragging.
   </para>

   <bridgehead renderas='sect3'>Example Tool Palette</bridgehead>
   <para>
    This example adds a &gtk-tool-palette; widget and a &gtk-drawing-area; widget to a window and allows the
    user to drag icons from the tool palette to the drawing area. The tool palette contains several groups of
    items. The combo boxes allow the user to change the style and orientation of the tool palette.
   </para>

   <example id="example-tool-palette">
    <title>Tool Palette</title>
   <programlisting xmlns:xi="http://www.w3.org/2001/XInclude">
<xi:include href="../demo/gtk-example/tool-palette.lisp" parse="text"/>
   </programlisting>
   </example>
  </section>
 </chapter>

 <chapter id="Menus_and_Toolbars">
  <title>Menus and Toolbars</title>
  <para>
   This chapter is derived from Stewart Weiss's tutorial
   <ulink url="http://www.compsci.hunter.cuny.edu/~sweiss/course_materials/csci493.70/lecture_notes/GTK_menus.pdf">
   Menus and Toolbars in GTK</ulink>. The original code snippets have been translated to Lisp.
  </para>
  <para>
   GUI applications have menus and toolbars.  They are an important part of how the user interacts with the
   application.  Although menus and toolbars look like different things, they are both containers for widgets
   that, when clicked, result in the performance of actions.  Menus contain menu items, and toolbars usually
   contain buttons.  Although toolbars are actually more general than this in that they can contain arbitrary
   widgets, they are usually used to provide quick access to frequently used menu items.
  </para>

  <section id="Menus">
   <sectioninfo>
    <itermset>
     <indexterm zone="Menus">
      <primary>GtkMenuShell</primary>
     </indexterm>
     <indexterm zone="Menus">
      <primary>menu-shell, gtk-menu-shell</primary>
     </indexterm>
     <indexterm zone="Menus">
      <primary>GtkMenuBar</primary>
     </indexterm>
     <indexterm zone="Menus">
      <primary>menu-bar, gtk-menu-bar</primary>
     </indexterm>
     <indexterm zone="Menus">
      <primary>GtkMenu</primary>
     </indexterm>
     <indexterm zone="Menus">
      <primary>mneu, gtk-menu</primary>
     </indexterm>
     <indexterm zone="Menus">
      <primary>GtkMenuItem</primary>
     </indexterm>
     <indexterm zone="Menus">
      <primary>menu-item, gtk-menu-item</primary>
     </indexterm>
     <indexterm zone="Menus">
      <primary>GtkCheckMenuItem</primary>
     </indexterm>
     <indexterm zone="Menus">
      <primary>check-menu-item, gtk-check-menu-item</primary>
     </indexterm>
     <indexterm zone="Menus">
      <primary>GtkImageMenuItem</primary>
     </indexterm>
     <indexterm zone="Menus">
      <primary>image-menu-item, gtk-image-menu-item</primary>
     </indexterm>
     <indexterm zone="Menus">
      <primary>GtkSeparatorMenuItem</primary>
     </indexterm>
     <indexterm zone="Menus">
      <primary>separator-menu-itemm gtk-separator-menu-item</primary>
     </indexterm>
    </itermset>
   </sectioninfo>
   <title>Menus</title>
   <para>
    GTK knows several classes related to the creation of menus:
   </para>
   <variablelist>
    <varlistentry>
     <term><code>gtk-menu-shell</code></term>
     <listitem>
      A <ulink url="&gtk-menu-shell;"><code>gtk-menu-shell</code></ulink> is the abstract base class used
      to derive the <ulink url="&gtk-menu;"><code>gtk-menu</code></ulink> and <ulink url="&gtk-menu-bar;">
      <code>gtk-menu-bar</code></ulink> subclasses. A <ulink url="&gtk-menu-shell;">
      <code>gtk-menu-shell</code></ulink> is a container of &gtk-menu-item; objects arranged in a list which
      can be navigated, selected, and
      activated by the user to perform application functions.  A &gtk-menu-item;
      can have a submenu associated with it, allowing for nested
      hierarchical menus.
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><code>gtk-menu-bar</code></term>
     <listitem>
      The <ulink url="&gtk-menu-bar;"><code>gtk-menu-bar</code></ulink> is a subclass of
      <ulink url="&gtk-menu-shell;"><code>gtk-menu-shell</code></ulink> which contains one or more menu
      items.  The result is a standard menu bar which can hold many menu items.
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><code>gtk-menu</code></term>
     <listitem>
      A <ulink url="&gtk-menu;"><code>gtk-menu</code></ulink> is a <ulink url="&gtk-menu-shell;">
      <code>gtk-menu-shell</code></ulink> that implements a drop down menu consisting of a list of
      &gtk-menu-item; objects which can be navigated and
      activated by the user to perform application functions. A <ulink url="&gtk-menu;">
      <code>gtk-menu</code></ulink> is most commonly dropped down by activating a
       &gtk-menu-item; in a <ulink url="&gtk-menu-bar;">
      <code>gtk-menu-bar</code></ulink> or popped up by activating a &gtk-menu-item;
      in another <ulink url="&gtk-menu;"><code>gtk-menu</code></ulink>.
      Applications can display a <ulink url="&gtk-menu;"><code>gtk-menu</code></ulink> as a pop-up menu by
      calling the function <ulink url="&gtk-menu-popup;"><code>gtk-menu-popup</code></ulink>.
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><code>gtk-menu-item</code></term>
     <listitem>
      The &gtk-menu-item; widget and the derived widgets are
      the only valid childs for menus.  Their function is to correctly handle highlighting, alignment, events
      and submenus. As it derives from &gtk-bin; it can hold any
      valid child widget, although only a few are really useful.
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><code>gtk-check-menu-item</code></term>
     <listitem>
      A &gtk-check-menu-item; is a menu item that
      maintains the state of a boolean value in addition to a &gtk-menu-item;
      usual role in activating application code. A check box indicating
      the state of the boolean value is displayed at the left side of the &gtk-menu-item;.
      Activating the &gtk-menu-item;
      toggles the value.
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><code>gtk-image-menu-item</code></term>
     <listitem>
      A &gtk-image-menu-item; is a menu item which has
      an icon next to the text label. Note that the user can disable display of menu icons, so make sure to
      still fill in the text label.
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><code>gtk-separator-menu-item</code></term>
     <listitem>
      The <ulink url="&gtk-separator-menu-item;"><code>gtk-separator-menu-item</code></ulink> is a separator
      used to group items within a menu.  It displays a horizontal line with a shadow to make it appear
      sunken into the interface.
     </listitem>
    </varlistentry>
   </variablelist>

   <section id="Principles_of_Menus">

    <sectioninfo>
     <itermset>
      <indexterm zone="Principles_of_Menus">
       <primary>menu-item-submenu, gtk-menu-item-submenu</primary>
      </indexterm>
     </itermset>
    </sectioninfo>

    <title>Principles of Menus</title>
    <para>
     Menu creation and menu handling follows the following:
    </para>
    <itemizedlist>
     <listitem>
      Menus of the <ulink url="&gtk-menu;"><code>gtk-menu</code></ulink> class and menubars of the
      <ulink url="&gtk-menu-bar;"><code>gtk-menu-bar</code></ulink> class are containers.  They are dervid
      from the same abstract base class <ulink url="&gtk-menu-shell;"><code>gtk-menu-shell</code></ulink>.
     </listitem>
     <listitem>
      The only thing that can be put into a menu or a menubar is a menu item.
     </listitem>
     <listitem>
      Menus can be attached to menu items so that when the item is activated, the menu drops down or pops up.
      If a menu item is a child of a menubar, the menu attached to it drops down.  If it is a child of a
      menu, the menu attached to it pops up.
     </listitem>
     <listitem>
      Menu items are the only things that can be activated, and these emit an "activate" signal, which must
      be connected to a callback to handle the user's clicks on that item.  Although they emit other signals,
      this is the normally used.
     </listitem>
    </itemizedlist>
    <para>
     In essence, menus form a recursively defined hierarchy.  The root of this hierarchy is always a menubar.
     Usually menubars are horizontal, rectangular regions at the top of a window, but they can be vertical as
     well, and can be placed anywhere.  Those labels that can be seen in the menubar, such as "File", "Edit"
     or "Help", are menu items.  Menu items can have menus attached to them, so that when they get clicked,
     the menu appears.  Each of the menus attached to a menu item may have menu items that have menus
     attached to them, and these may have items that have menus attached to them, and so on.
    </para>
    <para>
     Use the term submenu refers to a menu that is attached to a menu item within another menu, but there is
     no special class of submenus; a submenu is just a menu.  Because a menu item always exists as a child of
     either a menu or a menubar, the menu that is attached to a menu item is always a submenu of something
     else.  This should make it easy to remember the fact that there is but a single way to attach a menu to
     a menu item with the generic function <ulink url="&gtk-menu-item-submenu;">
     <code>gtk-menu-item-submenu</code></ulink>.  The point is that the attached menu is of necessity a
     submenu of something else.
    </para>
   </section>

   <section id="Creating_Menus_by_Hand">
    <sectioninfo>
     <itermset>
      <indexterm zone="Creating_Menus_by_Hand">
       <primary>menu-item-new, gtk-menu-item-new</primary>
      </indexterm>
      <indexterm zone="Creating_Menus_by_Hand">
       <primary>menu-item-new-with-label, gtk-menu-item-new-with-label</primary>
      </indexterm>
      <indexterm zone="Creating_Menus_by_Hand">
       <primary>menu-item-new-with-mnemonic, gtk-menu-item-new-with-mnemonic</primary>
      </indexterm>
      <indexterm zone="Creating_Menus_by_Hand">
       <primary>menu-item-label, gtk-menu-item-label</primary>
      </indexterm>
      <indexterm zone="Creating_Menus_by_Hand">
       <primary>menu-shell-append, gtk-menu-shell-append</primary>
      </indexterm>
      <indexterm zone="Creating_Menus_by_Hand">
       <primary>menu-shell-prepend, gtk-menu-shell-prepend</primary>
      </indexterm>
      <indexterm zone="Creating_Menus_by_Hand">
       <primary>menu-shell-insert, gtk-menu-shell-insert</primary>
      </indexterm>
      <indexterm zone="Creating_Menus_by_Hand">
       <primary>separator-menu-item-new, gtk-separator-menu-item-new</primary>
      </indexterm>
     </itermset>
    </sectioninfo>
    <title>Creating Menus by Hand</title>
    <figure id="figure-menus-by-hand">
     <title>Creating Menus by Hand</title>
     <mediaobject>
      <imageobject>
       <imagedata fileref="figures/menus-by-hand.png" format="png"></imagedata>
      </imageobject>
     </mediaobject>
    </figure>
    <para>
     This method is called "by hand" because the menu is constructed in the same way that a typical house is
     constructed, by assembling the pieces and attaching them to each other, one by one.  The outline of the
     steps that must be taken is:
    </para>
    <orderedlist>
     <listitem>Create the menubar.</listitem>
     <listitem>Create the menu items that will be packed into the menubar.</listitem>
     <listitem>Pack the menu items into the menubar.</listitem>
     <listitem>Create the menus that the menu items will activate.</listitem>
     <listitem>Attach these submenus to the menu items.</listitem>
     <listitem>
      For each submenu (a) create the menu items that it will contain, and (b) pack these menu items into
      the submenu.
     </listitem>
    </orderedlist>
    <para>
     These steps are listed in a top-down sequence, but it is conceivable to carry them out in many different
     permutations.
    </para>
    <para>
     An empty menubar is created with the function <ulink url="&gtk-menu-bar-new;">
     <code>gtk-menu-bar-new</code></ulink> or the call <code>(make-instance 'gtk-menu-bar)</code>. The
     menubar itself should be added to its parent container with an appropriate packing function.  Typically
     the menubar is put at the top of the content area just below the top-level windows's title bar, so the
     usual sequence is
    </para>
    <programlisting>
(let ((vbox (gtk-box-new :vertical 0)))
  (let ((menu-bar (gtk-menu-bar-new)))
    (gtk-container-add vbox menu-bar))
  (gtk-container-add window vbox)
  ... )
    </programlisting>
    <para>
     For each menu in the menubar, a separate menu item is needed.  Regular menu items can be created with
     the functions <ulink url="&gtk-menu-item-new;"><code>gtk-menu-item-new</code></ulink>,
     <ulink url="&gtk-menu-item-new-with-label;"><code>gtk-menu-item-new-with-label</code></ulink>,
     <ulink url="&gtk-menu-item-new-with-mnemonic;"><code>gtk-menu-item-new-with-mnemonic</code></ulink>, or
     with the appropriate calls of the function <code>make-instance</code>.
    </para>
    <para>
     The first of these creates a menu item with no label; later the generic function
     <ulink url="&gtk-menu-item-label;"><code>gtk-menu-item-label</code></ulink> can be used to create a
     label for it.  The second and third functions create menu items with either a plain label or with a
     label and a mnemonic, just like is done with buttons.  There are four subclasses of menu items, among
     which are image menu items, which can contain an image instead of or in addition to a label.
    </para>
    <para>
     There are three different ways to pack menu items into menubars and menus; they are all methods of the
     <ulink url="&gtk-menu-shell;"><code>gtk-menu-shell</code></ulink> base class:
     <ulink url="&gtk-menu-shell-append;"><code>gtk-menu-shell-append</code></ulink>,
     <ulink url="&gtk-menu-shell-prepend;"><code>gtk-menu-shell-prepend</code></ulink>, and
     <ulink url="&gtk-menu-shell-insert;"><code>gtk-menu-shell-insert</code></ulink>.
    </para>
    <para>
     The second argument in all three is the menu item to be put into the container. The differences are
     probably obvious.  The append method adds the menu item to the end of the list of those already in the
     menu shell, whereas the prepend method inserts it before all of the items already in it.  The insert
     method takes an integer position as the third argument, which is the position in the item list where
     child is added. Positions are numbered from 0 to (n-1).  If an item is put into position k, then all
     items currently in the list at positions k through (n-1) are shifted downward in the list to make room
     for the new item.
    </para>
    <para>
     The following code fragment creates a few labeled menu items, and packs them into the menubar in
     left-to-right order:
    </para>
    <programlisting>
(let ((file-item (gtk-menu-item-new-with-label "File"))
      (view-item (gtk-menu-item-new-with-label "View"))
      (tools-item (gtk-menu-item-new-with-label "Tools"))
      (help-item (gtk-menu-item-new-with-label "Help")))
  (gtk-menu-shell-append menu-bar file-item)
  (gtk-menu-shell-append menu-bar view-item)
  (gtk-menu-shell-append menu-bar tools-item)
  (gtk-menu-shell-append menu-bar help-item)
  ... )
    </programlisting>
    <para>
     The next step is to create the menus that will be dropped down when these menu items are activated.
     Menus are created with the function @xurl{gtk-menu-new}.
    </para>
    <para>
     For the above menu items, four menus are created and attached to the menu items with the generic
     function <ulink url="&gtk-menu-item-submenu;"><code>gtk-menu-item-submenu</code></ulink>:
    </para>
    <programlisting>
(let ((file-menu (gtk-menu-new))
      (view-menu (gtk-menu-new))
      (tools-menu (gtk-menu-new))
      (help-menu (gtk-menu-new)))
  (setf (gtk-menu-item-submenu file-item) file-menu)
  (setf (gtk-menu-item-submenu view-item) view-menu)
  (setf (gtk-menu-item-submenu tools-item) tools-menu)
  (setf (gtk-menu-item-submenu help-item) help-menu)
  ... )
    </programlisting>
    <para>
     The next step is to create the menu items to populate each of the menus, and add them to these menus.
     In the example, the "File" menu will have an "Open" item, a "Close" item, and an "Exit" item.  Between
     the "Close" item and the "Exit" item a separator item is added.  Separators are members of the
     <ulink url="&gtk-separator-menu-item;"><code>gtk-separator-menu-item</code></ulink> class and are
     created with the function <ulink url="&gtk-separator-menu-item-new;">
     <code>gtk-separator-menu-item-new</code></ulink> or the call
     <code>(make-instance 'gtk-separator)</code>.
    </para>
    <para>
     The "File" menus's items will be simple labeled items.  The code to create them and pack them is:
    </para>
    <programlisting>
 (let ((open-item (gtk-menu-item-new-with-label "Open"))
       (close-item (gtk-menu-item-new-with-label "Close"))
       (exit-item (gtk-menu-item-new-with-label "Exit")))
   (gtk-menu-shell-append file-menu open-item)
   (gtk-menu-shell-append file-menu close-item)
   (gtk-menu-shell-append file-menu (gtk-separator-menu-item-new))
   (gtk-menu-shell-append file-menu exit-item)
   ... )
    </programlisting>
    <para>
     To create a menu that contains submenus does not involve anything other than descending a level in the
     menu hierarchy and repeating these steps.  To illustrate, a "Help" menu is designed so that it has two
     items, one of which is a menu item that, when activated, pops up a submenu.  The first two steps are
     to create the two menu items and pack the into the "Help" menu:
    </para>
    <programlisting>
(let ((query-item (gtk-menu-item-new-with-label "What's this?"))
      (about-help-item
        (gtk-menu-item-new-with-label "About this program")))
  (gtk-menu-shell-append help-menu query-item)
  (gtk-menu-shell-append help-menu (gtk-separator-menu-item-new))
  (gtk-menu-shell-append help-menu about-help-item)
  ... )
    </programlisting>
    <para>
     The next step is to create a submenu and attach it to the <code>about-help-item</code>:
    </para>
    <programlisting>
(let ((about-help-menu (gtk-menu-new)))
  (setf (gtk-menu-item-submenu about-help-item) about-help-menu)
  ... )
    </programlisting>
    <para>
     The last step is to create a submenu and attach it to the <code>about-help-menu</code>:
    </para>
    <programlisting>
(let ((about-tool-item (gtk-menu-item-new-with-label "About Tools"))
      (about-stuff-item
        (gtk-menu-item-new-with-label "About Other Stuff")))
  (gtk-menu-shell-append about-help-menu about-tool-item)
  (gtk-menu-shell-append about-help-menu about-stuff-item)
  ... )
    </programlisting>
    <para>
     The preceding steps create the menu items, but they are not yet connected to the "activate" signal.
     Menu items that have a submenu do not need to be connected to the "activate" signal; GTK arranges for
     that signal to open the submenu. But the others need to be connected.  For example, the "Exit" menu item
     is connected to a callback to quit the application with
    </para>
    <programlisting>
(g-signal-connect exit-item "activate"
                  (lambda (widget)
                    (declare (ignore widget))
                    (gtk-widget-destroy window))))
    </programlisting>
    <para>
     The following Lisp code shows a complete example for creating menus by hand. It includes all code
     snippets shown above. The output is shown in figure <link linkend="figure-menus-by-hand">
     Menus by hand</link>.
    </para>
    <example id="example-menus-by-hand">
     <title>Creating Menus by Hand</title>
     <programlisting>
(defun example-menus-by-hand ()
  (within-main-loop
    ;; We set the "gtk-shell-shows-menubar" property to NIL to display the
    ;; menubar by the application itself and not by the desktop environment.
    (setf (gtk-settings-gtk-shell-shows-menubar (gtk-settings-get-default))
          nil)
    (let ((window (make-instance 'gtk-window
                                 :type :toplevel
                                 :default-width 425
                                 :default-height 250
                                 :title "Example Menus by Hand"))
          ;; A vbox to put in a menu and a button
          (vbox (gtk-box-new :vertical 0)))
      ;; Create a menu bar and the menu items for the menu bar
      (let ((menu-bar (gtk-menu-bar-new))
            (file-item (gtk-menu-item-new-with-label "File"))
            (view-item (gtk-menu-item-new-with-label "View"))
            (tools-item (gtk-menu-item-new-with-label "Tools"))
            (help-item (gtk-menu-item-new-with-label "Help")))
        ;; Add the menu bar to the main container
        (gtk-container-add vbox menu-bar)
        ;; Add the menu items to the menu bar
        (gtk-menu-shell-append menu-bar file-item)
        (gtk-menu-shell-append menu-bar view-item)
        (gtk-menu-shell-append menu-bar tools-item)
        (gtk-menu-shell-append menu-bar help-item)
        ;; Create the menus for the menu items in the menu bar
        (let ((file-menu (gtk-menu-new))
              (view-menu (gtk-menu-new))
              (tools-menu (gtk-menu-new))
              (help-menu (gtk-menu-new)))
          ;; Attach the submenus to the items of the menu bar
          (setf (gtk-menu-item-submenu file-item) file-menu)
          (setf (gtk-menu-item-submenu view-item) view-menu)
          (setf (gtk-menu-item-submenu tools-item) tools-menu)
          (setf (gtk-menu-item-submenu help-item) help-menu)
          ;; Create items to put into the File menu
          (let ((open-item (gtk-menu-item-new-with-label "Open"))
                (close-item (gtk-menu-item-new-with-label "Close"))
                (exit-item (gtk-menu-item-new-with-label "Exit")))
            ;; Append the items to the File menu
            (gtk-menu-shell-append file-menu open-item)
            (gtk-menu-shell-append file-menu close-item)
            (gtk-menu-shell-append file-menu (gtk-separator-menu-item-new))
            (gtk-menu-shell-append file-menu exit-item)
            ;; Add a signal handler for exit-item
            (g-signal-connect exit-item "activate"
                              (lambda (widget)
                                (declare (ignore widget))
                                (gtk-widget-destroy window))))

          ;; The view and tools menus will be empty for now

          ;; Create items to put into the Help menu
          (let ((query-item (gtk-menu-item-new-with-label "What's this?"))
                (about-help-item (gtk-menu-item-new-with-label "Info")))
            ;; Append the items to the About Help Menu
            (gtk-menu-shell-append help-menu query-item)
            (gtk-menu-shell-append help-menu (gtk-separator-menu-item-new))
            (gtk-menu-shell-append help-menu about-help-item)
            ;; Create a submenu and items for about-help-item
            (let ((about-help-menu (gtk-menu-new))
                  (about-tool-item
                    (gtk-menu-item-new-with-label "About This"))
                  (about-more-item
                    (gtk-menu-item-new-with-label "About That")))
              ;; Attach the submenu to the about-help-item
              (setf (gtk-menu-item-submenu about-help-item) about-help-menu)
              ;; Append the items to the about-help-menu
              (gtk-menu-shell-append about-help-menu about-tool-item)
              (gtk-menu-shell-append about-help-menu about-more-item)))))
      (g-signal-connect window "destroy"
                        (lambda (widget)
                          (declare (ignore widget))
                          (leave-gtk-main)))
      (gtk-container-add window vbox)
      (gtk-widget-show-all window))))
     </programlisting>
    </example>
   </section>

   <section id="Pop-Up_Menus_for_Widgets">
    <sectioninfo>
     <itermset>
      <indexterm zone="Pop-Up_Menus_for_Widgets">
       <primary>menu-popup, gtk-menu-popup</primary>
      </indexterm>
     </itermset>
    </sectioninfo>
    <title>Pop-Up Menus for Widgets</title>
    <figure id="figure-menu-popup">
     <title>Creating a Pop-Up Menu</title>
     <mediaobject>
      <imageobject>
       <imagedata fileref="figures/menu-popup.png" format="png"></imagedata>
      </imageobject>
     </mediaobject>
    </figure>
    <para>
     The same techniques for creating menus rooted in a menubar applies to the creation of pop-up menus for
     other widgets.  For example, to create a button, which when the mouse button is pressed on it, would pop
     up a menu instead of taking some action, first the menu is created using the instructions above. Then a
     mouse button press event signal is connected to a callback that popped up the menu, using the function
     &g-signal-connect;.  To illustrate, a small pop-up
     menu is created and two menu items are packed into it.
    </para>
    <programlisting>
(let ((popup-menu (gtk-menu-new))
      (big-item (gtk-menu-item-new-with-label "Larger"))
      (small-item (gtk-menu-item-new-with-label "Smaller")))
  (gtk-menu-shell-append popup-menu big-item)
  (gtk-menu-shell-append popup-menu small-item)
  ... )
    </programlisting>
    <para>
     Next a callback is connected to the "button-press-event" signal.  The callback will be responsible for
     popping up the menu with the function <ulink url="&gtk-menu-popup;"><code>gtk-menu-popup</code></ulink>.
     This function displays a menu and makes it available for selection.  It exists precisely for the purpose
     of displaying context sensitive menus.
    </para>
    <para>
     The first argument of the function is the menu to pop-up.  All other arguments are keyword arguments
     with the keywords <code>:parent-menu-shell</code>, <code>:parent-menu-item</code>,
     <code>:position-func</code>, <code>:button</code>, and <code>:activate-time</code>.  For normal use the
     default values for most of the arguments can be accepted.
    </para>
    <para>
     The <code>:button</code> parameter should be the mouse button pressed to initiate the menu popup.  If
     the menu popup was initiated by something other than a mouse press, such as a mouse button release or a
     key-press, button should be 0.
    </para>
    <para>
     The API documentation states that the <code>:activate-time</code> parameter is used to conflict-resolve
     initiation of concurrent requests for mouse/keyboard grab requests.  To function properly, this needs to
     be the time stamp of the user event that caused the initiation of the popup.
    </para>
    <para>
     Putting this together, the callback should be:
    </para>
    <programlisting>
(g-signal-connect button "button-press-event"
   (lambda (widget event)
     (declare (ignore widget))
     (gtk-menu-popup popup-menu
                     :button (gdk-event-button-button event)
                     :activate-time (gdk-event-button-time event))
     t))
    </programlisting>
    <para>
     The following code shows a complete example for creating a pop-up menu. It includes the code shown
     above.  The output is shown in figure <link linkend="figure-menu-popup">Menu Popup</link>.
    </para>
    <example id="example-menu-popup">
     <title>Creating Pop-Up Menus</title>
     <programlisting>
(defun example-menu-popup ()
  (within-main-loop
    (let ((window (make-instance 'gtk-window
                                 :type :toplevel
                                 :default-width 250
                                 :default-height 150
                                 :title "Example Popup Menu"))
          (button (gtk-button-new-with-label "Click me")))
      ;; Create pop-up menu for button
      (let ((popup-menu (gtk-menu-new))
            (big-item (gtk-menu-item-new-with-label "Larger"))
            (small-item (gtk-menu-item-new-with-label "Smaller")))
        (gtk-menu-shell-append popup-menu big-item)
        (gtk-menu-shell-append popup-menu small-item)
        (gtk-widget-show-all popup-menu)
        ;; Signal handler to pop up the menu
        (g-signal-connect button "button-press-event"
           (lambda (widget event)
             (gtk-menu-popup popup-menu
                             :button (gdk-event-button-button event)
                             :activate-time (gdk-event-button-time event))
             t)))
      (g-signal-connect window "destroy"
                        (lambda (widget)
                          (declare (ignore widget))
                          (leave-gtk-main)))
      (gtk-container-add window button)
      (gtk-widget-show-all window))))
     </programlisting>
    </example>
   </section>
  </section>

  <section id="Toolbars">
   <title>Toolbars</title>
   <figure id="figure-toolbar-by-hand">
    <title>Creating a Toolbar</title>
    <mediaobject>
     <imageobject>
      <imagedata fileref="figures/toolbar-by-hand.png" format="png"></imagedata>
     </imageobject>
    </mediaobject>
   </figure>
   <para>
    Toolbars provide quick access to commonly used actions.  They are containers that should be populated
    with instances of the &gtk-tool-item; class. Usually you
    will insert toolbar buttons into a toolbar.  Toolbar buttons belong to the
    &gtk-tool-button; class, which is a sub class of
    &gtk-tool-item;.  There are also two subclasses of the
    tool button class: <ulink url="&gtk-menu-tool-button;"><code>gtk-menu-tool-button</code></ulink> and
    <ulink url="&gtk-toggle-tool-button;"><code>gtk-toggle-tool-button</code></ulink>, which has a subclass
    &gtk-radio-tool-button;.
   </para>
   <para>
    A toolbar is created with only a single function <ulink url="&gtk-toolbar-new;">
    <code>gtk-toolbar-new</code></ulink>.  Once it is created, tool items can be inserted into it, using the
    function <ulink url="&gtk-toolbar-insert;"><code>gtk-toolbar-insert</code></ulink>.
   </para>
   <para>
    This inserts the tool item at position <code>pos</code>.  If <code>pos</code> is 0 the item is prepended
    to the start of the toolbar. If <code>pos</code> is negative, the item is appended to the end of the
    toolbar.  Therefore, if items are inserted successively into a toolbar passing -1 as <code>pos</code>,
    they will appear in the toolbar in left to right order.
   </para>
   <para>
    Although tool items can be created with the function <ulink url="&gtk-tool-item-new;">
    <code>gtk-tool-item-new</code></ulink>; we will have little use for this function, as we will be putting
    only buttons and separators into our toolbars.  Each of these has its own specialized constructors.  To
    create a toolbar button, you can use any of two different methods: <ulink url="&gtk-tool-button-new;">
    <code>gtk-tool-button-new</code></ulink> or <ulink url="&gtk-tool-button-new-from-stock;">
    <code>gtk-tool-button-new-from-stock</code></ulink>.
   </para>
   <para>
    The first method requires that you supply a custom icon and label; the second lets you pick a stock ID.
    You can use any stock item from the documentation. As we have not yet covered how to create icons, we
    will stay with the second method in the examples that follow.  The following code fragment creates a
    toolbar and a few toolbar buttons using stock items and puts them into a toolbar.
   </para>
   <programlisting>
(let ((toolbar (gtk-toolbar-new))
      (new-button (gtk-tool-button-new-from-stock "gtk-new"))
      (open-button (gtk-tool-button-new-from-stock "gtk-open"))
      (save-button (gtk-tool-button-new-from-stock "gtk-save"))
      (quit-button (gtk-tool-button-new-from-stock "gtk-quit"))
      (separator (make-instance 'gtk-separator-tool-item
                                :draw nil)))
  (gtk-toolbar-insert toolbar new-button -1)
  (gtk-toolbar-insert toolbar open-button -1)
  (gtk-toolbar-insert toolbar save-button -1)
  (gtk-toolbar-insert toolbar separator -1)
  (gtk-toolbar-insert toolbar quit-button -1)
  ... )
   </programlisting>
   <para>
    You can create separator items using the function <ulink url="&gtk-separator-tool-item-new;">
    <code>gtk-separator-tool-item-new</code></ulink>.  This creates a vertical separator in horizontal
    toolbar.  If for some reason you want the buttons to the right of the separator to be grouped at the far
    end of the toolbar, you can use the separator like a "spring" to push them to that end by setting its
    "expand" property to <emphasis>true</emphasis> and its "draw" property to <code>nil</code>, using the
    sequence
   </para>
   <programlisting>
(let (...
      (separator (gtk-separator-tool-item-new))
      ...)
  (setf (gtk-separator-tool-item-draw separator) nil)
  (setf (gtk-tool-item-expand separator) t)
  ... )
   </programlisting>
   <para>
    The "expand" property is inherited from &gtk-tool-item;  
    whereas the "draw" property is specific to the separator.  Because "draw" is a property of the
    <ulink url="&gtk-separator-tool-item;"><code>gtk-separator-tool-item</code></ulink> class, we can save
    one function call, when using the function <code>make-instance</code> to create a
    <ulink url="&gtk-separator-tool-item;"><code>gtk-separator-tool-item</code></ulink> widget.
   </para>
   <programlisting>
(let (...
      (separator (make-instance 'gtk-separator-tool-item
                                :draw nil))
      ...)
  (setf (gtk-tool-item-expand separator) t)
  ... )
   </programlisting>
   <para>
    Toolbar buttons are buttons, not items, and therefore they emit a "clicked" signal.  To respond to button
    clicks, connect a callback to the button as if it were an ordinary button, such as
   </para>
   <programlisting>
(g-signal-connect quit-button "clicked"
                  (lambda (widget)
                    (declare (ignore widget))
                    (gtk-widget-destroy window)))
   </programlisting>
   <para>
    A complete program showing how to create a simple toolbar using this manual method is shown in the
    following example. The output is shown in figure <link linkend="figure-toolbar-by-hand">
    Toolbar by hand</link>.
   </para>
   <example id="example-toolbar-by-hand">
    <title>Creating a Toolbar</title>
    <programlisting>
(defun example-toolbar-by-hand ()
  (within-main-loop
    (let ((window (make-instance 'gtk-window
                                 :type :toplevel
                                 :default-width 250
                                 :default-height 150
                                 :title "Example Toolbar"))
          ;; A vbox to put a menu and a button in
          (vbox (gtk-box-new :vertical 0)))
      (let ((toolbar (gtk-toolbar-new))
            (new-button (gtk-tool-button-new-from-stock "gtk-new"))
            (open-button (gtk-tool-button-new-from-stock "gtk-open"))
            (save-button (gtk-tool-button-new-from-stock "gtk-save"))
            (quit-button (gtk-tool-button-new-from-stock "gtk-quit"))
            (separator (make-instance 'gtk-separator-tool-item
                                      :draw nil)))
        (gtk-toolbar-insert toolbar new-button -1)
        (gtk-toolbar-insert toolbar open-button -1)
        (gtk-toolbar-insert toolbar save-button -1)
        (gtk-toolbar-insert toolbar separator -1)
        (gtk-toolbar-insert toolbar quit-button -1)
        (setf (gtk-tool-item-expand separator) t)
        (gtk-box-pack-start vbox toolbar :fill nil :expand nil :padding 3)
        ;; Connect a signal handler to the quit button
        (g-signal-connect quit-button "clicked"
                          (lambda (widget)
                            (declare (ignore widget))
                            (gtk-widget-destroy window))))
      (g-signal-connect window "destroy"
                        (lambda (widget)
                          (declare (ignore widget))
                          (leave-gtk-main)))
      (gtk-container-add window vbox)
      (gtk-widget-show-all window))))
    </programlisting>
   </example>
  </section>

  <section id="GtkUIManager">
   <title>GtkUIManager</title>
   <para>
    A <ulink url="&gtk-ui-manager;"><code>gtk-ui-manager</code></ulink> is an object that can dynamically
    construct a user interface consisting of menus and toolbars from a UI description.  A UI description is a
    specification of what menu and toolbar widgets should be present in an application and is described in an
    XML format. A <ulink url="&gtk-ui-manager;"><code>gtk-ui-manager</code></ulink> makes it possible to
    change menus and toolbars dynamically using what is called UI merging.
   </para>

   <section id="Actions">
    <title>Actions</title>
    <para>
     The principal objects manipulated by a <ulink url="&gtk-ui-manager;"><code>gtk-ui-manager</code></ulink>
     are actions, which are instances of the <ulink url="&gtk-action;"><code>gtk-action</code></ulink> class.
     Actions represent operations that the user can perform.  Associated with an action are
    </para>
    <itemizedlist>
     <listitem>a callback function</listitem>
     <listitem>its name</listitem>
     <listitem>a label</listitem>
     <listitem>an accelerator</listitem>
     <listitem>a flag indicating whether the label is a stock ID</listitem>
     <listitem>a tooltip</listitem>
     <listitem>a toolbar label</listitem>
     <listitem>a flag indicating whether it is sensitive</listitem>
     <listitem>a flag indicating whether it is visible</listitem>
    </itemizedlist>
    <para>
     The callback function is the function that is executed when the action is activated.  The action name is
     how it is referred to, not what appears in a menu item or toolbar button, which is its label.  Actions
     can have associated keyboard accelerators and tooltips.  Their visibility and sensitivity can be
     controlled as well.  The idea is that you can create actions that the <ulink url="&gtk-ui-manager;">
     <code>gtk-ui-manager</code></ulink> can bind to proxies such as menu items and toolbar buttons.
    </para>
    <para>
     The <ulink url="&gtk-action;"><code>gtk-action</code></ulink> class has methods to create icons, menu
     items and toolbar items representing itself, as well as get and set methods for accessing and changing
     its properties.
    </para>
    <para>
     The <ulink url="&gtk-action;"><code>gtk-action</code></ulink> class also has two subclasses:
     <ulink url="&gtk-toggle-action;"><code>gtk-toggle-action</code></ulink> and
     <ulink url="&gtk-recent-action;"><code>gtk-recent-action</code></ulink>.  The
     <ulink url="&gtk-toggle-action;"><code>gtk-toggle-action</code></ulink> class has a
     &gtk-radio-action; subclass.  These correspond to
     toggle buttons and radio buttons respectively.
    </para>
   </section>

   <section id="UI_Definitions">
    <title>UI Definitions</title>
    <para>
     You can specify the set user interface action elements in your application with an XML description
     called a UI definition.  A UI definition is a textual description that represents the actions and the
     widgets that will be associated with them.  It must b e bracketed by the pair of tags
     <code>&#x3c;ui></code> and <code>&#x3c;/ui></code>.  Within these tags you describe your user interface
     in a hierarchical way, by defining menubars, which would contain menus, which in turn contain menus and
     menu items, toolbars, which would contain tool items, and pop-up menus, which can contain menus and menu
     items.  The set of tags that can be used in these UI definitions, with their descriptions and
     attributes, is
    </para>
    <table frame='all'>
     <tgroup cols='4' align='left' colsep='0' rowsep='0'>
      <thead>
       <row>
        <entry>Tag</entry>
        <entry>Description</entry>
        <entry>Attributes</entry>
        <entry>Closing Tag</entry>
       </row>
      </thead>
      <tbody>
       <row>
        <entry valign="top"><code>&#x3c;menubar></code></entry>
        <entry valign="top"><code>gtk-menu-bar</code></entry>
        <entry valign="top">name, action</entry>
        <entry valign="top">yes</entry>
       </row>
       <row>
        <entry valign="top"><code>&#x3c;toolbar></code></entry>
        <entry valign="top"><code>gtk-toolbar</code></entry>
        <entry valign="top">name, action</entry>
        <entry valign="top">yes</entry>
       </row>
       <row>
        <entry valign="top"><code>&#x3c;popup></code></entry>
        <entry valign="top">toplevel <code>gtk-menu</code></entry>
        <entry valign="top">name, action, accelerators</entry>
        <entry valign="top">yes</entry>
       </row>
       <row>
        <entry valign="top"><code>&#x3c;menu></code></entry>
        <entry valign="top"><code>gtk-menu</code> attached to a menu item</entry>
        <entry valign="top">name, action, position</entry>
        <entry valign="top">yes</entry>
       </row>
       <row>
        <entry valign="top"><code>&#x3c;menuitem></code></entry>
        <entry valign="top"><code>gtk-menu-item</code> subclass, the exact type depends on the action</entry>
        <entry valign="top">name, action, position, always-show-image</entry>
        <entry valign="top">no</entry>
       </row>
       <row>
        <entry valign="top"><code>&#x3c;toolitem></code></entry>
        <entry valign="top"><code>gtk-tool-item</code> subclass, the exact type depends on the action</entry>
        <entry valign="top">name, action, position</entry>
        <entry valign="top">no</entry>
       </row>
       <row>
        <entry valign="top"><code>&#x3c;separator></code></entry>
        <entry valign="top">
         <code>gtk-separator-menu-item</code> or <code>gtk-separator-tool-item</code>
        </entry>
        <entry valign="top">name, action, expand</entry>
        <entry valign="top">no</entry>
       </row>
       <row>
        <entry valign="top"><code>&#x3c;accelerator></code></entry>
        <entry valign="top">keyboard accelerator</entry>
        <entry valign="top">name, action</entry>
        <entry valign="top">no</entry>
       </row>
       <row>
        <entry valign="top"><code>&#x3c;placeholder></code></entry>
        <entry valign="top">placeholder for dynamically adding an item</entry>
        <entry valign="top">name, action</entry>
        <entry valign="top">yes</entry>
       </row>
      </tbody>
     </tgroup>
    </table>

    <bridgehead renderas='sect3'>Example</bridgehead>
    <para>
     The following example shows a UI definition of a menubar and its submenus.
    </para>
    <programlisting>
&#x3c;ui>
  &#x3c;menubar name='MainMenu'>
    &#x3c;menu name='File' action='FileMenu'>
      &#x3c;menuitem name='Open'action='Open' always-show-image='true'/>
      &#x3c;menuitem name='Close' action='Close' always-show-image='true'/>
      &#x3c;separator/>
      &#x3c;menuitem name='Exit' action='Exit'/>
    &#x3c;/menu>
    &#x3c;menu action='ViewMenu'>
      &#x3c;menuitem name='ZoomIn' action='ZoomIn'/>
      &#x3c;menuitem name='ZoomOut' action='ZoomOut'/>
      &#x3c;separator/>
      &#x3c;menuitem name='FullScreen' action='FullScreen'/>
      &#x3c;separator/>
      &#x3c;menuitem name='JustifyLeft' action='JustifyLeft'/>
      &#x3c;menuitem name='JustifyCenter' action='JustifyCenter'/>
      &#x3c;menuitem name='JustifyRight' action='JustifyRight'/>
      &#x3c;menu action='IndentMenu'>
        &#x3c;menuitem action='Indent'/>
        &#x3c;menuitem action='Unindent'/>
      &#x3c;/menu>
    &#x3c;/menu>
  &#x3c;/menubar>
&#x3c;/ui>
    </programlisting>

    <bridgehead renderas='sect3'>Notes</bridgehead>
    <itemizedlist>
     <listitem>
      Some tags must have a closing tag and some do not. Those with no closing tag are
      <code>&#x3c;menuitem></code>, <code>&#x3c;toolitem></code>, <code>&#x3c;separator></code>, and
      <code>&#x3c;accelerator></code>. A tag that does not have a closing tag must have a forward slash
      preceding its right bracket: <code>/></code>.  All other tags can have content.
     </listitem>
     <listitem>
      All attribute values are plain text strings.
     </listitem>
     <listitem>
      All UI elements have a name and action attribute. The name is optional; if a name is not specified, the
      action is used as its own name. If for some reason, neither the name nor the action attribute are
      specified, the name of the element is used when referring to it. The name and action attributes must
      not contain "/" characters after parsing, nor double quotes.
     </listitem>
     <listitem>
      Menus, menu items, and toolitems have a position attribute with two possible values: "top" and
      "bottom". If this attribute is missing, its default value of "bottom" is used. This attribute
      determines where the element is placed relative to its siblings. If position="top" then when it is
      added to the parent container, it will be placed before its siblings, meaning to the left in a
      horizontal container or above the siblings in a vertical container. If it is "bottom" then it will be
      placed to the right of the siblings or below them in horizontal and vertical containers respectively.
     </listitem>
     <listitem>
      The elements are added to the UI interface in the order in which they appear in the XML string. In the
      above example, the JustifyLeft action precedes the JustifyCenter action, so the former will appear
      above the latter. If however, the UI was defined as follows:
      <programlisting>
&#x3c;menuitem name='JustifyLeft' action='JustifyLeft' position='top'/>
&#x3c;menuitem name='JustifyCenter action='JustifyCenter' position='top'/>
&#x3c;menuitem name='JustifyRight' action='JustifyRight' position='top'/>
      </programlisting> 
      then they would appear in the order
      <programlisting>
JustifyRight
JustifyCenter
JustifyLeft
      </programlisting>
      because each time the element is inserted, the position='top' attribute forces it to be above its
      siblings. The 'top' attribute converts the packing into a stack push operation in effect.
     </listitem>
     <listitem>
      Menu items have a "always-show-image" attribute with two possible values: "true" and "false". If this
      attribute is true, then menu item icons will always be visible, overriding any user settings in the
      desktop environment.
     </listitem>
     <listitem>
      Separators can have an expand attribute, with the value "true" or "false". If it is set to "true" then
      the separator will expand to take up extra space in the parent container and become invisible.
      Otherwise it is drawn as a thin line, depending on the user's theme.
     </listitem>
     <listitem>
      Submenus are created in a different way using the XML than they are when constructing these
      programmatically. Remember that submenus are attached to menu items, which are contained in the parent
      menu. Here, a <code>&#x3c;menu></code> element can be a direct child of a parent
      <code>&#x3c;menu></code> element. In the example above, the menu whose action is 'IndentMenu' is a
      child of the 'ViewMenu'.
     </listitem>
     <listitem>
      Placeholders are merged into their parent containers invisibly. If a placeholder has child elements X,
      Y, and Z, these will be at the same level of the tree as the placeholder itself. An example later will
      illustrate the utility of this feature.
     </listitem>
     <listitem>
      Finally, observe the hierarchy implicit in the UI definition. As a matter of style, you should indent
      these using standard rules of indentation, to make them easier to read.
     </listitem>
    </itemizedlist>
    <para>
     We can create a toolbar definition in a similar way:
    </para>
    <programlisting>
&#x3c;ui>
  &#x3c;toolbar name='ToolBar' action="ToolBarAction">
    &#x3c;placeholder name="ExtraToolItems">
      &#x3c;separator/>
      &#x3c;toolitem name="ZoomIn"action="ZoomIn"/>
      &#x3c;toolitem name="ZoomOut"action="ZoomOut"/>
      &#x3c;separator/>
      &#x3c;toolitem name='FullScreen' action='FullScreen'/>
      &#x3c;separator/>
      &#x3c;toolitem name='JustifyLeft' action='JustifyLeft'/>
      &#x3c;toolitem name='JustifyCenter' action='JustifyCenter'/>
      &#x3c;toolitem name='JustifyRight' action='JustifyRight'/>
    &#x3c;/placeholder>
  &#x3c;/toolbar>
&#x3c;/ui>
    </programlisting>
    <para>
     Notice that the tool items have the same action names as some of the menu items. This is how you can
     create multiple proxies for the same action. When the <ulink url="&gtk-ui-manager;">
     <code>gtk-ui-manager</code></ulink> loads these descriptions, and you take the appropriate steps in your
     program, they will be connected to the same callback functions.
    </para>
    <para>
     Notice also that there is a placeholder in the toolbar defined above. We can use that placeholder to
     dynamically add more tool items in that position. It does not occupy space in the toolbar widget; it
     just marks a position to be accessed, so there is no downside to putting these placeholders into the UI
     definition.
    </para>
   </section>

   <section id="Actions_Groups">
    <title>Actions Groups</title>
    <para>
     Actions are organized into action groups. An action group is essentially a map from names to
     <ulink url="&gtk-action;"><code>gtk-action</code></ulink> objects. Action groups are the easiest means
     for adding actions to a UI manager object.
    </para>
    <para>
     In general, related actions should be placed into a single group. More precisely, since the UI manager
     can add and remove actions as groups, if the interface is supposed to change dynamically, then all
     actions that should be available in the same state of the application should be in the same group. It
     is typical that multiple action groups are defined for a particular user interface. Most nontrivial
     applications will make use of multiple groups. For example, in an application that can play media files,
     when a media file is open, the playback actions (play, pause, rewind, etc.) would be in a group that
     could be added and removed as needed.
    </para>
   </section>

   <section id="Creating_the_UI">
    <title>Creating the UI</title>
    <para>
     The basic steps in creating the UI are to
    </para>
    <orderedlist>
     <listitem>
      Define the UI in an XML format, either in a separate file or in a constant string within the source
      code.
     </listitem>
     <listitem>Create the actions and action groups.</listitem>
     <listitem>Create a UI manager.</listitem>
     <listitem>Add the action groups to the UI manager.</listitem>
     <listitem>
      Extract the accelerators from the UI manager and add them to the top-level window.
     </listitem>
     <listitem>Add the UI definition to the UI manager from the file or string.</listitem>
     <listitem>
      Get the menubar and toolbar widgets from the UI manager and pack them into the window.
     </listitem>
     <listitem>Create the callbacks referenced in the action objects created in step 2.</listitem>
    </orderedlist>
    <para>
     We will next describe how to program each of steps 2 through 7.
    </para>

    <bridgehead>Creating Actions and Action Groups</bridgehead>
    <para>
     The function to create an action group is <ulink url="&gtk-action-group-new;">
     <code>gtk-action-group-new</code></ulink>. The name argument can be used by various methods for
     accessing this particular action group. It should reflect what this particular group's purpose or common
     feature is. Actions are added to an action group in one of two ways.  You can add them one at a time
     with the function <ulink url="&gtk-action-group-add-action;">
     <code>gtk-action-group-add-action</code></ulink>, or as a list of related actions with the function
     <ulink url="&gtk-action-group-add-actions;"><code>gtk-action-group-add-actions</code></ulink>.
    </para>
    <para>
     The problem with the first method is that it is tedious to add actions one by one, and that this method
     does not provide a means to add the accelerators for the actions without additional steps. Even if there
     is just a single action in the group, it is more convenient to use the second function. To use the
     function <ulink url="&gtk-action-group-add-actions;"><code>gtk-action-group-add-actions</code></ulink>,
     you first have to create a list of action entries, which looks like the following example:
    </para>
    <programlisting>
(list
  (list &#x3c;name> &#x3c;stock-id> &#x3c;label> &#x3c;accelerator> &#x3c;tooltip> &#x3c;callback>)
  ... )
    </programlisting>
    <para>
     The members of the list have the following meanings:
    </para>
    <variablelist>
     <varlistentry>
      <term>name</term>
      <listitem>The name of the action.</listitem>
     </varlistentry>
     <varlistentry>
      <term>stock-id</term>
      <listitem>The stock ID for the action, or the name of an icon from the icon theme.</listitem>
     </varlistentry>
     <varlistentry>
      <term>label</term>
      <listitem>
       The label for the action. This field should typically be marked for translation, see the function
       <ulink url="&gtk-action-group-set-translation-domain;">
       <code>gtk-action-group-set-translation-domain</code></ulink>. If label is <code>nil</code>, the label
       of the stock item with ID <code>stock-id</code> is used.
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>accelerator</term>
      <listitem>
       The accelerator for the action, in the format understood by the function
       <ulink url="&gtk-accelerator-parse;"><code>gtk-accelerator-parse</code></ulink>.
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>tooltip</term>
      <listitem>
       The tooltip for the action. This field should typically be marked for translation, see the function
       <ulink url="&gtk-action-group-set-translation-domain;">
       <code>gtk-action-group-set-translation-domain</code></ulink>.
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>callback</term>
      <listitem>
       The function to call when the action is activated.
      </listitem>
     </varlistentry>
    </variablelist>

    <para>
     The <code>name</code> must match the name of the action to which it corresponds in the UI  definition.
     The <code>stock-id</code> can be <code>nil</code>, as can the <code>label</code>. The
     <code>accelerator</code> syntax is very flexible. You can specify control keys, function keys and even
     ordinary characters, for example, using "&#x3c;Control>a", "Ctrl>a","&#x3c;ctrl>a", or
     "&#x3c;Shift>&#x3c;Alt>F1", "&#x3c;Release>z", or "minus", to name a few. If you use a stock item, it is
     not necessary to supply an accelerator, unless you want to override the default one. The
     <code>tooltip</code> is a string that will appear when the cursor hovers over the proxy for this action
     entry.
    </para>
    <para>
     Below is an example of a declaration of a small list of action entries.
    </para>
    <programlisting>
(defvar file-entries
        (list (list "FileMenu"
                    nil
                    "_File")
              (list "Open"
                    "gtk-open"
                    "_Open"
                    "&#x3c;control>O"
                    "Open a file"
                    #'on-open-file)
              (list "Close"
                    "gtk-close"
                    "_Close"
                    "&#x3c;control>W"
                    "Close a file" #'on-close-file)
              (list "Exit"
                    "gtk-quit"
                    "E_xit" "&#x3c;control>Q"
                    "Exit the program"
                    #'(lambda (widget)
                        (declare (ignore widget))
                        (gtk-widget-destroy toplevel-window)))))
    </programlisting>
    <para>
     Notice that the FileMenu action does not have a tooltip nor a callback. The Open, Close, and Exit
     actions have both a mnemonic label and an accelerator. Having defined this list, it can be added to a
     group as follows:
    </para>
    <programlisting>
(let ((action-group (gtk-action-group-new "common-actions")))
  (gtk-action-group-add-actions action-group file-entries)
  ... )
    </programlisting>
    <para>
     Multiple action entry lists can be added to a single action group. In fact, you probably will need to do
     this, because toggle actions and radio actions must be defined differently. A
     <ulink url="&gtk-toggle-action;"><code>gtk-toggle-action</code></ulink> entry contains all of the
     members of a <ulink url="&gtk-action;"><code>gtk-action</code></ulink> entry, as well as an additional
     boolean flag <code>is-active</code>.
    </para>
    <para>
     The <code>is-active</code> flag indicates whether or not the action is active or inactive. To add toggle
     action entries to an action group you need to use the function
     <ulink url="&gtk-action-group-add-toggle-actions;">
     <code>gtk-action-group-add-toggle-actions</code></ulink> designed for that purpose.
    </para>
    <para>
     The function differs from <ulink url="&gtk-action-group-add-actions;">
     <code>gtk-action-group-add-actions</code></ulink> only in that it expects a list of
     <ulink url="&gtk-toggle-action;"><code>gtk-toggle-action</code></ulink> entries. To illustrate, we could
     define a list with a single toggle action entry:
    </para>
    <programlisting>
(defvar toggle-entries
        (list (list "FullScreen"
                    "gtk-fullscreen"
                    "_FullScreen"
                    "F11"
                    "Switch between full screen and windowed mode"
                    #'on-full-screen
                    nil)))
    </programlisting>
    <para>
     and add it to the same group as above with
    </para>
    <programlisting>
(gtk-action-group-add-toggle-actions common-actions toggle-entries)
    </programlisting>
    <para>
     GTK defines radio action entries separately. Usually you use radio buttons when there are three or more
     alternatives. If there are just two, a toggle is the cleaner interface element. Because radio actions
     can have more than two values, the list's last element is an integer instead of a boolean.
    </para>
    <para>
     Unlike ordinary actions and toggle actions, which can have different callbacks for each action, radio
     action entries do not specify a callback function. Furthermore, the last member of this structure is the
     value that that particular radio action has. If for example, there are three radio actions for how text
     is to be aligned, left, right, or centered, then one would have the value 0, the next, 1, and the third,
     2. An example of a list of radio action entries is below.
    </para>
    <programlisting>
(defvar radio-entries
        (list (list "JustifyLeft"
                    "gtk-justify-left"
                    "_Left"
                    nil
                    "Left justify text"
                    0)
              (list "JustifyCenter"
                    "gtk-justify-center"
                    "_Center"
                    nil
                    "Center the text"
                    1)
              (list "JustifyRight"
                    "gtk-justify-right"
                    "_Right"
                    nil
                    "Right justify the text"
                    2)))
    </programlisting>
    <para>
     Because radio action entries do not have a callback function as a member, the function
     <ulink url="&gtk-action-group-add-radio-actions;">
     <code>gtk-action-group-add-radio-actions</code></ulink> to add radio actions to an action group
     specifies a single callback to be used for all of the actions in the array of radio actions being added.
     This is the callback that will be called in response to the "changed" signal.
    </para>
    <para>
     Also, this function has another parameter that specifies the value that should be active initially. It
     is either one of the values in the individual radio action entries, or -1 to indicate that none should
     be active to start. We could add the radio_entries action list to our group with the call
    </para>
    <programlisting>
(gtk-action-group-add-radio-actions action-group
                                    radio-entries
                                    0
                                    #'on-change)
    </programlisting>
    <para>
     specifying that the JustifyLeft action is the initial value.
    </para>

    <bridgehead>Creating the UIManager and Adding the Action Groups</bridgehead>
    <para>
     A <ulink url="&gtk-ui-manager;"><code>gtk-ui-manager</code></ulink> is created with the function
     <ulink url="&gtk-ui-manager-new;"><code>gtk-ui-manager-new</code></ulink>. This creates a UI manager
     object that can then be used for creating and managing the application's user interface. It is now ready
     to be populated with the action groups that you already defined. To insert an action group into the UI
     manager, use the function @xurl{gtk-ui-manager-insert-action-group}.
    </para>
    <para>
     The first argument is the object returned by the call to create the UI manager. The second is the group
     to be inserted. The <code>pos</code> argument specifies the position in the list of action groups
     managed by this UI manager. Action groups that are earlier in this list will be accessed before those
     that are later in this list. A consequence of this is that, if an action with the same name, e.g.
     "Open", is in two different groups, the entry in the group with smaller position will hide the one in
     the group with larger position. For example, if an "Open" action is in groups named
     <code>action-group1</code> and <code>action-group2</code>, and <code>action-group1</code> is inserted at
     position 1, and <code>action-group2</code> is at position 2, then the entry for the "Open" action in
     <code>action-group1</code> will be used by the UI manager when its proxy is activated. If it has a
     different callback or label or accelerator, these will be associated with this action, not the one in
     <code>action-group2</code>. You can use this feature if you need to change the semantics of a menu item
     or toolbar button, but not the menu item or button itself.
    </para>
    <para>
     While we are on the subject of inserting actions, we might as well look at how you can remove an action
     group, if you have need to do that dynamically. That function is
     <ulink url="&gtk-ui-manager-remove-action-group;">
     <code>gtk-ui-manager-remove-action-group</code></ulink>. This searches the list of action groups in the
     UI manager and deletes the one which is passed to it.
    </para>

    <bridgehead>Extracting Accelerators and adding them to the Top-Level Window</bridgehead>
    <para>
     Accelerators are key combinations that provide quick access to the actions in a window. They are usually
     associated with the top-level window so that key-presses while that window has focus can be handled by
     the top-level window's "key-press-event" handler, which can propagate it through the chain of widgets.
     The problem is that the accelerators are stored within the UI manager, not the top-level window, when
     you insert the action groups into it. The UI manager aggregates the accelerators into its private data
     as action groups are added to it. However it provides a method of extracting them. The set of
     accelerators can be extracted into a <ulink url="&gtk-accel-group;"><code>gtk-accel-group</code></ulink>
     object that can be added into a top-level window. The function that does this is
     <ulink url="&gtk-ui-manager-get-accel-group;"><code>gtk-ui-manager-get-accel-group</code></ulink>.
     The function that adds this group into a top-level window is <ulink url="&gtk-window-add-accel-group;">
     <code>gtk-window-add-accel-group</code></ulink>. The following code-snippet will extract the
     accelerators and add them to the top-level window:
    </para>
    <programlisting>
(let ((accel-group (gtk-ui-manager-get-accel-group ui-manager)))
  (gtk-window-add-accel-group window accel-group)
  ... )
    </programlisting>

    <bridgehead>Loading the UI Definition</bridgehead>
    <para>
     If the UI definition is in a separate file, it can be loaded using the function
     <ulink url="&gtk-ui-manager-add-ui-from-file;"><code>gtk-ui-manager-add-ui-from-file</code></ulink>. The
     first argument is the UI manager object, the second, a filename passed as a UTF-8 string. If this
     function is successful, it will return a positive integer called a merge-id. Merge-ids will be explained
     in the next section. If the function fails, for one reason or another, the return value will be zero.
     Therefore it is a good idea to check the return value of the function. The following code fragment tests
     both conditions and terminates the program with an error message if there is an error:
    </para>
    <programlisting>
(let ((merge-id (gtk-ui-manager-add-ui-from-file ui-manager
                                                 "menu-1.xml")))
  (when (eql 0 merge-id)
    (error-message "Could not load UI Manager definition"))
  ... )
    </programlisting>
    <para>
     The function <code>error-message</code> displays a message dialog with a suitable message.
    </para>
    <para>
     An alternative to storing the UI definition in a file in the source code tree is to store the UI
     definition as a string within a source code file itself. If the UI definition is in a string, then it
     can be added with the function <ulink url="&gtk-ui-manager-add-ui-from-string;">
     <code>gtk-ui-manager-add-ui-from-string</code></ulink>.
    </para>
    <para>
     The buffer argument is the name of the string containing the UI definition. The return value is also
     either a positive integer on success, in which case it is a valid merge-id, or zero on failure. The
     following listing shows how to define a UI definition in a string.
    </para>
    <programlisting>
(defparameter ui-constant
  "&#x3c;ui>
     &#x3c;menubar name='MainMenu'>
       &#x3c;menu action='FileMenu'>
         &#x3c;placeholder name='FilePlace'/>
         &#x3c;separator/>
         &#x3c;menuitem action='Exit'/>"
       &#x3c;/menu>"
       &#x3c;menu action='ViewMenu'>"
         &#x3c;menuitem action='ZoomIn'/>"
         &#x3c;menuitem action='ZoomOut'/>"
         &#x3c;separator/>"
         &#x3c;menuitem action='FullScreen'/>"
         &#x3c;separator/>"
       &#x3c;/menu>"
     &#x3c;/menubar>"
   &#x3c;/ui>")
    </programlisting>
    <para>
     This would then be added to the UI manager with the fragment
    </para>
    <programlisting>
(let ((merge-id (gtk-ui-manager-add-ui-from-string ui-manager 
                                                   ui-constant)))
  (when (eql 0 merge-id)
    (error-message "Could not load UI Manager definition"))
  ... )
    </programlisting>

    <bridgehead>Getting the Widgets</bridgehead>
    <para>
     The last step is to retrieve the widgets that the UI manager created when the UI definition was loaded
     into it, and pack those widgets into the window where you want them to be. This is where the names of
     the UI definition elements come into play. The UI manager can find a widget for you when you give it the
     absolute pathname of the element that you want to construct. The absolute pathname is a string starting
     with a forward slash '/', much like a file's absolute pathname, with a sequence of the ancestor elements
     in the XML tree of that element.
    </para>
    <para>
     Elements which do not have a name or action attribute in the XML (e.g. <code>&#x3c;popup></code>) can
     be addressed by their XML element name (e.g. "popup"). The root element ("/ui") can be omitted in the
     path.
    </para>
    <para>t
     As an example, the absolute pathname of the FileMenu in the UI definition above is "/MainMenu/FileMenu".
    </para>
    <para>
     The function <ulink url="&gtk-ui-manager-get-widget;"><code>gtk-ui-manager-get-widget</code></ulink>
     finds the widget that the UI manager constructed, whose name matches the pathname that you give it. If
     you give it the name of a menubar, you get a menubar widget with its entire subtree. If you give it the
     name of a menu, you get the menu item to which the menu is attached, not the menu.
    </para>
    <para>
     If our UI definition had a menubar and toolbar at the top level named "MainMenu" and "MainToolBar"
     respectively, we could get them from the UI manager using
    </para>
    <programlisting>
(let ((menubar (gtk-ui-manget-get-widget ui-manager "/MainMenu"))
      (toolbar (gtk-ui-manager-get-widget ui-manager "/MainToolBar")))
  ... )
    </programlisting>
    <para>
     We could then pack these into a &gtk-box; one below the other
     in our main window, and we would be finished, except of course for defining all of the required callback
     functions.
    </para>
    <para>
     <emphasis>Note.</emphasis> The widgets that are constructed by a UI manager are not tied to the
     life-cycle of that UI manager. It does acquire a reference to them, but when you add the widgets
     returned by this function to a container or if you explicitly ref them, they will survive the
     destruction of the UI manager. (Read the notes on memory management in GTK if you are unfamiliar with
     these concepts.)
    </para>
    <para>
     Lastly, you can tell the UI manager to create tear-off menus if you want, using the function
     <ulink url="&gtk-ui-manager-add-tearoffs;"><code>gtk-ui-manager-add-tearoffs</code></ulink>.
     By passing <emphasis>true</emphasis>, all menus (except popup menus) will have the tear-off property.
    </para>
   </section>

   <section id="UI_Merging">
    <title>UI Merging</title>
    <para>
     One of the most powerful features of the UI manager is its ability to dynamically change the menus and
     toolbars by overlaying or inserting menu items or toolbar items over others and removing them later.
     This feature is called UI merging. The ability to merge elements is based on the use of the pathnames
     to the UI elements defined in the UI definition, and merge-ids.
    </para>
    <para>
     A merge-id is an unsigned integer value that is associated with a particular UI definition inside the UI
     manager. The functions that add UI definitions into the UI manager, such as
     <ulink url="&gtk-ui-manager-add-ui-from-string;"><code>gtk-ui-manager-add-ui-from-string</code></ulink>
     and <ulink url="&gtk-ui-manager-add-ui-from-file;"><code>gtk-ui-manager-add-ui-from-file</code></ulink>,
     return a merge-id that can be used at a later time, for example, to remove that particular UI
     definition. The function that removes a UI definition is @xurl{gtk-ui-manager-remove-ui}.
    </para>
    <para>
     This is given the merge-id of the UI definition to be removed. For example, if I create a UI with the
     call
    </para>
    <programlisting>
(let ((merge-id (gtk-ui-manager-add-ui-from-string ui_manager
                                                   ui_toolbar)))
  ... )
    </programlisting>
    <para>
     and I later want to remove the toolbar from the window, I would call
    </para>
    <programlisting>
(gtk-ui-manager-remove-ui ui-manger merge-id)
    </programlisting>
    <para>
     In order to add an element such as a toolbar in one part of the code, and later remove it in a callback
     function, you would need to make the merge-id either a shared variable, or attach it as a property to a
     widget that the callback is passed.
    </para>
    <para>
     There is a third function <ulink url="&gtk-ui-manager-add-ui;">
     <code>gtk-ui-manager-add-ui</code></ulink> for adding a new element to the user interface. The
     parameters have the following meanings:
    </para>
    <variablelist>
     <varlistentry>
      <term><code>self</code></term>
      <listitem>a <code>gtk-ui-manager</code></listitem>
     </varlistentry>
     <varlistentry>
      <term><code>merge-id</code></term>
      <listitem>the merge-id for the merged UI</listitem>
     </varlistentry>
     <varlistentry>
      <term><code>path</code></term>
      <listitem>a path</listitem>
     </varlistentry>
     <varlistentry>
      <term><code>name</code></term>
      <listitem>the name for the added UI element</listitem>
     </varlistentry>
     <varlistentry>
      <term><code>action</code></term>
      <listitem>the name of the action to be proxied, or <code>nil</code> to add a separator</listitem>
     </varlistentry>
     <varlistentry>
      <term><code>type</code></term>
      <listitem>the type of UI element to add</listitem>
     </varlistentry>
     <varlistentry>
      <term><code>top</code></term>
      <listitem>
       if <emphasis>true</emphasis>, the UI element is added before its siblings, otherwise it is added
       after its siblings.
      </listitem>
     </varlistentry>
    </variablelist>
    <para>
     This function can add a single element to the UI, such as a menu item, a toolbar item, a menu, or a
     menubar. It cannot add an entire UI definition such as the ones contained in the strings defined above.
     Furthermore, it cannot be used to insert an element in a place where such an element cannot be inserted.
     For example, you cannot insert a toolbar inside a menu, or a menu inside a menu, but you can insert a
     menu item in a menu, or a menu in a menubar.
    </para>
    <para>
     In order to use this function, you need a merge-id to give to it. It will assign associate the new UI
     element to this merge-id so that it can be removed at a later time. New merge-ids are created with the
     function <ulink url="&gtk-ui-manager-new-merge-id;"><code>gtk-ui-manager-new-merge-id</code></ulink>.
     The third parameter is the absolute path name to the position at which you want to add the new UI
     element. For example, if you want to insert a new menu item at the top of the File menu, the path would
     be "/MainMenu/FileMenu". The fourth parameter is a name that you want this item to have for future
     access and the fifth is the name for the action, which must exist already, that should be connected to
     this element.
    </para>
    <para>
     The type must be a member of the <ulink url="&gtk-ui-manager-item-type;">
     <code>gtk-ui-manager-item-type</code></ulink>, which has the following values
    </para>
    <programlisting>
:auto
:menubar
:menu
:toolbar
:placeholder
:popup
:menuitem
:toolitem
:separator
:accelerator
    </programlisting>
    <para>
     Their meanings should be self-explanatory, except for the first. You can use <code>:auto</code> as the
     type to let GTK decide the type of the element that can be inserted at the indicated path. Lastly, if
     you want the element to be above the element that is currently in that position, you set top to
     <emphasis>true</emphasis>, otherwise <code>nil</code>.
    </para>
    <para>
     As an example, suppose that I want to add a Print menu item in my File menu just below the Open menu
     item. I could use the following code fragment, assuming that I have already defined an action named
     Print:
    </para>
    <programlisting>
(let ((merge-id (gtk-ui-manager-new-merge-id ui-manager)))
  (gtk-ui-manager-add-ui ui-manager
                         merge-id
                         "/MainMenu/FileMenu/Open"
                         "Print"
                         "Print"
                         :menu-item
                         nil)
    ... )
    </programlisting>
    <para>
     This will insert the Print menu item into the proper position.
    </para>
    <para>
     Assuming that  your menu is to be changed dynamically, these steps will not be enough to make the menu
     elements appear dynamically. The UI manager does not handle the task of packing new toolbars or menubars
     into their places in the window. However, it does emit the "add-widget" signal for each generated
     menubar and toolbar. Your application can respond to this signal with a callback function that can pack
     the UI element into the appropriate position. Therefore, two additional steps are needed by a program
     that adds and removes menubars or toolbars:
    </para>
    <itemizedlist>
     <listitem>
      Create a callback function to pack these widgets into the parent container, and
     </listitem>
     <listitem>
      Connect the "add-widget" signal emitted by the UI manager to this callback.
     </listitem>
    </itemizedlist>
    <para>
     The callback for this signal has the prototype
    </para>
    <programlisting>
lambda (merge widget)
    </programlisting>
    <para>
     The first parameter is the UI manager emitting the signal, the second is the widget that has been added.
     For example
    </para>
    <programlisting>
(g-signal-connect ui-manager "add-widget"
   (lambda (merge widget)
     (declare (ignore merge))
     (gtk-box-pack-start menu-box widget :fill nil :expand nil)
     (gtk-widget-show widget)))
    </programlisting>
    <para>
     This will pack the menubar or toolbar after any other widgets in the parent, assuming that menu-box is
     a &gtk-box; of some kind that the menu or toolbar should be
     packed into. It must show the widget to realize it.
    </para>
   </section>
  </section>
 </chapter>

 <chapter id="Printing" revision="2021-3-16">
  <title>Printing</title>

  <section id="Print_Operation" revision="2021-3-16">
   <title>Print Operation</title>
   <para>
    At the application development level, the GTK printing API provides dialogs that are consistent across
    applications and allows use of Cairo's common drawing API, with Pango-driven text rendering. In the
    implementation of this common API, platform-specific backends and printer-specific drivers are used.
   </para>
   <para>
    The primary object is the &gtk-print-operation; object, allocated for each print operation. To handle page
    drawing connect to its signals, or inherit from it and override the default virtual signal handlers.
    The &gtk-print-operation; object automatically handles all the settings affecting the print loop.
   </para>

   <bridgehead>Signals</bridgehead>
   <para>
    The function &gtk-print-operation-run; starts the print loop, during which various signals are emitted:
   </para>
   <variablelist>
    <varlistentry>
     <term>"begin-print"</term>
     <listitem>
      You must handle this signal, because this is where you create and set up a &pango-layout; object using
      the provided &gtk-print-context; object, and break up your printing output into pages.
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>"paginate"</term>
     <listitem>
      Pagination is potentially slow so if you need to monitor it you can call the function
      &gtk-print-operation-show-progress; and handle this signal.
     </listitem>
    </varlistentry>
    <varlistentry>
     <term></term>
     <listitem>
      For each page that needs to be rendered, the following signals are emitted:
      <variablelist>
       <varlistentry>
        <term>"request-page-setup"</term>
        <listitem>
         Provides a &gtk-print-context; object, page number and &gtk-page-setup; object. Handle this signal
         if you need to modify page setup on a per-page basis.
        </listitem>
       </varlistentry>
       <varlistentry>
        <term>"draw-page"</term>
        <listitem>
         You must handle this signal, which provides a &gtk-print-context; object and a page number. The
         print context should be used to create a &cairo-context; instance into which the provided page
         should be drawn. To render text, iterate over the &pango-layout; object you created in the
         "begin-print" handler.
        </listitem>
       </varlistentry>
      </variablelist>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>"end-print"</term>
     <listitem>
      A handler for it is a safe place to free any resources related to a print operaton. If you have your
      custom class that inherits from the &gtk-print-operation; class, it is naturally simpler to do it in
      the destructor.
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>"done"</term>
     <listitem>
      This signal is emitted when printing is finished, meaning when the print data is spooled. Note that the
      provided &gtk-print-operation-result; value may indicate that an error occurred. In any case you
      probably want to notify the user about the final status.
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>"status-chanded"</term>
     <listitem>
      Emitted whenever a print job's status changes, until it is finished. Call the function
      &gtk-print-operation-track-print-status; to monitor the job status after spooling. To see the status,
      use the functions &gtk-print-operation-status; or &gtk-print-operation-status-string;.
     </listitem>
    </varlistentry>
   </variablelist>
  </section>

  <section id="Page_Setup" revision="2021-3-17">
   <title>Page Setup</title>

   <figure id="figure-page-setup-dialog">
    <title>Page Setup Dialog</title>
    <mediaobject>
     <imageobject>
      <imagedata fileref="figures/page-setup-dialog.png" format="png"></imagedata>
     </imageobject>
    </mediaobject>
   </figure>

   <para>
    The &gtk-print-operation; class has a method called &gtk-print-operation-default-page-setup; which selects
    the default paper size, orientation and margins. To show a page setup dialog from your application, use
    the function &gtk-print-run-page-setup-dialog;, which returns a &gtk-page-setup; object with the chosen
    settings. Use this object to update a &gtk-print-operation; object and to access the selected
    &gtk-paper-size; instance, &gtk-page-orientation; value and printer-specific margins.
   </para>
   <para>
    You should save the chosen &gtk-page-setup; instance so you can use it again if the page setup dialog is
    shown again.
   </para>
   <para>
    The Cairo coordinate system, in the "draw-page" handler, is automatically rotated to the current page
    orientation. It is normally within the printer margins, but you can change that via the function
    &gtk-print-operation-use-full-page;. The default measurement unit is device pixels. To select other units,
    use the function &gtk-print-operation-unit;.
   </para>

   <example id="create-page-setup-dialog">
    <title>Create Page Setup Dialog</title>
   <programlisting xmlns:xi="http://www.w3.org/2001/XInclude">
<xi:include href="../demo/gtk-example/page-setup-dialog.lisp" parse="text"/>
   </programlisting>
   </example>

  </section>

  <section id="Rendering_text" revision="2021-3-16">
   <title>Rendering text</title>
   <para>
    Text rendering is done using Pango. The &pango-layout; object for printing should be created by calling
    the function &gtk-print-context-create-pango-layout;. The &gtk-print-context; object also provides the
    page metrics, via the functions &gtk-print-context-width; and &gtk-print-context-height;. The number of
    pages can be set with the function &gtk-print-operation-n-pages;. To actually render the Pango text in the
    "on-draw-page" handler, get a &cairo-context; object with the function &gtk-print-context-cairo-context;
    and show the &pango-layout-line; instances that appear within the requested page number.
   </para>
  </section>

  <section id="Asynchronous_operations" revision="2021-3-16">
   <title>Asynchronous operations</title>
   <para>
    By default, the function &gtk-print-operation-run; returns when a print operation is completed. If you
    need to run a non-blocking print operation, call the function &gtk-print-operation-allow-async;. Note that
    this function is not supported on all platforms, however the done signal will still be emitted.
   </para>
   <para>
    The function &gtk-print-operation-run; may return the value <code>:in-progress</code> of the
    &gtk-print-operation-result; enumeration. To track status and handle the result or error you need to
    implement signal handlers for the "done" and "status-changed" signals:
   </para>
   <para>
    For instance,
   </para>
   <programlisting>
(let ((operation (make-instance 'gtk-print-operation)))
  (g-signal-connect operation "done" #'on-print-operation-done)
  ;; Run the print operation
  ... )
   </programlisting>
   <para>
    Second, check for an error and connect to the "status-changed" signal. For instance:
   </para>
   <programlisting>
(defun on-print-operation-done (operation result)
  (if (eq :error result)
      ;; Notify user
      (if (eq :apply result)
          ;; Update print settings with the ones used in this print operation
      ))
  (if (not (gtk-print-operation-is-finished operation))
      (g-signal-connect operation "status-changed" #'on-print-operation-status-changed))
  ... )
   </programlisting>
   <para>
    Finally, check the status. For instance,
   </para>
   <programlisting>
(defun on-print-operaton-status-changed (operation)
  (if (gtk-print-operation-is-finished operation)
      ;; the print job is finished
      ;; get the status with gtk-print-operation-status or gtk-print-operation-status-string
  )
  ;; Update UI
  ... )
   </programlisting>
  </section>

  <section id="Export_to_PDF" revision="2021-3-16">
   <title>Export to PDF</title>
   <para>
    The 'Print to file' option is available in the print dialog, without the need for extra implementation.
    However, it is sometimes useful to generate a PDF file directly from code. For instance,
   </para>
   <programlisting>
(let ((operation (make-instance 'gtk-print-operation)))
  (setf (gtk-print-operation-export-filename operation) "test.pdf")
  (gtk-print-operation-run operation :export parent)
  ... )
   </programlisting>
  </section>

  <section id="Extending_the_print_dialog" revision="2021-3-16">
   <title>Extending the print dialog</title>
   <para>
    You may add a custom tab to the print dialog:
   </para>
   <itemizedlist>
    <listitem>
     Set the title of the tab via the function &gtk-print-operation-custom-tab-label;, create a new widget
     and return it from the "create-custom-widget" signal handler. You'll probably want this to be a
     container widget, packed with some others.
    </listitem>
    <listitem>
     Get the data from the widgets in the "custom-widget-apply" signal handler.
    </listitem>
   </itemizedlist>
   <para>
    The "custom-widget-apply" signal provides the widget you previously created, to simplify things you can
    keep the widgets you expect to contain some user input as global to the signal handlers. For example,
    let's say you have a &gtk-entry; widget:
   </para>
   <programlisting>
(let ((entry (make-instance 'gtk-entry)))

  (defun on-create-custom-widget (operation)
    (let ((hbox (make-instance 'gtk-box
                               :orientation :horizontal
                               :border-width 6))
          (label (make-instance 'gtk-label
                                :label "Enter some text: ")))
    (setf (gtk-print-operation-custom-label operation) "My custom tab")
    (gtk-box-pack-start hbox label :expand nil)
    (gtk-box-pack-start hbox entry :expand nil)
    (gtk-widget-show-all hbox)
    hbox))

  (defun on-custom-widget-apply (operation widget)
    (let* ((user-input (gtk-entry-text entry)))
      ... )))
   </programlisting>
   <para>
    The example in examples/book/printing/advanced demonstrates this.
   </para>
  </section>

  <section id="Preview" revision="2021-3-16">
   <title>Preview</title>
   <para>
    The native GTK print dialog has a preview button, but you may also start a preview directly from an
    application:
   </para>
   <programlisting>
(let ((operation (make-instance 'gtk-print-operation)))
  (gtk-print-operation-run operation :preview parent)
  ... )
   </programlisting>
   <para>
    On Unix, the default preview handler uses an external viewer program. On Windows, the native preview
    dialog will be shown. If necessary you may override this behaviour and provide a custom preview dialog.
   </para>
  </section>

  <section id="Printing_Example" revision="2021-3-17">
   <title>Printing Example</title>
   <para>
    The following example demonstrates how to print some input from a user interface. It shows how to
    implement the "begin-print" and "draw-page" handler, as well as how to track print status and update the
    print settings.
   </para>
   <example id="do-print-operation">
    <title>Do Print Operation</title>
   <programlisting xmlns:xi="http://www.w3.org/2001/XInclude">
<xi:include href="../demo/gtk-example/print-operation.lisp" parse="text"/>
   </programlisting>
   </example>
  </section>
 </chapter>

 <chapter id="Application_Suport">
  <title>Application Support</title>
  <section id="Application_Class">
   <title>Application Class</title>
   <para>
    <ulink url="&gtk-application;"><code>gtk-application</code></ulink> is a class that handles many
    important aspects of a GTK application in a convenient fashion, without enforcing a one-size-fits-all
    application model.
   </para>
   <para>
    Currently, <ulink url="&gtk-application;"><code>gtk-application</code></ulink> handles GTK
    initialization, application uniqueness, session management, provides some basic scriptability and desktop
    shell integration by exporting actions and menus and manages a list of toplevel windows whose life-cycle
    is automatically tied to the life-cycle of your application.
   </para>
   <para>
    While <ulink url="&gtk-application;"><code>gtk-application</code></ulink> works fine with plain
    &gtk-window; widgets, it is recommended to use it together
    with <ulink url="&gtk-application-window;"><code>gtk-application-window</code></ulink>.
   </para>
   <para>
    When GDK threads are enabled, <ulink url="&gtk-application;"><code>gtk-application</code></ulink> will
    acquire the GDK lock when invoking actions that arrive from other processes.  The GDK lock is not touched
    for local action invocations.  In order to have actions invoked in a predictable context it is therefore
    recommended that the GDK lock be held while invoking actions locally with the function
    <ulink url="&g-action-group-activate-action;"><code>g-action-group-activate-action</code></ulink>.  The
    same applies to actions associated with <ulink url="&gtk-application-window;">
    <code>gtk-application-window</code></ulink> and to the 'activate' and 'open'
    <ulink url="&g-application;"><code>g-application</code></ulink> methods.
   </para>
   <para>
    To set an application menu for a <ulink url="&gtk-application;"><code>gtk-application</code></ulink>, use
    the generic function <ulink url="&gtk-application-app-menu;">
    <code>gtk-application-app-menu</code></ulink>.  The <ulink url="&g-menu-model;">
    <code>g-menu-model</code></ulink> that this function expects is usually constructed using
    <ulink url="&gtk-builder;"><code>gtk-builder</code></ulink>, as seen in example
    <link linkend="example-application">Application</link>.  To specify a menubar that will be shown by
    <ulink url="&gtk-application-window;"><code>gtk-application-window</code></ulink> widgets, use the
    generic function <ulink url="&gtk-application-menubar;"><code>gtk-application-menubar</code></ulink>.
    Use the base <ulink url="&g-action-map;"><code>g-action-map</code></ulink> interface to add actions, to
    respond to the user selecting these menu items.
   </para>
   <para>
    GTK displays these menus as expected, depending on the platform the application is running on.
   </para>
   <para>
    <ulink url="&gtk-application;"><code>gtk-application</code></ulink> optionally registers with a session
    manager of the users session, if you set the <ulink url="&register-session;">
    <code>register-session</code></ulink> property, and offers various functionality related to the session
    life-cycle.
   </para>
   <para>
    An application can block various ways to end the session with the function
    <ulink url="&gtk-application-inhibit;"><code>gtk-application-inhibit</code></ulink>.  Typical use cases
    for this kind of inhibiting are long-running, uninterruptible operations, such as burning a CD or
    performing a disk backup.  The session manager may not honor the inhibitor, but it can be expected to
    inform the user about the negative consequences of ending the session while inhibitors are present.
   </para>
  </section>

  <section id="Application_Window">
   <sectioninfo>
    <itermset>
     <indexterm zone="Application_Window">
      <primary>GtkApplicationWindow</primary>
     </indexterm>
     <indexterm zone="Application_Window">
      <primary>application-window, gtk-application-window</primary>
     </indexterm>
     <indexterm zone="Application_Window">
      <primary>GActionGroup</primary>
     </indexterm>
     <indexterm zone="Application_Window">
      <primary>action-group, g-action-group</primary>
     </indexterm>
     <indexterm zone="Application_Window">
      <primary>GActionMap</primary>
     </indexterm>
     <indexterm zone="Application_Window">
      <primary>action-map, g-action-map</primary>
     </indexterm>
     <indexterm zone="Application_Window">
      <primary>GMenuModel</primary>
     </indexterm>
     <indexterm zone="Application_Window">
      <primary>menu-model, g-menu-model</primary>
     </indexterm>
     <indexterm zone="Application_Window">
      <primary>GtkMenuBar</primary>
     </indexterm>
     <indexterm zone="Application_Window">
      <primary>menu-bar,gtk-menu-bar</primary>
     </indexterm>
    </itermset>
   </sectioninfo>
   <title>Application Window</title>
   <para>
    <ulink url="&gtk-application-window;"><code>gtk-application-window</code></ulink> is a
    &gtk-window; subclass that offers some extra functionality
    for better integration with <ulink url="&gtk-application;"><code>gtk-application</code></ulink> features.
    Notably, it can handle both the application menu as well as the menubar. See the functions
    <ulink url="&gtk-application-app-menu;"><code>gtk-application-app-menu</code></ulink> and
    <ulink url="&gtk-application-menubar;"><code>gtk-application-menubar</code></ulink>.
   </para>
   <para>
    This class implements the <ulink url="&g-action-group;"><code>g-action-group</code></ulink> and
    <ulink url="&g-action-map;"><code>g-action-map</code></ulink> interfaces, to let you add window-specific
    actions that will be exported by the associated <ulink url="&gtk-application;">
    <code>gtk-application</code></ulink>, together with its application-wide actions. Window-specific actions
    are prefixed with the "win." prefix and application-wide actions are prefixed with the "app." prefix.
    Actions must be addressed with the prefixed name when referring to them from a
    <ulink url="&g-menu-model;"><code>g-menu-model</code></ulink>.
   </para>
   <para>
    Note that widgets that are placed inside a <ulink url="&gtk-application-window;">
    <code>gtk-application-window</code></ulink> can also activate these actions, if they implement the
    <ulink url="&gtk-actionable;"><code>gtk-actionable</code></ulink> interface.
   </para>
   <para>
    As with <ulink url="&gtk-application;"><code>gtk-application</code></ulink>, the GDK lock will be
    acquired when processing actions arriving from other processes and should therefore be held when
    activating actions locally if GDK threads are enabled.
   </para>
   <para>
    The settings <ulink url="&gtk-shell-shows-app-menu;"><code>gtk-shell-shows-app-menu</code></ulink> and
    <ulink url="&gtk-shell-shows-menubar;"><code>gtk-shell-shows-menubar</code></ulink> tell GTK whether the
    desktop environment is showing the application menu and menubar models outside the application as part of
    the desktop shell.  For instance, on OS X, both menus will be displayed remotely; on Windows neither will
    be.  gnome-shell (starting with version 3.4) will display the application menu, but not the menubar.
   </para>
   <para>
    If the desktop environment does not display the menubar, then <ulink url="&gtk-application-window;">
    <code>gtk-application-window</code></ulink> will automatically show a <ulink url="&gtk-menu-bar;">
    <code>gtk-menu-bar</code></ulink> for it. See the <ulink url="&gtk-application;">
    <code>gtk-application</code></ulink> docs for some screenshots of how this looks on different platforms.
    This behaviour can be overridden with the <ulink url="&show-menubar;"><code>show-menubar</code></ulink>
    property.  If the desktop environment does not display the application menu, then it will automatically
    be included in the menubar.
   </para>
   <para>
    The XML format understood by <ulink url="&gtk-builder;"><code>gtk-builder</code></ulink> for
    <ulink url="&g-menu-model;"><code>g-menu-model</code></ulink> consists of a toplevel
    <code>&#x3c;menu></code> element, which contains one or more <code>&#x3c;item></code> elements. Each
    <code>&#x3c;item></code> element contains <code>&#x3c;attribute></code> and <code>&#x3c;link></code>
    elements with a mandatory name attribute.  <code>&#x3c;link></code> elements have the same content model
    as <code>&#x3c;menu></code>.
   </para>
   <para>
    Attribute values can be translated using gettext, like other <ulink url="&gtk-builder;">
    <code>gtk-builder</code></ulink> content.  <code>&#x3c;attribute></code> elements can be marked for
    translation with a translatable = "yes" attribute.  It is also possible to specify message context and
    translator comments, using the context and comments attributes. To make use of this, the
    <ulink url="&gtk-builder;"><code>gtk-builder</code></ulink> must have been given the gettext domain to
    use.
   </para>
  </section>

  <section id="Simple_Application">
   <title>Simple Application</title>
   <figure id="figure-bloatpad">
    <title>Simple Application</title>
    <mediaobject>
     <imageobject>
      <imagedata fileref="figures/bloatpad.gif" format="gif"></imagedata>
     </imageobject>
    </mediaobject>
   </figure>
   <example id="example-application">
    <title>Simple GTK Application</title>
    <programlisting>
(defclass bloat-pad (gtk-application)
  ()
  (:metaclass gobject-class)
  (:g-type-name . "BloatPad"))

(register-object-type-implementation "BloatPad"
                                     bloat-pad
                                     "GtkApplication"
                                     nil
                                     nil)

(defun new-window (application file)
  (declare (ignore file))
    (let (;; Create the application window
          (window (make-instance 'gtk-application-window
                                 :application application
                                 :title "Bloatpad"
                                 :border-width 12
                                 :default-width 500
                                 :default-height 400))
          (grid (make-instance 'gtk-grid))
          (toolbar (make-instance 'gtk-toolbar)))

      ;; Connect signal "destroy" to the application window
      (g-signal-connect window "destroy"
                        (lambda (widget)
                          (declare (ignore widget))
                          (leave-gtk-main)
                          (if (zerop gtk::*main-thread-level*)
                              (g-application-quit application))))

      ;; Add action "copy" to the application window
      (let ((action (g-simple-action-new "copy" nil)))
        (g-action-map-add-action window action)
        (g-signal-connect action "activate"
           (lambda (action parameter)
             (declare (ignore action parameter))
             (let ((view (gobject::get-g-object-for-pointer
                           (g-object-data window "bloatpad-text"))))
               (gtk-text-buffer-copy-clipboard
                                  (gtk-text-view-buffer view)
                                  (gtk-widget-clipboard view "CLIPBOARD"))))))

      ;; Add action "paste" to the application window
      (let ((action (g-simple-action-new "paste" nil)))
        (g-action-map-add-action window action)
        (g-signal-connect action "activate"
           (lambda (action parameter)
             (declare (ignore action parameter))
             (let ((view (gobject::get-g-object-for-pointer
                           (g-object-data window "bloatpad-text"))))
               (gtk-text-buffer-paste-clipboard
                                       (gtk-text-view-buffer view)
                                       (gtk-widget-clipboard view "CLIPBOARD")
                                       :editable t)))))

      ;; Add action "fullscreen" to the application window
      (let ((action (g-simple-action-new-stateful
                                               "fullscreen"
                                               nil
                                               (g-variant-new-boolean nil))))
        (g-action-map-add-action window action)
        (g-signal-connect action "activate"
           (lambda (action parameter)
             (declare (ignore parameter))
             (let* ((state (g-action-state action))
                    (value (g-variant-boolean state)))
               (g-action-change-state action
                                      (g-variant-new-boolean (not value))))))
        (g-signal-connect action "change-state"
           (lambda (action parameter)
             (if (g-variant-boolean parameter)
                 (gtk-window-fullscreen window)
                 (gtk-window-unfullscreen window))
             (setf (g-simple-action-state action) parameter))))

      ;; Add action "justify" to the application window
      (let ((action (g-simple-action-new-stateful
                                             "justify"
                                             (g-variant-type-new "s")
                                             (g-variant-new-string "left"))))
        (g-action-map-add-action window action)
        (g-signal-connect action "activate"
           (lambda (action parameter)
             (g-action-change-state action parameter)))
        (g-signal-connect action "change-state"
           (lambda (action parameter)
             (let ((view (gobject::get-g-object-for-pointer
                           (g-object-data window "bloatpad-text")))
                   (str (g-variant-string parameter)))
               (cond ((equal str "left")
                      (setf (gtk-text-view-justification view) :left))
                     ((equal str "center")
                      (setf (gtk-text-view-justification view) :center))
                     (t
                      (setf (gtk-text-view-justification view) :right)))
               (setf (g-simple-action-state action) parameter)))))

      (let ((button (make-instance 'gtk-toggle-tool-button
                                   :stock-id "gtk-justify-left")))
        (gtk-actionable-set-detailed-action-name button "win.justify::left")
        (gtk-container-add toolbar button))
      (let ((button (make-instance 'gtk-toggle-tool-button
                                   :stock-id "gtk-justify-center")))
        (gtk-actionable-set-detailed-action-name button
                                                 "win.justify::center")
        (gtk-container-add toolbar button))
      (let ((button (make-instance 'gtk-toggle-tool-button
                                   :stock-id "gtk-justify-right")))
        (gtk-actionable-set-detailed-action-name button "win.justify::right")
        (gtk-container-add toolbar button))
      (let ((button (make-instance 'gtk-separator-tool-item
                                   :draw nil)))
        (setf (gtk-tool-item-expand button) t)
        (gtk-container-add toolbar button))
      (let ((button (make-instance 'gtk-tool-item))
            (box (make-instance 'gtk-box
                                :orientation :horizontal
                                :spacing 6))
            (label (make-instance 'gtk-label
                                  :label "Fullscreen:"))
            (switch (make-instance 'gtk-switch)))
        (setf (gtk-actionable-action-name switch) "win.fullscreen")
        (gtk-container-add box label)
        (gtk-container-add box switch)
        (gtk-container-add button box)
        (gtk-container-add toolbar button))
      (gtk-grid-attach grid toolbar 0 0 1 1)
      (let ((scrolled (make-instance 'gtk-scrolled-window
                                     :hexpand t
                                     :vexpand t))
            (view (make-instance 'gtk-text-view)))
        (setf (g-object-data window "bloatpad-text") (pointer view))
        (gtk-container-add scrolled view)
        (gtk-grid-attach grid scrolled 0 1 1 1))
      (gtk-container-add window grid)
      (gtk-widget-show-all window)))

(defun bloat-pad-activate (application)
  ;; Start a main loop and create an application window
  (within-main-loop
    (new-window application nil))
  ;; Wait until the main loop has finished
  (join-gtk-main))

(defun create-about-dialog ()
  (let (;; Create an about dialog
        (dialog (make-instance 'gtk-about-dialog
                               :program-name "Example Dialog"
                               :version "0.00"
                               :copyright "(c) Dieter Kaiser"
                               :website
                               "github.com/crategus/cl-cffi-gtk"
                               :website-label "Project web site"
                               :license "LLGPL"
                               :authors '("Dieter Kaiser")
                               :documenters '("Dieter Kaiser")
                               :artists '("None")
                               :logo-icon-name
                               "applications-development"
                               :wrap-license t)))
    ;; Run the about dialog
    (gtk-dialog-run dialog)
    ;; Destroy the about dialog
    (gtk-widget-destroy dialog)))

(defvar *menu*
  "&#x3c;interface>
    &#x3c;menu id='app-menu'>
     &#x3c;section>
      &#x3c;item>
       &#x3c;attribute name='label' translatable='yes'>_New Window&#x3c;/attribute>
       &#x3c;attribute name='action'>app.new&#x3c;/attribute>
       &#x3c;attribute name='accel'>&lt;Primary&gt;n&#x3c;/attribute>
      &#x3c;/item>
     &#x3c;/section>
     &#x3c;section>
      &#x3c;item>
       &#x3c;attribute name='label' translatable='yes'>_About Bloatpad&#x3c;/attribute>
       &#x3c;attribute name='action'>app.about&#x3c;/attribute>
      &#x3c;/item>
     &#x3c;/section>
     &#x3c;section>
      &#x3c;item>
       &#x3c;attribute name='label' translatable='yes'>_Quit&#x3c;/attribute>
       &#x3c;attribute name='action'>app.quit&#x3c;/attribute>
       &#x3c;attribute name='accel'>&lt;Primary&gt;q&#x3c;/attribute>
      &#x3c;/item>
     &#x3c;/section>
     &#x3c;/menu>
    &#x3c;menu id='menubar'>
     &#x3c;submenu>
      &#x3c;attribute name='label' translatable='yes'>_Edit&#x3c;/attribute>
      &#x3c;section>
       &#x3c;item>
        &#x3c;attribute name='label' translatable='yes'>_Copy&#x3c;/attribute>
        &#x3c;attribute name='action'>win.copy&#x3c;/attribute>
        &#x3c;attribute name='accel'>&lt;Primary&gt;c&#x3c;/attribute>
       &#x3c;/item>
       &#x3c;item>
        &#x3c;attribute name='label' translatable='yes'>_Paste&#x3c;/attribute>
        &#x3c;attribute name='action'>win.paste&#x3c;/attribute>
        &#x3c;attribute name='accel'>&lt;Primary&gt;v&#x3c;/attribute>
       &#x3c;/item>
      &#x3c;/section>
     &#x3c;/submenu>
     &#x3c;submenu>
      &#x3c;attribute name='label' translatable='yes'>_View&#x3c;/attribute>
      &#x3c;section>
       &#x3c;item>
        &#x3c;attribute name='label' translatable='yes'>_Fullscreen&#x3c;/attribute>
        &#x3c;attribute name='action'>win.fullscreen&#x3c;/attribute>
        &#x3c;attribute name='accel'>F11&#x3c;/attribute>
       &#x3c;/item>
      &#x3c;/section>
     &#x3c;/submenu>
    &#x3c;/menu>
   &#x3c;/interface>")

(defun bloat-pad-startup (application)
  ;; Add action "new" to the application
  (let ((action (g-simple-action-new "new" nil)))
    ;; Connect a handler to the signal "activate"
    (g-signal-connect action "activate"
       (lambda (action parameter)
         (declare (ignore action parameter))
         ;; ensure-gtk-main increases the thread level for the new window
         (ensure-gtk-main)
         (new-window application nil)))
    ;; Add the action to the action map of the application
    (g-action-map-add-action application action))

  ;; Add action "about" to the application
  (let ((action (g-simple-action-new "about" nil)))
    ;; Connect a handler to the signal "activate"
    (g-signal-connect action "activate"
       (lambda (action parameter)
         (declare (ignore action parameter))
         (create-about-dialog)))
    ;; Add the action to the action map of the application
    (g-action-map-add-action application action))

  ;; Add action "quit" to the application
  (let ((action (g-simple-action-new "quit" nil)))
    ;; Connect a handler to the signal activate
    (g-signal-connect action "activate"
       (lambda (action parameter)
         (declare (ignore action parameter))
         ;; Destroy all windows of the application
         (dolist (window (gtk-application-get-windows application))
           (gtk-widget-destroy window))
         ;; Quit the main loop
         (leave-gtk-main)
         ;; Quit the application
         (g-application-quit application)))
    ;; Add the action to action map of the application
    (g-action-map-add-action application action))

  ;; Intitialize the application menu and the menubar
  (let ((builder (make-instance 'gtk-builder)))
    ;; Read the menus from a string
    (gtk-builder-add-from-string builder *menu*)
    ;; Set the application menu
    (setf (gtk-application-app-menu application)
          (gtk-builder-object builder "app-menu"))
    ;; Set the menubar
    (setf (gtk-application-menubar application)
          (gtk-builder-object builder "menubar"))))

(defun bloat-pad-open (application)
  (declare (ignore application))
  ;; Executed when the application is opened
  nil)

(defun bloat-pad-shutdown (application)
  (declare (ignore application))
  ;; Executed when the application is shut down
  nil)

(defmethod initialize-instance :after
    ((app bloat-pad) &#x26;key &#x26;allow-other-keys)
  (g-signal-connect app "activate" #'bloat-pad-activate)
  (g-signal-connect app "startup" #'bloat-pad-startup)
  (g-signal-connect app "open" #'bloat-pad-open)
  (g-signal-connect app "shutdown" #'bloat-pad-shutdown))

(defun bloat-pad-new ()
  (g-set-application-name "Bloatpad")
  (setf (gtk-settings-gtk-shell-shows-app-menu (gtk-settings-get-default))
        nil)
  (setf (gtk-settings-gtk-shell-shows-menubar (gtk-settings-get-default))
        nil)
  (make-instance 'bloat-pad
                 :application-id "com.crategus.bloatpad"
                 :flags :handles-open
                 :inactivity-timeout 30000
                 :register-session t))

(defun example-application (&#x26;optional (argc 0) (argv (null-pointer)))
  (let (;; Create an instance of the application Bloat Pad
        (bloat-pad (bloat-pad-new)))
    (format t "call G-APPLICATION-RUN.~%")
    ;; Run the application
    (g-application-run bloat-pad argv)
    (format t "back from G-APPLICATION-RUN.~%")))
    </programlisting>
   </example>
  </section>
 </chapter>

 <chapter id="GTK_and_Cairo">
  <title>GTK and Cairo</title>
  <para>
   This tutorial is taken from the offical Cairo website at
   <ulink url="http://cairographics.org/tutorial/">cairographics.org/tutorial/</ulink> which has been derived
   from Michael Urman's Cairo tutorial for python programmers. The code snippets have been translated to Lisp
   and the text has only been changed as much as necessary.
  </para>
  <para>
   Cairo is a powerful 2d graphics library. This document introduces you to how Cairo works and many of the
   functions you will use to create the graphic experience you desire.
  </para>

  <section id="Cario_Drawing_Model">
   <title>Cairo's Drawing Model</title>
   <para>
    In order to explain the operations used by cairo, we first delve into a model of how Cairo models
    drawing. There are only a few concepts involved, which are then applied over and over by the different
    methods. First I will describe the nouns: destination, source, mask, path, and context.  After that I
    will describe the verbs which offer ways to manipulate the nouns and draw the graphics you wish to
    create.
   </para>

   <section id="Nouns">
    <title>Nouns</title>
    <para>
     Cairo's nouns are somewhat abstract.  To make them concrete I am including diagrams that depict how they
     interact. The first three nouns are the three layers in the diagrams you see in this section. The fourth
     noun, the path, is drawn on the middle layer when it is relevant. The final noun, the context, is not
     shown.
    </para>

    <bridgehead>Destination</bridgehead>
    <mediaobject>
     <imageobject>
      <imagedata fileref="figures/destination.png" format="png"></imagedata>
     </imageobject>
    </mediaobject>
    <para>
     The destination is the <emphasis>surface</emphasis> on which you are drawing. It may be tied to an
     array of pixels like in this tutorial, or it might be tied to a SVG or PDF file, or something else.
     This surface collects the elements of your graphic as you apply them, allowing you to build up a
     complex work as though painting on a canvas.
    </para>

    <bridgehead>Source</bridgehead>
    <mediaobject>
     <imageobject>
      <imagedata fileref="figures/source.png" format="png"></imagedata>
     </imageobject>
    </mediaobject>
    <para>
     The source is the "paint" you are about to work with. I show this as it is - plain black for several
     examples - but translucent to show lower layers. Unlike real paint, it does not have to be a single
     color; it can be a <emphasis>pattern</emphasis> or even a previously created destination
     <emphasis>surface</emphasis> (see <ulink url="http://cairographics.org/FAQ/#paint_from_a_surface">
     How do I paint from one surface to another?</ulink>). Also unlike real paint it can contain transparency
     information - the Alpha channel.
    </para>

    <bridgehead>Mask</bridgehead>
    <mediaobject>
     <imageobject>
      <imagedata fileref="figures/the-mask.png" format="png"></imagedata>
     </imageobject>
    </mediaobject>
    <para>
     The mask is the most important piece: it controls where you apply the source to the destination. I
     will show it as a yellow layer with holes where it lets the source through.  When you apply a drawing
     verb, it is like you stamp the source to the destination. Anywhere the mask allows, the source is
     copied. Anywhere the mask disallows, nothing happens.
    </para>

    <bridgehead>Path</bridgehead>
    <para>
     The path is somewhere between part of the mask and part of the context. I will show it as thin green
     lines on the mask layer. It is manipulated by path verbs, then used by drawing verbs.
    </para>

    <bridgehead>Context</bridgehead>
    <para>
     The context keeps track of everything that verbs affect. It tracks one source, one destination, and
     one mask. It also tracks several helper variables like your line width and style, your font face and
     size, and more. Most importantly it tracks the path, which is turned into a mask by drawing verbs.
    </para>
    <para>
     Before you can start to draw something with Cairo, you need to create the context. The context is 
     stored in Cairo's central data type, called <ulink url="&cairo-t;"><code>cairo-t</code></ulink>.
     When you create a Cairo context, it must be tied to a specific surface - for example, an image surface
     if you want to create a PNG file. There is also a data type for the surface, called
     <ulink url="&cairo-surface-t;"><code>cairo-surface-t</code></ulink>. You can initialize your Cairo
     context with the functions <ulink url="&cairo-image-surface-create;">
     <code>cairo-image-surface-create</code></ulink> and <ulink url="&cairo-create;">
     <code>cairo-create</code></ulink> like this:
    </para>
    <programlisting>
(let* ((surface (cairo-image-surface-create :argb32 120 120))
       (cr (cairo-create surface)))
  ... )
    </programlisting>
    <para>
     The Cairo context in this example is tied to an image surface of dimension 120 x 120 and 32 bits per
     pixel to store RGB and Alpha information. Surfaces can be created specific to most Cairo backends, see
     the <ulink url="http://www.crategus.com/books/cl-cffi-gtk/pages/cairo.html">
     Cairo API documentation</ulink> for details.
    </para>
   </section>

   <section id="Verbs">
    <title>Verbs</title>
    <para>
     The reason you are using Cairo in a program is to draw. Cairo internally draws with one fundamental
     drawing operation: the source and mask are freely placed somewhere over the destination. Then the
     layers are all pressed together and the paint from the source is transferred to the destination wherever
     the mask allows it. To that extent the following five drawing verbs, or operations, are all similar.
     They differ by how they construct the mask.
    </para>

    <bridgehead>Stroke</bridgehead>
    <mediaobject>
     <imageobject>
      <imagedata fileref="figures/stroke.png" format="png"></imagedata>
     </imageobject>
    </mediaobject>
    <para>
     The <ulink url="&cairo-stroke;"><code>cairo-stroke</code></ulink> operation takes a virtual pen along
     the path. It allows the source to transfer through the mask in a thin (or thick) line around the path,
     according to the pen's <ulink url="&cairo-set-line-width;"><code>line width</code></ulink>,
     <ulink url="&cairo-set-dash;"><code>dash style</code></ulink>, and
     <ulink url="&cairo-set-line-cap;"><code>line caps</code></ulink>.
    </para>
    <programlisting>
(cairo-set-line-width cr 0.1)
(cairo-set-source-rgb cr 1.0 0.0 0.0)
(cairo-rectangle cr 0.25 0.25 0.5 0.5)
(cairo-stroke cr)
    </programlisting>
    <para>
     The following example shows the above code snippet in action and the code to produce the output:
    </para>
    <mediaobject>
     <imageobject>
      <imagedata fileref="figures/cairo-stroke.png" format="png"></imagedata>
     </imageobject>
    </mediaobject>
    <example id="example-cairo-stroke">
     <title>Demo Cairo Stroke</title>
     <programlisting>
(defun demo-cairo-stroke ()
  (within-main-loop
    (let ((window (make-instance 'gtk-window
                                 :type :toplevel
                                 :title "Demo Cairo Stroke"
                                 :border-width 12
                                 :default-width 400
                                 :default-height 400)))
      (g-signal-connect window "destroy"
                        (lambda (widget)
                          (declare (ignore widget))
                          (leave-gtk-main)))
      ;; Signals used to handle the backing surface
      (g-signal-connect window "draw"
         (lambda (widget cr)
           (let ((cr (pointer cr))
                 ;; Get the GdkWindow for the widget
                 (window (gtk-widget-window widget)))
           ;; Clear surface
           (cairo-set-source-rgb cr 1.0 1.0 1.0)
           (cairo-paint cr)
           ;; Example is in 1.0 x 1.0 coordinate space
           (cairo-scale cr
                        (gdk-window-width window)
                        (gdk-window-height window))
           ;; Drawing code goes here
           (cairo-set-line-width cr 0.1)
           (cairo-set-source-rgb cr 1.0 0.0 0.0)
           (cairo-rectangle cr 0.25 0.25 0.5 0.5)
           (cairo-stroke cr)
           ;; Destroy the Cario context
           (cairo-destroy cr)
           t)))
      (gtk-widget-show-all window))))
     </programlisting>
    </example>

    <bridgehead>Fill</bridgehead>
    <mediaobject>
     <imageobject>
      <imagedata fileref="figures/fill.png" format="png"></imagedata>
     </imageobject>
    </mediaobject>
    <para>
     The <ulink url="&cairo-fill;"><code>cairo-fill</code></ulink> operation instead uses the path like the
     lines of a coloring book, and allows the source through the mask within the hole whose boundaries are
     the path. For complex paths (paths with multiple closed sub-paths - like a donut - or paths that
     self-intersect) this is influenced by the <ulink url="&cairo-set-fill-rule;">fill rule</ulink>. Note
     that while stroking the path transfers the source for half of the line width on each side of the path,
     filling a path fills directly up to the edge of the path and no further.
    </para>
    <programlisting>
(cairo-set-source-rgb cr 1.0 0.0 0.0)
(cairo-rectangle cr 0.25 0.25 0.5 0.5)
(cairo-fill cr)
    </programlisting>

    <bridgehead>Show Text / Glyps</bridgehead>
    <mediaobject>
     <imageobject>
      <imagedata fileref="figures/showtext.png" format="png"></imagedata>
     </imageobject>
    </mediaobject>
    <para>
     The <ulink url="&cairo-show-text;"><code>cairo-show-text</code></ulink> operation forms the mask from
     text. It may be easier to think of <ulink url="&cairo-show-text;"><code>cairo-show-text</code></ulink>
     as a shortcut for creating a path with <ulink url="&cairo-text-path;">
     <code>cairo-text-path</code></ulink> and then using <ulink url="&cairo-fill;">
     <code>cairo-fill</code></ulink> to transfer it. Be aware <ulink url="&cairo-show-text;">
     <code>cairo-show-text</code></ulink> caches glyphs so is much more efficient if you work with a lot of
     text.
    </para>
    <programlisting>
(cairo-set-source-rgb cr 0.0 0.0 0.0)
(cairo-select-font-face cr "Georgia" :normal :bold)
(cairo-set-font-size cr 1.2)
(let ((text-extents (cairo-text-extents cr "a")))
  (cairo-move-to cr
                 (- 0.5
                    (/ (cairo-text-extents-t-width text-extents) 2)
                    (cairo-text-extents-t-x-bearing text-extents))
                 (- 0.5
                    (/ (cairo-text-extents-t-height text-extents) 2)
                    (cairo-text-extents-t-y-bearing text-extents)))
  (cairo-show-text cr "a"))
    </programlisting>

    <bridgehead>Paint</bridgehead>
    <mediaobject>
     <imageobject>
      <imagedata fileref="figures/paint.png" format="png"></imagedata>
     </imageobject>
    </mediaobject>
    <para>
     The <ulink url="&cairo-paint;"><code>cairo-paint</code></ulink> operation uses a mask that transfers
     the entire source to the destination. Some people consider this an infinitely large mask, and others
     consider it no mask; the result is the same. The related operation
     <ulink url="&cairo-paint-with-alpha;"><code>cairo-paint-with-alpha</code></ulink> similarly allows
     transfer of the full source to destination, but it transfers only the provided percentage of the color.
    </para>
    <programlisting>
(cairo-set-source-rgb cr 0.0 0.0 0.0)
(cairo-paint-with-alpha cr 0.5)
    </programlisting>

    <bridgehead>Mask</bridgehead>
    <mediaobject>
     <imageobject>
      <imagedata fileref="figures/mask.png" format="png"></imagedata>
     </imageobject>
    </mediaobject>
    <para>
     The <ulink url="&cairo-mask;"><code>cairo-mask</code></ulink> and <ulink url="&cairo-mask-surface;">
     <code>cairo-mask-surface</code></ulink> operations allow transfer according to the transparency/opacity
     of a second source pattern or surface. Where the pattern or surface is opaque, the current source is
     transferred to the destination. Where the pattern or surface is transparent, nothing is transferred.
    </para>
    <programlisting>
(let ((linpat (cairo-pattern-create-linear 0 0 1 1))
      (radpat (cairo-pattern-create-radial 0.5 0.5 0.25 0.5 0.5 0.75)))

  (cairo-pattern-add-color-stop-rgb linpat 0 0 0.3 0.8)
  (cairo-pattern-add-color-stop-rgb linpat 1 0 0.8 0.3)

  (cairo-pattern-add-color-stop-rgba radpat 0 0 0 0 1)
  (cairo-pattern-add-color-stop-rgba radpat 0.5 0 0 0 0)

  (cairo-set-source cr linpat)
  (cairo-mask cr radpat))
    </programlisting>
   </section>
  </section>

  <section id="Drawing_with_Cairo">
   <title>Drawing with Cairo</title>
   <para>
    In order to create an image you desire, you have to prepare the context for each of the drawing verbs.
    To use <ulink url="&cairo-stroke;"><code>cairo-stroke</code></ulink> or <ulink url="&cairo-fill;">
    <code>cairo-fill</code></ulink> you first need a path. To use <ulink url="&cairo-show-text;">
    <code>cairo-show-text</code></ulink> you must position your text by its insertion point. To use
    <ulink url="&cairo-mask;"><code>cairo-mask</code></ulink> you need a second source pattern or surface.
    And to use any of the operations, including <ulink url="&cairo-paint;"><code>cairo-paint</code></ulink>,
    you need a primary source.
   </para>

   <section id="Preparing_and_Selecting_a_Source">
    <title>Preparing and Selecting a Source</title>
     <mediaobject>
      <imageobject>
       <imagedata fileref="figures/setsourcergba.png" format="png"></imagedata>
      </imageobject>
     </mediaobject>
    <para>
     There are three main kinds of sources in cairo: colors, gradients, and images. Colors are the simplest;
     they use a uniform hue and opacity for the entire source. You can select these without any preparation
     with <ulink url="&cairo-set-source-rgb;"><code>cairo-set-source-rgb</code></ulink> and
     <ulink url="&cairo-set-source-rgba;"><code>cairo-set-source-rgba</code></ulink>. Using
     <code>(cairo-set-source-rgb cr r g b)</code> is equivalent to using
     <code>(cairo-set-source-rgba cr r g b 1.0)</code>, and it sets your source color to use full opacity.
    </para>
    <programlisting>
(cairo-set-source-rgb cr 0 0 0)
(cairo-move-to cr 0 0)
(cairo-line-to cr 1 1)
(cairo-move-to cr 1 0)
(cairo-line-to cr 0 1)
(cairo-set-line-width cr 0.2)
(cairo-stroke cr)

(cairo-rectangle cr 0 0 0.5 0.5)
(cairo-set-source-rgba cr 1 0 0 0.80)
(cairo-fill cr)

(cairo-rectangle cr 0 0.5 0.5 0.5)
(cairo-set-source-rgba cr 0 1 0 0.60)
(cairo-fill cr)

(cairo-rectangle cr 0.5 0 0.5 0.5)
(cairo-set-source-rgba cr 0 0 1 0.40)
(cairo-fill cr)
    </programlisting>
    <para>
     Gradients describe a progression of colors by setting a start and stop reference location and a series
     of "stops" along the way.  Linear gradients are built from two points which pass through parallel lines
     to define the start and stop locations.  Radial gradients are also built from two points, but each has
     an associated radius of the circle on which to define the start and stop locations.  Stops are added to 
     the gradient with <ulink url="&cairo-pattern-add-color-stop-rgb;">
     <code>cairo-pattern-add-color-stop-rgb</code></ulink> and
     <ulink url="&cairo-pattern-add-color-stop-rgba;"><code>cairo-pattern-add-color-stop-rgba</code></ulink>
     which take a color like <code>cairo-set-source-rgb*</code>, as well as an offset to indicate where it
     lies between the reference locations. The colors between adjacent stops are averaged over space to form
     a smooth blend. Finally, the behavior beyond the reference locations can be controlled with
     <ulink url="&cairo-pattern-set-extend;"><code>cairo-pattern-set-extend</code></ulink>.
    </para>
    <mediaobject>
     <imageobject>
      <imagedata fileref="figures/setsourcegradient.png" format="png"></imagedata>
     </imageobject>
    </mediaobject>
    <programlisting>
(let ((radpat (cairo-pattern-create-radial 0.25
                                           0.25 0.10 0.50 0.50 0.50))
      (linpat (cairo-pattern-create-linear 0.25 0.35 0.75 0.65)))
  (cairo-pattern-add-color-stop-rgb radpat 0.00 1.00 0.80 0.80)
  (cairo-pattern-add-color-stop-rgb radpat 1.00 0.90 0.00 0.00)
  (iter (for i from 1 below 10)
        (iter (for j from 1 below 10)
              (cairo-rectangle cr
                               (- (/ i 10.0) 0.04)
                               (- (/ j 10.0) 0.04)
                               0.08
                               0.08)))
  (cairo-set-source cr radpat)
  (cairo-fill cr)

  (cairo-pattern-add-color-stop-rgba linpat 0.00 1.0 1.0 1.0 0.0)
  (cairo-pattern-add-color-stop-rgba linpat 0.25 0.0 1.0 0.0 0.5)
  (cairo-pattern-add-color-stop-rgba linpat 0.50 1.0 1.0 1.0 0.0)
  (cairo-pattern-add-color-stop-rgba linpat 0.75 0.0 0.0 1.0 0.5)
  (cairo-pattern-add-color-stop-rgba linpat 1.00 1.0 1.0 1.0 0.0)

  (cairo-rectangle cr 0.0 0.0 1.0 1.0)
  (cairo-set-source cr linpat)
  (cairo-fill cr))
    </programlisting>
    <para>
     Images include both surfaces loaded from existing files with
     <ulink url="&cairo-image-surface-create-from-png;">
     <code>cairo-image-surface-create-from-png</code></ulink> and surfaces created from within Cairo as an
     earlier destination. As of Cairo 1.2, the easiest way to make and use an earlier destination as a
     source is with <ulink url="&cairo-push-group;"><code>cairo-push-group</code></ulink> and either
     <ulink url="&cairo-pop-group;"><code>cairo-pop-group</code></ulink> or
     <ulink url="&cairo-pop-group-to-source;"><code>cairo-pop-group-to-source</code></ulink>. Use
     <ulink url="&cairo-pop-group-to-source;"><code>cairo-pop-group-to-source</code></ulink> to use it just
     until you select a new source, and <ulink url="&cairo-pop-group;"><code>cairo-pop-group</code></ulink>
     when you want to save it so you can select it over and over again with <ulink url="&cairo-set-source;">
     <code>cairo-set-source</code></ulink>.
    </para>
   </section>

   <section id="Creating_a_Path">
    <title>Creating a Path</title>
    <para>
     Cairo always has an active path. If you call <ulink url="&cairo-stroke;">
     <code>cairo-stroke</code></ulink> it will draw the path with your line settings. If you call
     <ulink url="&cairo-fill;"><code>cairo-fill</code></ulink> it will fill the inside of the path. But as
     often as not, the path is empty, and both calls will result in no change to your destination. Why is it
     empty so often? For one, it starts that way; but more importantly after each
     <ulink url="&cairo-stroke;"><code>cairo-stroke</code></ulink> or <ulink url="&cairo-fill;">
     <code>cairo-fill</code></ulink> it is emptied again to let you start building your next path.
    </para>
    <para>
     What if you want to do multiple things with the same path? For instance to draw a red rectangle with a
     black border, you would want to fill the rectangle path with a red source, then stroke the same path
     with a black source.  A rectangle path is easy to create multiple times, but a lot of paths are more
     complex.
    </para>
    <para>
     Cairo supports easily reusing paths by having alternate versions of its operations. Both draw the same
     thing, but the alternate does not reset the path. For stroking, alongside <ulink url="&cairo-stroke;">
     <code>cairo-stroke</code></ulink> there is <ulink url="&cairo-stroke-preserve;">
     <code>cairo-stroke-preserve</code></ulink>; for filling, <ulink url="&cairo-fill-preserve;">
     <code>cairo-fill-preserve</code></ulink> joins <ulink url="&cairo-fill;">
     <code>cairo-fill</code></ulink>. Even setting the clip has a preserve variant. Apart from choosing when
     to preserve your path, there are only a couple common operations.
    </para>
   </section>

   <section id="Moving">
    <title>Moving</title>
    <mediaobject>
     <imageobject>
      <imagedata fileref="figures/path-moveto.png" format="png"></imagedata>
     </imageobject>
    </mediaobject>
    <para>
     Cairo uses a connect-the-dots style system when creating paths.  Start at 1, draw a line to 2, then 3,
     and so forth.  When you start a path, or when you need to start a new sub-path, you want it to be like
     point 1: it has nothing connecting to it.  For this, use <ulink url="&cairo-move-to;">
     <code>cairo-move-to</code></ulink>.  This sets the current reference point without making the path
     connect the previous point to it.  There is also a relative coordinate variant,
     <ulink url="&cairo-rel-move-to;"><code>cairo-rel-move-to</code></ulink>, which sets the new reference a
     specified distance away from the current reference instead. After setting your first reference point,
     use the other path operations which both update the reference point and connect to it in some way.
    </para>
    <programlisting>
(cairo-move-to cr 0.25 0.25)
    </programlisting>

    <bridgehead>Straight Lines</bridgehead>
    <mediaobject>
     <imageobject>
      <imagedata fileref="figures/path-lineto.png" format="png"></imagedata>
     </imageobject>
    </mediaobject>
    <para>
     Whether with absolute coordinates <ulink url="&cairo-line-to;"><code>cairo-line-to</code></ulink>
     (extend the path from the reference to this point), or relative coordinates
     <ulink url="&cairo-rel-line-to;"><code>cairo-rel-line-to</code></ulink> (extend the path from the
     reference this far in this direction), the path connection will be a straight line.  The new reference
     point will be at the other end of the line.
    </para>
    <programlisting>
(cairo-line-to cr 0.5 0.375)
(cairo-rel-line-to cr 0.25 -0.125)
    </programlisting>

    <bridgehead>Arcs</bridgehead>
    <mediaobject>
     <imageobject>
      <imagedata fileref="figures/path-arcto.png" format="png"></imagedata>
     </imageobject>
    </mediaobject>
    <para>
     Arcs are parts of the outside of a circle.  Unlike straight lines, the point you directly specify is not
     on the path.  Instead it is the center of the circle that makes up the addition to the path.  Both a
     starting and ending point on the circle must be specified, and these points are connected either
     clockwise by <ulink url="&cairo-arc;"><code>cairo-arc</code></ulink> or counter-clockwise by
     <ulink url="&cairo-arc-negative;"><code>cairo-arc-negative</code></ulink>. If the previous reference
     point is not on this new curve, a straight line is added from it to where the arc begins. The reference
     point is then updated to where the arc ends. There are only absolute versions.
    </para>
    <programlisting>
(cairo-arc cr 0.5 0.5 (* 0.25 (sqrt 2)) (* -0.25 pi) (* 0.25 pi))
    </programlisting>

    <bridgehead>Curves</bridgehead>
    <mediaobject>
     <imageobject>
      <imagedata fileref="figures/path-curveto.png" format="png"></imagedata>
     </imageobject>
    </mediaobject>
    <para>
     Curves in Cairo are cubic Bezier splines.  They start at the current reference point and smoothly follow
     the direction of two other points (without going through them) to get to a third specified point.  Like
     lines, there are both absolute <ulink url="&cairo-curve-to;"><code>cairo-curve-to</code></ulink> and
     relative <ulink url="&cairo-rel-curve-to;"><code>cairo-rel-curve-to</code></ulink> versions. Note that
     the relative variant specifies all points relative to the previous reference point, rather than each
     relative to the preceding control point of the curve.
    </para>
    <programlisting>
(cairo-rel-curve-to cr -0.25 -0.125 -0.25 0.125 -0.5, 0)
    </programlisting>

    <bridgehead>Close the path</bridgehead>
    <mediaobject>
     <imageobject>
      <imagedata fileref="figures/path-close.png" format="png"></imagedata>
     </imageobject>
    </mediaobject>
    <para>
     Cairo can also close the path by drawing a straight line to the beginning of the current sub-path. This
     straight line can be useful for the last edge of a polygon, but is not directly useful for curve-based
     shapes. A closed path is fundamentally different from an open path: it is one continuous path and has
     no start or end.  A closed path has no line caps for there is no place to put them.
    </para>
    <programlisting>
(cairo-close-path cr)
    </programlisting>

    <bridgehead>Text</bridgehead>
    <para>
     Finally text can be turned into a path with <ulink url="&cairo-text-path;">
     <code>cairo-text-path</code></ulink>. Paths created from text are like any other path, supporting stroke
     or fill operations. This path is placed anchored to the current reference point, so
     <ulink url="&cairo-move-to;"><code>cairo-move-to</code></ulink> your desired location before turning
     text into a path. However there are performance concerns to doing this if you are working with a lot of
     text; when possible you should prefer using the verb <ulink url="&cairo-show-text;">
     <code>cairo-show-text</code></ulink> over <ulink url="&cairo-text-path;">
     <code>cairo-text-path</code></ulink> and <ulink url="&cairo-fill;"><code>cairo-fill</code></ulink>.
    </para>
   </section>
  </section>

  <section id="Understanding_Text">
   <title>Understanding Text</title>
   <mediaobject>
    <imageobject>
     <imagedata fileref="figures/textextents.png" format="png"></imagedata>
    </imageobject>
   </mediaobject>
   <para>
    To use text effectively you need to know where it will go. The methods <ulink url="&cairo-font-extents;">
    <code>cairo-font-extents</code></ulink> and <ulink url="&cairo-text-extents;">
    <code>cairo-text-extents</code></ulink> get you this information. Since this diagram is hard to see so
    small, I suggest getting its source and bump the size up to 600. It shows the relation between the  
    reference point (red dot); suggested next reference point (blue dot); bounding box (dashed blue lines);
    bearing displacement (solid blue line); and height, ascent, baseline, and descent lines (dashed green).
   </para>
   <para>
    The reference point is always on the baseline.  The descent line is below that, and reflects a rough
    bounding box for all characters in the font.  However it is an artistic choice intended to indicate
    alignment rather than a true bounding box.  The same is true for the ascent line above.  Next above that
    is the height line, the artist-recommended spacing between subsequent baselines.  All three of these are
    reported as distances from the baseline, and expected to be positive despite their differing directions.
   </para>
   <para>
    The bearing is the displacement from the reference point to the upper-left corner of the bounding box.
    It is often zero or a small positive value for x displacement, but can be negative x for characters like
    j as shown; it is almost always a negative value for y displacement.  The width and height then describe
    the size of the bounding box.  The advance takes you to the suggested reference point for the next
    letter.  Note that bounding boxes for subsequent blocks of text can overlap if the bearing is negative,
    or the advance is smaller than the width would suggest.
   </para>
   <para>
    In addition to placement, you also need to specify a face, style, and size.  Set the face and style
    together with <ulink url="&cairo-select-font-face;"><code>cairo-select-font-face</code></ulink>, and the
    size with <ulink url="&cairo-set-font-size;"><code>cairo-set-font-size</code></ulink>.  If you need even
    finer control, try getting a <ulink url="&cairo-font-options-t;">
    <code>cairo-font-options-t</code></ulink> with <ulink url="&cairo-get-font-options;">
    <code>cairo-get-font-options</code></ulink>, tweaking it, and setting it with
    <ulink url="&cairo-set-font-options;"><code>cairo-set-font-options</code></ulink>.
   </para>
  </section>

  <section id="Working_with_Transforms">
   <title>Working with Transforms</title>
   <para>
    Transforms have three major uses.  First they allow you to set up a coordinate system that is easy to
    think in and work in, yet have the output be of any size. Second they allow you to make helper functions
    that work at or around a (0, 0) but can be applied anywhere in the output image.  Thirdly they let you
    deform the image, turning a circular arc into an elliptical arc, etc.  Transforms are a way of setting
    up a relation between two coordinate systems.  The device-space coordinate system is tied to the surface,
    and cannot change.  The user-space coordinate system matches that space by default, but can be changed
    for the above reasons.  The helper functions <ulink url="&cairo-user-to-device;">
    <code>cairo-user-to-device</code></ulink> and <ulink url="&cairo-user-to-device-distance;">
    <code>cairo-user-to-device-distance</code></ulink> tell you what the device-coordinates are for a
    user-coordinates position or distance.  Correspondingly <ulink url="&cairo-device-to-user;">
    <code>cairo-device-to-user</code></ulink> and <ulink url="&cairo-device-to-user-distance;">
    <code>cairo-device-to-user-distance</code></ulink> tell you user-coordinates for a device-coordinates
    position or distance.  Remember to send positions through the non-distance variant, and relative moves
    or other distances through the distance variant.
   </para>
   <para>
    I leverage all of these reasons to draw the diagrams in this document.  Whether I am drawing 120 x 120
    or 600 x 600, I use <ulink url="&cairo-scale;"><code>cairo-scale</code></ulink> to give me a 1.0 x 1.0
    workspace.  To place the results along the right column, such as in the discussion of cairo's drawing
    model, I use <ulink url="&cairo-translate;"><code>cairo-translate</code></ulink>.  And to add the
    perspective view for the overlapping layers, I set up an arbitrary deformation with
    <ulink url="&cairo-transform;"><code>cairo-transform</code></ulink> on a <ulink url="&cairo-matrix-t;">
    <code>cairo-matrix-t</code></ulink>.
   </para>
   <para>
    To understand your transforms, read them bottom to top, applying them to the point you are drawing.  To
    figure out which transforms to create, think through this process in reverse.  For example if I want my
    1.0 x 1.0 workspace to be 100 x 100 pixels in the middle of a 120 x 120 pixel surface, I can set it up
    one of three ways:
   </para>
   <programlisting>
1. (cairo-translate cr 10 10)
   (cairo-scale cr 100 100)

2. (cairo-scale cr 100 100)
   (cairo-translate cr 0.1 0.1)

3. (let ((mat (cairo-matrix-init 100 0 0 100 10 10)))
     (cairo-transform cr mat)
     ... )
   </programlisting>
   <para>
    Use the first when relevant because it is often the most readable; use the third when necessary to
    access additional control not available with the primary functions.
   </para>
   <para>
    Be careful when trying to draw lines while under transform.  Even if you set your line width while the
    scale factor was 1, the line width setting is always in user-coordinates and is not modified by setting
    the scale.  While you are operating under a scale, the width of your line is multiplied by that scale.
    To specify a width of a line in pixels, use <ulink url="&cairo-device-to-user-distance;">
    <code>cairo-device-to-user-distance</code></ulink> to turn a (1, 1) device-space distance into, for
    example, a (0.01, 0.01) user-space distance.  Note that if your transform deforms the image there is not
    necessarily a way to specify a line with a uniform width.
   </para>
  </section>

  <section id="Where_to_Go_Next">
   <title>Where to Go Next</title>
   <para>
    This wraps up the tutorial. It does not cover all functions in Cairo, so for some "advanced" lesser-used
    features, you will need to look elsewhere. The code behind the examples (layer diagrams, drawing
    illustrations) uses a handful of techniques that are not described within, so analyzing them may be a
    good first step. Other examples on cairographics.org lead in different directions. As with everything,
    there is a large gap between knowing the rules of the tool, and being able to use it well. The final
    section of this document provides some ideas to help you traverse parts of the gap.
   </para>
  </section>

  <section id="Tips_and_Tricks">
   <title>Tips and Tricks</title>
   <para>
    In the previous sections you should have built up a firm grasp of the operations Cairo uses to create
    images. In this section I've put together a small handful of snippets I have found particularly useful
    or non-obvious.  I am still new to Cairo myself, so there may be other better ways to do these things.
    If you find a better way, or find a cool way to do something else, let me know and perhaps I can
    incorporate it into these tips.
   </para>

   <section id="Line_Width">
    <title>Line Width</title>
    <para>
     When you are working under a uniform scaling transform, you can not just use pixels for the width of
     your line.  However it is easy to translate it with the help of
     <ulink url="&cairo-device-to-user-distance;"><code>cairo-device-to-user-distance</code></ulink>
     (assuming that the pixel width is  1):
    </para>
    <programlisting>
(muliple-value-bind (ux uy)
    (cairo-device-to-user-distance cr)
  (cairo-set-line-width cr (min ux uy)))
    </programlisting>
    <para>
     When you are working under a deforming scale, you may wish to still have line widths that are uniform
     in device space.  For this you should return to a uniform scale before you stroke the path.  In the
     image, the arc on the left is stroked under a deformation, while the arc on the right is stroked under
     a uniform scale.
    </para>
    <programlisting>
(cairo-set-line-width cr 0.1)

(cairo-save cr)
(cairo-scale cr 0.5 1)
(cairo-arc cr 0.5 0.5 0.40 0 (* 2 pi))
(cairo-stroke cr)

(cairo-translate cr 1 0)
(cairo-arc cr 0.5 0.5 0.40 0 (* 2pi))
(cairo-restore cr)
(cairo-stroke cr)
    </programlisting>
   </section>

   <section id="Text_Alignment">
    <title>Text Alignment</title>
    <para>
     When you try to center text letter by letter at various locations, you have to decide how you want to
     center it.  For example the following code will actually center letters individually, leading to poor
     results when your letters are of different sizes.  (Unlike most examples, here I assume a 26 x 1
     workspace.)
    </para>
    <programlisting>
cairo_text_extents_t te;
char alphabet[] = "AbCdEfGhIjKlMnOpQrStUvWxYz";
char letter[2];

for (i=0; i &#x3c; strlen(alphabet); i++) {
    *letter = '\0';
    strncat (letter, alphabet + i, 1);

    cairo_text_extents (cr, letter, &#x26;te);
    cairo_move_to (cr, i + 0.5 - te.x_bearing - te.width / 2,
            0.5 - te.y_bearing - te.height / 2);
    cairo_show_text (cr, letter);
}
    </programlisting>
    <para>
     Instead the vertical centering must be based on the general size of the font, thus keeping your baseline
     steady.  Note that the exact positioning now depends on the metrics provided by the font itself, so the
     results are not necessarily the same from font to font.
    </para>
    <programlisting>
cairo_font_extents_t fe;
cairo_text_extents_t te;
char alphabet[] = "AbCdEfGhIjKlMnOpQrStUvWxYz";
char letter[2];

cairo_font_extents (cr, &#x26;fe);
for (i=0; i &#x3c; strlen(alphabet); i++) {
    *letter = '\0';
    strncat (letter, alphabet + i, 1);

    cairo_text_extents (cr, letter, &#x26;te);
    cairo_move_to (cr, i + 0.5 - te.x_bearing - te.width / 2,
            0.5 - fe.descent + fe.height / 2);
    cairo_show_text (cr, letter);
}
    </programlisting>
   </section>
  </section>

  <section id="Writing_a_Widget_Using_Cairo_and_GTK">
   <title>Writing a Widget Using Cairo and GTK</title>
   <figure id="figure-cairo-clock">
    <title>Cairo Clock</title>
    <mediaobject>
     <imageobject>
      <imagedata fileref="figures/cairo-clock.png" format="png"></imagedata>
     </imageobject>
    </mediaobject>
   </figure>
   <para>
    This demo shows a custom widget named <code>egg-clock-face</code> which draws a clock using
    Cairo.  This Cairo Clock example is inspired by the C code from Davyd Madeley.  
    <code>egg-clock-face</code> is defined as a subclass of the &gtk-drawing-area;
    class.  Only the property <code>time</code> is added to
    hold the actual time of the clock.  The <code>initialize-instance</code> method installs a
    timeout source with the function <ulink url="&g-timeout-add;"><code>g-timeout-add</code>
    </ulink>, which updates every second the <code>time</code> property of <code>egg-clock-face
    </code> and requests the redrawing of the widget.  The "draw" signal handler draws the clock
    into the &gtk-drawing-area; of the
    <code>egg-clock-face</code> widget.
   </para>

   <example id="example-cairo-clock">
    <title>Demo Cairo Clock</title>
    <programlisting>
(asdf:load-system :cl-cffi-gtk)

(defpackage :cairo-clock
  (:use :gtk :gdk :gobject :glib :pango :cairo :cffi :iterate :common-lisp)
  (:export #:demo-cairo-clock))

(in-package :cairo-clock)

;; Class egg-clock-face is a subclass of a GtkDrawingArea

(defclass egg-clock-face (gtk-drawing-area)
  ((time :initarg :time
         :initform (multiple-value-list (get-decoded-time))
         :accessor egg-clock-face-time))
  (:metaclass gobject-class))

(defmethod initialize-instance :after
    ((clock egg-clock-face) &#x26;key &#x26;allow-other-keys)
  ;; A timeout source for the time
  (g-timeout-add 1000
                 (lambda ()
                   (setf (egg-clock-face-time clock)
                         (multiple-value-list (get-decoded-time)))
                   (gtk-widget-queue-draw clock)
                   +g-source-continue+))
  ;; Signal handler which draws the clock
  (g-signal-connect clock "draw"
     (lambda (widget cr)
       (let ((cr (pointer cr))
             ;; Get the GdkWindow for the widget
             (window (gtk-widget-window widget)))
       ;; Clear surface
       (cairo-set-source-rgb cr 1.0 1.0 1.0)
       (cairo-paint cr)
       (let* ((x (/ (gdk-window-width window) 2))
              (y (/ (gdk-window-height window) 2))
              (radius (- (min x y) 12)))
         ;; Clock back
         (cairo-arc cr x y radius 0 (* 2 pi))
         (cairo-set-source-rgb cr 1 1 1)
         (cairo-fill-preserve cr)
         (cairo-set-source-rgb cr 0 0 0)
         (cairo-stroke cr)
         ;; Clock ticks
         (let ((inset 0.0)
               (angle 0.0))
           (dotimes (i 12)
             (cairo-save cr)
             (setf angle (/ (* i pi) 6))
             (if (eql 0 (mod i 3))
                 (setf inset (* 0.2 radius))
                 (progn
                   (setf inset (* 0.1 radius))
                   (cairo-set-line-width cr
                                         (* 0.5 (cairo-get-line-width cr)))))
             (cairo-move-to cr
                            (+ x (* (- radius inset) (cos angle)))
                            (+ y (* (- radius inset) (sin angle))))
             (cairo-line-to cr
                            (+ x (* radius (cos angle)))
                            (+ y (* radius (sin angle))))
             (cairo-stroke cr)
             (cairo-restore cr)))
         (let ((seconds (first (egg-clock-face-time clock)))
               (minutes (second (egg-clock-face-time clock)))
               (hours (third (egg-clock-face-time clock))))
           ;; The hour hand is rotated 30 degrees (pi/6 r) per hour
           ;; + 1/2 a degree (pi/360 r) per minute
           (let ((hours-angle (* (/ pi 6) hours))
                 (minutes-angle (* (/ pi 360) minutes)))
             (cairo-save cr)
             (cairo-set-line-width cr (* 2.5 (cairo-get-line-width cr)))
             (cairo-move-to cr x y)
             (cairo-line-to cr
                            (+ x
                               (* (/ radius 2)
                                  (sin (+ hours-angle minutes-angle))))
                            (+ y
                               (* (/ radius 2)
                                  (- (cos (+ hours-angle minutes-angle))))))
             (cairo-stroke cr)
             (cairo-restore cr))
           ;; The minute hand is rotated 6 degrees (pi/30 r)
           ;; per minute
           (let ((angle (* (/ pi 30) minutes)))
             (cairo-move-to cr x y)
             (cairo-line-to cr
                            (+ x (* radius 0.75 (sin angle)))
                            (+ y (* radius 0.75 (- (cos angle)))))
             (cairo-stroke cr))
           ;; Seconds hand: Operates identically to the minute hand
           (let ((angle (* (/ pi 30) seconds)))
             (cairo-save cr)
             (cairo-set-source-rgb cr 1 0 0)
             (cairo-move-to cr x y)
             (cairo-line-to cr (+ x (* radius 0.7 (sin angle)))
                               (+ y (* radius 0.7 (- (cos angle)))))
             (cairo-stroke cr)
             (cairo-restore cr))))
       ;; Destroy the Cario context
       (cairo-destroy cr)
       t))))

(defun demo-cairo-clock ()
  (within-main-loop
    (let ((window (make-instance 'gtk-window
                                 :title "Demo Cairo Clock"
                                 :default-width 250
                                 :default-height 250))
          (clock (make-instance 'egg-clock-face)))
      (g-signal-connect window "destroy"
                        (lambda (widget)
                          (declare (ignore widget))
                          (leave-gtk-main)))
      (gtk-container-add window clock)
      (gtk-widget-show-all window))))
    </programlisting>
   </example>
  </section>
 </chapter>

 <chapter id="Deprecated" revidion="2021-5-18">
  <title>Deprecated</title>

  <section id="Packing_Using_Tables">
   <title>Packing Using Tables</title>
   <para>
    Tables are another way of packing widgets and can be extremely useful in certain situations. Using tables
    a grid is created that widgets can placed in. The widgets may take up as many spaces as specified. Tables
    can be created with the function &gtk-table-new;. The function takes three arguments which set the
    properties of a table. Alternatively, the table is created with the function <code>make-instance</code>.
   </para>
   <para>
    The first argument of &gtk-table-new; is the number of rows to make in the table, while the second is the
    number of columns. The last argument <code>homogeneous</code> has to do with how the boxes of the table
    are sized. If <code>homogeneous</code> is <code>T</code>, the table boxes are resized to the size of the
    largest widget in the table. If <code>homogeneous</code> is <code>NIL</code>, the size of a table boxes is
    dictated by the tallest widget in its same row, and the widest widget in its column. The rows and columns
    are laid out from <code>0</code> to <code>n</code>, where <code>n</code> is the number specified in the
    call to the function &gtk-table-new;. For <code>rows = 2</code> and <code>columns = 2</code>, the layout
    is shown in figure <link linkend="figure-table-layout"> Layout of a 2 x 2 Table</link>. Note that the
    coordinate system starts in the upper left hand corner.
   </para>
   <figure id="figure-table-layout">
    <title>Layout of a 2 x 2 Table</title>
    <programlisting>
 0          1          2
0+----------+----------+
 |          |          |
1+----------+----------+
 |          |          |
2+----------+----------+
    </programlisting>
   </figure>
   <para>
    To place a widget into a table, the function &gtk-table-attach; can be used. The arguments are listed in
    the table <link linkend="table-gtk-table-attach">Table Attach</link>. The first argument
    <code>table</code> is the table you have created and the second <code>child</code> the widget you wish to
    place into the table. The left and right attach arguments specify where to place the widget, and how many
    boxes to use. If you want a button in the lower right table entry of a 2 x 2 table, and want it to fill
    that entry only, <code>left-attach</code> is <code>= 1</code>, <code>right-attach = 2</code>,
    <code>top-attach = 1</code>, <code>bottom-attach = 2</code>. Now, if you wanted a widget to take up the
    whole top row of a 2 x 2 table, you would use <code>left-attach = 0</code>, <code>right-attach = 2</code>,
    <code>top-attach = 0</code>, <code>bottom-attach = 1</code>.
   </para>

   <table id="table-gtk-table-attach">
    <caption>Arguments of the function <code>gtk-table-attach</code></caption>
    <colgroup>
     <col style="width:30%"/>
     <col style="width:70%"/>
    </colgroup>
    <tr>
     <th align="left">Argument</th>
     <th align="left">Description</th>
    </tr>
    <tr>
     <td colspan="2" style="border-top:2px solid #ff9900;"></td>
    </tr>
    <tr valign="top">
     <td><code>table</code></td>
     <td>The GtkTable to add a new widget to.</td>
    </tr>
    <tr valign="top">
     <td><code>child</code></td>
     <td>The widet to add.</td>
    </tr>
    <tr valign="top">
     <td><code>left-attach</code></td>
     <td>The column number to attach the left side of a child widget to.</td>
    </tr>
    <tr valign="top">
     <td><code>right-attach</code></td>
     <td>The column number to attach the right side of a child widget to.</td>
    </tr>
    <tr valign="top">
     <td><code>top-attach</code></td>
     <td>The row number to attach the top of a child widget to.</td>
    </tr>
    <tr valign="top">
     <td><code>bottom-attach</code></td>
     <td>The row number to attach the bottom of a child widget to.</td>
    </tr>
    <tr valign="top">
     <td><code>:xoptions</code></td>
     <td>Used to specify the properties of the child widget when the table is resized.
        The default value is <code>'(:expand :fill)</code>.</td>
    </tr>
    <tr valign="top">
     <td><code>:yoptions</code></td>
     <td>The same as <code>xoptions</code>, except this field determines behavior of vertical resizing.
        The default value is <code>'(:expand :fill)</code>.</td>
    </tr>
    <tr valign="top">
     <td><code>:xpadding</code></td>
     <td>An integer value specifying the padding on the left and right of the widget being added to the table.
        The default value is <code>0</code>.</td>
    </tr>
    <tr>
     <td colspan="2" style="border-top:1px solid #ff9900;"></td>
    </tr>
   </table>

   <para>
    The arguments <code>:xoptions</code> and <code>:yoptions</code> are of the enumeration type
    &gtk-attach-options; and used to specify packing options. The packing options can be OR'ed together to
    allow multiple options. In the Lisp binding a list of options is used to combine multiple options.
    Possible values of the enumeration type &gtk-attach-options; are listed in the table
    <link linkend="table-gtk-attach-options">GtkAttachOptions</link>.
   </para>
   <para>
    Padding is just like in boxes, creating a clear area around the widget specified in pixels and is
    controlled with the arguments <code>:xpadding</code> and <code>:ypadding</code>.
   </para>
   <table id="table-gtk-attach-options" frame='all'>
    <title>Values of the type GtkAttachOptions</title>
    <tgroup cols='2' align='left' colsep='0' rowsep='0'>
     <thead>
      <row>
       <entry>Value</entry>
       <entry>Description</entry>
      </row>
     </thead>
     <tbody>
      <row>
       <entry valign="top"><code>:fill</code></entry>
       <entry valign="top">
        If the table box is larger than the widget, and <code>:fill</code> is specified, the widget will
        expand to use all the room available.
       </entry>
      </row>
      <row>
       <entry valign="top"><code>:shrink</code></entry>
       <entry valign="top">
        If the table widget was allocated less space then was requested (usually by the user resizing the
        window), then the widgets would normally just be pushed off the bottom of the window and disappear.
        If <code>:shrink</code> is specified, the widgets will shrink with the table.
       </entry>
      </row>
      <row>
       <entry valign="top"><code>:expand</code></entry>
       <entry valign="top">
         This will cause the table to expand to use up any remaining space in the window.
       </entry>
      </row>
     </tbody>
    </tgroup>
   </table>
   <para>
    In the Lisp binding the arguments <code>:xoptions</code>, <code>:yoptions</code>, <code>:xpadding</code>,
    and <code>:ypadding</code> of the function &gtk-table-attach; are defined as keyword arguments with
    default values as shown in table <link linkend="table-gtk-table-attach">GtkTableAttach</link>. In the C
    library this is realized with a second function <code>gtk_table_attach_defaults()</code>. In the Lisp
    binding the function &gtk-table-attach-defaults; is a second equivalent implementation of
    &gtk-table-attach;, when using the default values of the keyword arguments.
   </para>
   <para>
    The functions &gtk-table-set-row-spacing; and &gtk-table-set-col-spacing; places spacing between the rows
    at the specified row or column. The first argument of the functions is a &gtk-table;, the second argument
    a row or a column and the third argument the spacing. Note that for columns, the space goes to the right
    of the column, and for rows, the space goes below the row.
   </para>
   <para>
    You can also set a consistent spacing of all rows and columns with the functions
    &gtk-table-set-row-spacings; and &gtk-table-set-col-spacings;. Both functions take a &gtk-table; as the
    first argument and the desired spacing <code>spacing</code> as the second argument. Note that with these
    calls, the last row and last column do not get any spacing.
   </para>
   <note>
    <para>
     &gtk-table; has been deprecated since GTK 3.4. It is recommended to use &gtk-grid; instead. &gtk-grid;
     provides the same capabilities as &gtk-table; for arranging widgets in a rectangular grid, but does
     support height-for-width geometry management, which is newly introduced for widgets in GTK 3. This
     chapter will vanish in the near future.
    </para>
   </note>
  </section>

  <section id="Table_Packing_Example">
   <title>Table Packing Example</title>
   <para>
    The figure <link linkend="figure-table-packing">Table Packing</link> is a window with three buttons in a
    2 x 2 table. The first two buttons are placed in the upper row. A third, quit button, is placed in the
    lower row, spanning both columns. The code of this example is shown in the example
    <link linkend="example-table-packing">Table Packing</link>.
   </para>
   <figure id="figure-table-packing">
    <title>Table Packing</title>
    <mediaobject>
     <imageobject>
      <imagedata fileref="figures/table-packing306x108.gif" format="gif"></imagedata>
     </imageobject>
    </mediaobject>
   </figure>
   <example id="example-table-packing">
    <title>Table Packing</title>
    <programlisting>
(defun example-table-packing ()
  (within-main-loop
    (let ((window (make-instance 'gtk-window
                                 :type :toplevel
                                 :title "Example Table Packing"
                                 :border-width 12
                                 :default-width 300))
          (table (make-instance 'gtk-table
                                :n-columns 2
                                :n-rows 2
                                :homogeneous t))
          (button1 (make-instance 'gtk-button
                                  :label "Button 1"))
          (button2 (make-instance 'gtk-button
                                  :label "Button 2"))
          (quit (make-instance 'gtk-button
                               :label "Quit")))
      (g-signal-connect window "destroy"
                        (lambda (widget)
                          (declare (ignore widget))
                          (leave-gtk-main)))
      (g-signal-connect quit "clicked"
                        (lambda (widget)
                          (declare (ignore widget))
                          (gtk-widget-destroy window)))
      (gtk-table-attach table button1 0 1 0 1)
      (gtk-table-attach table button2 1 2 0 1)
      (gtk-table-attach table quit    0 2 1 2)
      (gtk-container-add window table)
      (gtk-widget-show-all window))))
    </programlisting>
   </example>
   <para>
    Figure <link linkend="figure-table-packing-2">Table Packing</link> is an extended example to show the
    possibility to increase the spacing of the rows and columns. This is implemented through two toggle
    buttons which increase and decrease the spacings. Toggle buttons are described in
    <link linkend="Toggle_Button">Toggle Buttons</link> later in this tutorial. The code of
    <link linkend="figure-table-packing-2">Table Packing</link> is shown in example
    <link linkend="example-table-packing-2">Table Packing</link>.
   </para>
   <figure id="figure-table-packing-2">
    <title>Table Packing with more spacing</title>
    <mediaobject>
     <imageobject>
      <imagedata fileref="figures/table-packing-2-306x120.png" format="png"></imagedata>
     </imageobject>
    </mediaobject>
   </figure>
   <example id="example-table-packing-2">
    <title>Table Packing with more spacing</title>
    <programlisting>
(defun example-table-packing-2 ()
  (within-main-loop
    (let ((window (make-instance 'gtk-window
                                 :type :toplevel
                                 :title "Example Table Packing"
                                 :border-width 12
                                 :default-width 300))
          (table (make-instance 'gtk-table
                                :n-columns 2
                                :n-rows 2
                                :homogeneous t))
          (button1 (make-instance 'gtk-toggle-button
                                  :label "More Row Spacing"))
          (button2 (make-instance 'gtk-toggle-button
                                  :label "More Col Spacing"))
          (quit (make-instance 'gtk-button
                               :label "Quit")))
      (g-signal-connect window "destroy"
                        (lambda (widget)
                          (declare (ignore widget))
                          (leave-gtk-main)))
      (g-signal-connect button1 "toggled"
         (lambda (widget)
           (if (gtk-toggle-button-active widget)
               (progn
                 (gtk-table-set-row-spacings table 12)
                 (setf (gtk-button-label widget) "Less Row Spacing"))
               (progn
                 (gtk-table-set-row-spacings table 0)
                 (setf (gtk-button-label widget) "More Row Spacing")))))
      (g-signal-connect button2 "toggled"
         (lambda (widget)
           (if (gtk-toggle-button-active widget)
               (progn
                 (gtk-table-set-col-spacings table 12)
                 (setf (gtk-button-label widget) "Less Col Spacing"))
               (progn
                 (gtk-table-set-col-spacings table 0)
                 (setf (gtk-button-label widget) "More Col Spacing")))))
      (g-signal-connect quit "clicked"
                        (lambda (widget)
                          (declare (ignore widget))
                          (gtk-widget-destroy window)))
      (gtk-table-attach table button1 0 1 0 1)
      (gtk-table-attach table button2 1 2 0 1)
      (gtk-table-attach table quit    0 2 1 2)
      (gtk-container-add window table)
      (gtk-widget-show-all window))))
    </programlisting>
   </example>
  </section>
 </chapter>

 <appendix id="Licenses">
  <title>Licenses</title>
  <para>
   The GTK 3 Tutorial for Lisp and the presented examples have been collected from different sources.  The
   original sources have been modified to describe the Lisp binding.  Numerous examples are taken from C
   code and translated to Lisp.
  </para>
  <orderedlist>
   <listitem>
    GTK+ 2.0 Tutorial, Tony Gale, Ian Main &#x26; the GTK team,
    The GTK Tutorial is Copyright (C) 1997 Ian Main,
    Copyright (C) 1998-2002 Tony Gale.
   </listitem>
   <listitem>
    Multiline Text Editing Widget, Vijay Kumar B.,
    Copyright (C) 2005 Vijay Kumar B.
   </listitem>
   <listitem>
    GTK+ 2.0 Tree View Tutorial by Tim-Philipp Mueller
   </listitem>
   <listitem>
    GTK+ 3 Reference Manual
   </listitem>
   <listitem>
    GDK 3 Reference Manual
   </listitem>
   <listitem>
    GObject Reference Manual,
    Copyright (C) 2005 - 2012 The GNOME Project, see http://www.gtk.org/
   </listitem>
   <listitem>
    Menus and Toolbars, Stewart Weiss,
    <ulink url="http://www.compsci.hunter.cuny.edu/~sweiss/course_materials/csci493.70/lecture_notes/GTK_menus.pdf">
    Menus and Toolbars in GTK+</ulink>
   </listitem>
  </orderedlist>
  <para>
   Permission is granted to make and distribute verbatim copies of this manual
   provided the copyright notice and this permission notice are preserved on all copies.
   Permission is granted to copy and distribute modified versions of this document
   under the conditions for verbatim copying, provided that this copyright notice is
   included exactly as in the original, and that the entire resulting derived work is
   distributed under the terms of a permission notice identical to this one.
   Permission is granted to copy and distribute translations of this document into
   another language, under the above conditions for modified versions.
   If you are intending to incorporate this document into a published work, please
   contact the maintainer, and we will make an effort to ensure that you have the
   most up to date information available.
  </para>
  <para>
   There is no guarantee that this document lives up to its intended purpose. This is
   simply provided as a free resource. As such, the authors and maintainers of the
   information provided within can not make any guarantee that the information is
   even accurate.
  </para>
 </appendix>

</book>



















































